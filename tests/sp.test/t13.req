drop table if exists tt1
create table tt1 (i int)$$

create procedure txnins version 'a' {
local function main(t)
    local tab = db:table(t) 
    --no params to insert
    tab:insert() 
    return 0
end
}$$
put default procedure txnins 'a'
exec procedure txnins('tt1')
select * from tt1

create procedure txnins version 'b' {
local function main(t)
    local tab = db:table(t) 
    --no params to insert
    return tab:insert() 
end
}$$
put default procedure txnins 'b'
exec procedure txnins('tt1')
select * from tt1

create procedure txnins version 'c' {
local function main(t)
    local tab = db:table(t) 
    --misspelled column name i/id
    tab:insert({id = 1}) 
    return 0
end
}$$
put default procedure txnins 'c'
exec procedure txnins('tt1')
select * from tt1

create procedure txnins version 'd' {
local function main(t)
    local tab = db:table(t) 
    --misspelled column name i/id
    return tab:insert({id = 1}) 
end
}$$
put default procedure txnins 'd'
exec procedure txnins('tt1')
select * from tt1

create procedure txnins version 'e' {
local function main(t)
    local tab = db:table(t) 
    --incorrect bind of non int for column i
    tab:insert({i = 'a'}) 
    return 0
end
}$$
put default procedure txnins 'e'
exec procedure txnins('tt1')
select * from tt1


create procedure txnins version 'f' {
local function main(t)
    local tab = db:table(t) 
    --incorrect bind of non int for column i
    return tab:insert({i = 'a'}) 
end
}$$
put default procedure txnins 'f'
exec procedure txnins('tt1')
select * from tt1

--normal working case
create procedure txnins version 'norm' {
local function main(t)
    local tab = db:table(t) 
    return tab:insert({i = 1}) 
end
}$$
put default procedure txnins 'norm'
exec procedure txnins('tt1')
select * from tt1


--testing errors with insert have not broken triggers
drop table if exists t
CREATE TABLE t(i int, j int)$$
CREATE TABLE taudit(type cstring(4), tbl cstring(64), logtime datetime, i int, j int, old_i int, old_j int)$$
CREATE PROCEDURE taudit VERSION 'sample' {
local function main(event)
    local taudit = db:table('taudit')
    local chg
    if event.new ~= nil then
        chg = event.new
    end
    if chg == nil then
        chg = {}
    end
    if event.old ~= nil then
        for k, v in pairs(event.old) do
            chg['old_'..k] = v
        end
    end
    --test with bad colunm name for table should be 'type' 
    chg.errtype = event.type
    chg.tbl = event.name
    chg.logtime = db:now()
    return taudit:insert(chg)
end
}$$
CREATE LUA TRIGGER taudit ON (TABLE t FOR INSERT AND UPDATE AND DELETE)
INSERT INTO t VALUES(1,1),(1,2),(1,3),(1,4)
UPDATE t SET i = j WHERE j % 2 = 0
DELETE FROM t WHERE i % 2 <> 0
