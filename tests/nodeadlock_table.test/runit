#!/bin/bash
bash -n "$0" | exit 1
set -x
################################################################################

function getmaster {
    cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default 'exec procedure sys.cmd.send("bdb cluster")' | grep MASTER | cut -f1 -d":" | tr -d '[:space:]'
}

failexit()
{
    echo "Failed $1"
    exit -1
}


f1() {
    cdb2sql ${CDB2_OPTIONS} $dbnm default <<"EOF"
begin
insert into t1 (i,j,b) values (1, 1, x'abcd')
insert into t2 (i,j,b) values (1, 2, x'abcd')
commit
EOF
}

f2() {
    cdb2sql ${CDB2_OPTIONS} $dbnm default <<"EOF"
begin
insert into t2 (i,j,b) values (2, 3, x'dcba')
insert into t1 (i,j,b) values (2, 4, x'dcba')
commit
EOF
}



# debug=1

# args
dbnm=$1
    cdb2sql ${CDB2_OPTIONS} $dbnm default <<"EOF"
insert into t1 (i,j,b) values (11, 111, x'abcd')
insert into t1 (i,j,b) values (12, 112, x'abcd')
EOF


cluster=`cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default 'exec procedure sys.cmd.send("bdb cluster")' | grep lsn | cut -f1 -d':' `
for node in $cluster ; do
    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('debg 500')"
#    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('bdb verbdeadlock 1')"
#    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('on verbose_deadlocks')"
    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('bdb setattr DELAY_LOCK_TABLE_RECORD_C 1000')"
    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('print_deadlock_cycles on')"
    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('track_curtran_locks on')"
    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('reql events on')"
    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('reql events detailed on')"
#    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('reql trace')"
#    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('reql go')"
    cdb2sql ${CDB2_OPTIONS} $dbnm --host $node "exec procedure sys.cmd.send('on extended_sql_debug_trace')"
done

master=`getmaster`

echo turn off ordering
cdb2sql ${CDB2_OPTIONS} $dbnm --host $master "exec procedure sys.cmd.send('reorder_blkseq_no_deadlock off')"

echo run two transactions that will get in a deadlock
echo will see DEADLOCK-CYCLE: in db log
f1 &
f2 &

wait

cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "select 't1',* from t1 where i < 10 order by i" > content.out
cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "select 't2',* from t2 order by i" >> content.out

echo "t1	1	1	x'abcd'" > content.expected
echo "t1	2	4	x'dcba'" >> content.expected
echo "t2	1	2	x'abcd'" >> content.expected
echo "t2	2	3	x'dcba'" >> content.expected

if ! diff content.expected content.out ; then 
    failexit "content not what it is supposed to be"
fi

echo turn on ordering
cdb2sql ${CDB2_OPTIONS} $dbnm --host $master "exec procedure sys.cmd.send('reorder_blkseq_no_deadlock on')"

echo there should be NO dedlocks now
f1 &
f2 &

wait

cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "select 't1',* from t1 where i < 10 order by i" > content.out
cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "select 't2',* from t2 order by i" >> content.out

echo "t1	1	1	x'abcd'" > content.expected
echo "t1	1	1	x'abcd'" >> content.expected
echo "t1	2	4	x'dcba'" >> content.expected
echo "t1	2	4	x'dcba'" >> content.expected
echo "t2	1	2	x'abcd'" >> content.expected
echo "t2	1	2	x'abcd'" >> content.expected
echo "t2	2	3	x'dcba'" >> content.expected
echo "t2	2	3	x'dcba'" >> content.expected

if ! diff content.expected content.out ; then 
    failexit "content not what it is supposed to be"
fi

# try the update now

f3() 
{
    cdb2sql ${CDB2_OPTIONS} $dbnm default <<"EOF"
begin
update t1 set b = x'cccc', j = j+1 where i=1
update t2 set b = x'dddd', j = j+1 where i=1
commit
EOF
}

f4() 
{
    cdb2sql ${CDB2_OPTIONS} $dbnm default <<"EOF"
begin
update t2 set b = x'eeee', j = j+1 where i=2
update t1 set b = x'ffff', j = j+1 where i=2
commit
EOF
}

f3 &
f4 &
wait

cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "select 't1',* from t1 where i < 10 order by i" > content.out
cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "select 't2',* from t2 order by i" >> content.out

echo "t1	1	2	x'cccc'" > content.expected
echo "t1	1	2	x'cccc'" >> content.expected
echo "t1	2	5	x'ffff'" >> content.expected
echo "t1	2	5	x'ffff'" >> content.expected
echo "t2	1	3	x'dddd'" >> content.expected
echo "t2	1	3	x'dddd'" >> content.expected
echo "t2	2	4	x'eeee'" >> content.expected
echo "t2	2	4	x'eeee'" >> content.expected

if ! diff content.expected content.out ; then 
    failexit "content not what it is supposed to be"
fi



# closing operations

logfl=`cdb2sql ${CDB2_OPTIONS} --tabs $dbnm --host $master "exec procedure sys.cmd.send('reql stat')" | grep "Eventlog enabled" | cut -f2 -d ':'`
if [ "x$logfl" == "x" ]; then
    cdb2sql ${CDB2_OPTIONS} --tabs $dbnm --host $master "exec procedure sys.cmd.send('reql stat')"
    failexit "cant find events logfile in reql stat on $master"
fi

cdb2sql ${CDB2_OPTIONS} $dbnm --host $master "exec procedure sys.cmd.send('reql events roll')"

sleep 4

if [ $master != `hostname` ]; then
    scp $master:$logfl $logfl
fi

logflunziped=${logfl}.unzipped 
zcat $logfl > $logflunziped

ddlk_cnt=`grep -c deadlock_cycle $logflunziped `
if [ $ddlk_cnt != 1 ]; then
    failexit 'expected only one deadlock in eventslog (from first trans)'
fi

cnonce_cnt=`grep deadlock_cycle $logflunziped | head -1 | sed 's/}/}\n/' | grep -c cnonce`
if [ $cnonce_cnt != 2 ]; then
    failexit 'expected two cnonces reported part of deadlock_cycle in eventslog'
fi

echo "Testcase passed."
