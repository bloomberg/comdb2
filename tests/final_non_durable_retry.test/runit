#!/usr/bin/env bash
bash -n "$0" | exit 1

. ${TESTSROOTDIR}/tools/cluster_utils.sh
. ${TESTSROOTDIR}/tools/runit_common.sh
. ${TESTSROOTDIR}/tools/hrtime.sh

export debug=1

[[ $debug == "1" ]] && set -x

function force_all_non_durable
{
    typeset val=$1
    if [[ -z "$CLUSTER" ]] ; then
        $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "put tunable 'debug_force_non_durable' = $val"
    else
        for n in $CLUSTER ; do
            $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $n "put tunable 'debug_force_non_durable' = $val"
        done
    fi
}

function hide_non_durable_rcode
{
    typeset val=$1
    if [[ -z "$CLUSTER" ]] ; then
        $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "put tunable 'hide_non_durable_rcode' = $val"
    else
        for n in $CLUSTER ; do
            $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $n "put tunable 'hide_non_durable_rcode' = $val"
        done
    fi
}

function create_table
{
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create table t1 (a int primary key)"
}

function get_not_durable_commits
{
    typeset -l master=$(get_master)
    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME --host $master "select value from comdb2_metrics where name = 'not_durable_commits'")
    echo "$x"
}

# Valid insert is never replicated durably ..
# hide_non_durable_rcode should pretend the final retry is durable
function hide_non_durable_good_insert
{
    typeset -l before_not_durable=$(get_not_durable_commits)
    typeset -l after_not_durable=0

    hide_non_durable_rcode 1
    force_all_non_durable 1
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 values (1)" 2>&1)
    [[ "$x" != *"rows inserted=1"* ]] && failexit "final insert should have succeeded"
    echo "$x"
    after_not_durable=$(get_not_durable_commits)
    hide_non_durable_rcode 0
    force_all_non_durable 0
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "delete from t1 where 1" >/dev/null 2>&1
}

function show_non_durable_good_insert
{
    typeset -l before_not_durable=$(get_not_durable_commits)
    typeset -l after_not_durable=0

    hide_non_durable_rcode 0
    force_all_non_durable 1
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 values (1)" 2>&1)
    [[ "$x" != *"Non-durable write"* ]] && failexit "final insert should been non-durable"
    echo "$x"
    after_not_durable=$(get_not_durable_commits)
    hide_non_durable_rcode 0
    force_all_non_durable 0
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "delete from t1 where 1" >/dev/null 2>&1
}

function show_non_durable_constraint_violation
{
    typeset -l before_not_durable=$(get_not_durable_commits)
    typeset -l after_not_durable=0

    # First insert should succeed
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 values (1)"
    [[ $? -ne 0 ]] && failexit "first insert should have succeeded"

    hide_non_durable_rcode 0
    force_all_non_durable 1
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 values (1)" 2>&1)
    [[ "$x" != *"Non-durable write"* ]] && failexit "final insert should have been non-durable"
    echo "$x"
    after_not_durable=$(get_not_durable_commits)
    hide_non_durable_rcode 0
    force_all_non_durable 0
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "delete from t1 where 1" >/dev/null 2>&1
}

# Insert non-durable record which should result in a constraint violation
# hide_non_durable_rcode shows final constraint-violation rather than non-durable
function hide_non_durable_constraint_violation
{
    typeset -l before_not_durable=$(get_not_durable_commits)
    typeset -l after_not_durable=0

    # First insert should succeed
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 values (1)"
    [[ $? -ne 0 ]] && failexit "first insert should have succeeded"

    hide_non_durable_rcode 1
    force_all_non_durable 1
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 values (1)" 2>&1)
    [[ "$x" != *"add key constraint duplicate key"* ]] && failexit "final insert should have failed with constraint violation"
    echo "$x"
    after_not_durable=$(get_not_durable_commits)
    hide_non_durable_rcode 0
    force_all_non_durable 0
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "delete from t1 where 1" >/dev/null 2>&1
}

function run_test
{
    hide_non_durable_good_insert
    show_non_durable_good_insert
    hide_non_durable_constraint_violation
    show_non_durable_constraint_violation
}

create_table
run_test

echo "Success!"
