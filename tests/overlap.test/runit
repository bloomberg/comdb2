#!/bin/bash
bash -n "$0" | exit 1

# Grab my database name.
dbnm=$1

# Verify that the user at least supplied a dbname
if [[ -z "$dbnm" ]]; then

    echo "Testcase requires <dbname> argument."
    exit 1

fi

# Enable or disable debugging.
debug=0

# Enable background-debugging.
bgdebug=0

# Set the maximum number of added records for t1.
maxt1=10

# Number of random writes per writer.
randwr=1000

# period len
plen=5000

# period step
pstep=10

# Keep track of select iterations.
iter=1

# Set to 0 to disable t1 inserts.
ins_t1=1

# Set to 0 to disable t1 updates.
upd_t1=1

# Set to 0 to disable t1 deletes.
del_t1=0

# Does t1 have any writes- calculated at end.
wr_t1=1

# 'Background' tmpfile.
bgtmpfl=${TMPDIR}/cdb2tst_bg.$$.tmp

# Counter.
ii=0

# Number of background writers.
nwrts=5

# Enable or disable a hello-message from the bg writers.
bghlo=0

# Variable to maintain the pids of the bkground writes.
bkpid=-1

# Count of the bkground pids that are still running.
bkcnt=-1

# Set the background pids to -1.
while [[ $ii -lt $nwrts ]]; do

    # Reset to -1.
    bkpid[$ii]=-1

    # Increment.
    let ii=ii+1

done

# Error/quit function.
function errquit
{
    typeset msg=$1
    typeset cnt=0

    # Enable debugging.
    [[ "$debug" == "1" ]] && set -x

    echo "ERROR: $msg"
    echo "Testcase failed."

    # Check for the background writer.
    while [[ $cnt -lt $nwrts ]]; do

        # Kill each pid
        [[ ${bkpid[$cnt]} != "-1" ]] && kill -9 ${bkpid[$cnt]} >/dev/null 2>&1

        # Reset to -1
        bkpid[$cnt]=-1

        let cnt=cnt+1

    done

    # Exit test.
    exit 1
}

# Insert a random record into t1
function insert_rand_t1
{
    typeset db=$1
    typeset id
    typeset s
    typeset e

    # Enable debugging if necessary
    [[ "$debug" == "1" ]] && set -x

    # Create a random id for t1
    id=$(( RANDOM % (maxt1) ))

    s=$(( RANDOM % plen))
    e=$(( s + (RANDOM % pstep) + 1 ))

    # Insert the record
    if [[ "1" == "$debug" ]]; then
        echo "cdb2sql ${CDB2_OPTIONS} $db default \"insert into t1 values ($id, $s, $e)\""
        cdb2sql ${CDB2_OPTIONS} $db default "insert into t1 values ($id, $s, $e)"
    else
        cdb2sql ${CDB2_OPTIONS} $db default "insert into t1 values ($id, $s, $e)" > /dev/null 2>&1
    fi

    # If the 'bgdebug' flag is set, write this to a file. */
    if [[ "1" == "$bgdebug" ]]; then

        echo "cdb2sql ${CDB2_OPTIONS} $db default \"insert into t1 values ($id, $s, $e)\"" >> $bgtmpfl
    fi

    return 0
}

# Update a random record in t1
# Update a random record in t1
function update_rand_t1
{
    typeset db=$1
    typeset id
    typeset upid
    typeset updateid=0
    typeset s
    typeset e

    # Enable debugging if necessary
    [[ "$debug" == "1" ]] && set -x

    # Create a random id for t1
    id=$(( RANDOM % (maxt1) )) ; upid=$(( RANDOM % (maxt1) ))

    s=$(( RANDOM % plen))
    e=$(( s + (RANDOM % pstep) + 1 ))

    # Make the blob a NULL once every 5 times
    if [[ "0" == $(( RANDOM % 5 )) ]]; then
        updateid=1
    fi

    # Update a record, discard the result
    if [[ "1" == "$debug" ]]; then

        if [[ "1" == "$updateid" ]]; then

            echo "cdb2sql ${CDB2_OPTIONS} $db default \"update t1 set id=$upid where id=$id\""
            cdb2sql ${CDB2_OPTIONS} $db default "update t1 set id=$upid where id=$id"

        else

            echo "cdb2sql ${CDB2_OPTIONS} $db default \"update t1 set s=$s, e=$e where id=$id\""
            cdb2sql ${CDB2_OPTIONS} $db default "update t1 set s=$s, e=$e where id=$id" > /dev/null 2>&1

        fi

    else
        if [[ "1" == "$updateid" ]]; then
            cdb2sql ${CDB2_OPTIONS} $db default "update t1 set id=$upid where id=$id" > /dev/null 2>&1
        else
            cdb2sql ${CDB2_OPTIONS} $db default "update t1 set s=$s, e=$e where id=$id" > /dev/null 2>&1
        fi
    fi

    # If the 'bgdebug' flag is set, write this to a file. */
    if [[ "1" == "$bgdebug" ]]; then

        if [[ "1" == "$updateid" ]]; then
            echo "cdb2sql ${CDB2_OPTIONS} $db default \"update t1 set id=$upid where id=$id\"" >> $bgtmpfl
        else
            echo "cdb2sql ${CDB2_OPTIONS} $db default \"update t1 set s=$s, e=$e where id=$id\"" >> $bgtmpfl
        fi

    fi

    return 0
}

# Delete a random record in t1
function delete_rand_t1
{
    typeset db=$1
    typeset id
    typeset x
    typeset s

    # Enable debugging if necessary
    [[ "$debug" == "1" ]] && set -x

    # Create a random id for t1
    x=$RANDOM ; id=$(( x % (maxt1) ))
    s=$(( RANDOM % 5000))

    # Delete a record, discard the result
    if [[ "1" == "$debug" ]]; then
        echo "cdb2sql ${CDB2_OPTIONS} $db default \"delete from t1 where id=$id and s=$s\""
        cdb2sql ${CDB2_OPTIONS} $db default "delete from t1 where id=$id and s=$s"
    else
        cdb2sql ${CDB2_OPTIONS} $db default "delete from t1 where id=$id and s=$s" > /dev/null 2>&1
    fi

    # If the 'bgdebug' flag is set, write this to a file. */
    if [[ "1" == "$bgdebug" ]]; then

        echo "cdb2sql ${CDB2_OPTIONS} $db default \"delete from t1 where id=$id and s=$s\"" >> $bgtmpfl

    fi

    return 0
}

# Perform some random writes
function randomwrites
{
    typeset iter=$1
    typeset ii=0

    # Say 'hello'.
    [[ "1" == "$bghlo" ]] && echo "Background writer executing."

    # Perform some random writes in a loop
    while [[ $ii -lt $iter ]]; do

        # Insert a record into t1
        [[ "1" == "$ins_t1" ]] && insert_rand_t1 $dbnm

        # Update a random record in t1
        [[ "1" == "$upd_t1" ]] && update_rand_t1 $dbnm

        # Delete a record from t1
        [[ "1" == "$del_t1" ]] && delete_rand_t1 $dbnm

        # Increment my counter
        let ii=ii+1

    done

    return 0
}

function overlap_verify
{
    typeset tbl=$1
    typeset iter=$2
    typeset tmfl
    typeset ckfl

    # Enable debugging if necessary
    [[ "$debug" == "1" ]] && set -x

    # Create a new-tmpfile for this select with a new name: we might want view.
    tmfl=$(pwd)/verify_${tbl}.out.txt

    # For the check-file name
    ckfl=$(pwd)/verify_${tbl}.txt

    # Perform the select.
    cdb2sql ${CDB2_OPTIONS} $dbnm default "select * from t1, t1 as t1v where t1v.rowid != t1.rowid and t1v.id = t1.id and (t1v.s < t1.e or t1v.s is null or t1.e is null) and (t1v.e > t1.s or t1.s is null or t1v.e is null)" > $tmfl 2>&1

    # Diff this against our output
    diff $ckfl $tmfl > /dev/null 2>&1

    # Check return code
    if [[ $? != 0 ]]; then

        # echo bad errmsg.
        echo "Overlapping data detected."

        # Tell the user how to see this.
        echo "Run 'diff $ckfl $tmfl' to see the error."

        # Return a bad rcode.
        return 1

    fi

    # Great- success!
    return 0
}

# Trap to errquit if the user presses Ctrl-C
trap "errquit \"Cancelling test on INT EXIT\"" INT EXIT

cdb2sql ${CDB2_OPTIONS} $dbnm default - <<EOF
drop table if exists t1
create table t1 {
tag ondisk
{
   int  id
   int  s
   int  e
}
keys {
    dup "ID" = id
    dup "PERIOD" = s + e
    "PK" = id + s + e
}
constraints {
    no_overlap "PK" -> s : e
}
}\$\$
EOF

# If bgdebugging is enabled, print the filename.
if [[ "1" == "$bgdebug" ]]; then

    # Clear it out.
    > $bgtmpfl

    echo "Enabled 'background' debugging for writes in file '$bgtmpfl'."
fi

# Select t1 back.
echo "Selecting t1."
cdb2sql ${CDB2_OPTIONS} $dbnm default "select * from t1 order by id" > select_t1.txt
echo "Verifying t1."
cdb2sql ${CDB2_OPTIONS} $dbnm default "select * from t1, t1 as t1v where t1v.rowid != t1.rowid and t1v.id = t1.id and (t1v.s < t1.e or t1v.s is null or t1.e is null) and (t1v.e > t1.s or t1.s is null or t1v.e is null)" > verify_t1.txt 2>&1

ii=0
# Print status message.
echo "Writing random records from $nwrts background processes."
# Start my background writers
while [[ $ii -lt $nwrts ]]; do

    # Start a loop of random-writes.
    randomwrites $randwr &

    # Retrieve the pid.
    bkpid[$ii]=$!

    echo "Background write $ii pid ${bkpid[$ii]}"

    # Increment.
    let ii=ii+1

done

# echo a status message.
echo "Select and verify the overlapping results."

# Verify the pid in a loop.
while [[ "$bkcnt" != "0" ]];  do

    #overlap_verify t1 $iter
    #[[ "$?" != "0" ]] && errquit "Unexpected overlapping data in t1."

    # Increment iter.
    let iter=iter+1

    # Reset bkcnt.
    bkcnt=0

    # Reset counter.
    ii=0

    # Check my writer-pids in a loop.
    while [[ $ii -lt $nwrts ]]; do

        # Check the writer pid again
        if [[ "-1" != ${bkpid[$ii]} ]]; then

            # Is this still alive?
            ps -p ${bkpid[$ii]} >/dev/null 2>&1

            # It takes only one-runner to break out of the loop.
            if [[ $? == 0 ]] ; then

                # We found a running pid- increment bkcnt.
                let bkcnt=bkcnt+1

            else

                # echo a message while I'm debugging this.
                echo "Writer pid ${bkpid[$ii]} has completed."

                # Reset this so I don't keep checking for it.
                bkpid[$ii]=-1

            fi
        fi

        # Go to next pid
        let ii=ii+1

    done

done

overlap_verify t1 $iter
[[ "$?" != "0" ]] && errquit "Unexpected overlapping data in t1."

# Remove trap-command.
trap - INT EXIT

# Select t1 back.
echo "Selecting t1."
cdb2sql ${CDB2_OPTIONS} $dbnm default "select * from t1 order by id" > select_t1_final.txt

# See if t1 was updated during this test.
wr_t1=$(( upd_t1 + del_t1 + ins_t1 ))

# Diff the current t1 against the original snapshot.
diff ./select_t1.txt $select_t1_final >/dev/null 2>&1

# If this is the same, something went wrong.
if [[ "0" != "$wr_t1" && $? == 0 ]]; then

    # echo testcase is broken message.
    echo "Testcase is broken: the post-commit t1 should have changed."

    # Tell the user how to see this.
    echo "Run 'diff $(pwd)/{select_t1.txt select_t1_final.txt}' to see the error."

    exit 1

fi

echo "Testcase passed."

exit 0
