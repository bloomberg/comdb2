#!/usr/bin/env bash
bash -n "$0" | exit 1

set -x

source ${TESTSROOTDIR}/tools/runit_common.sh
source ${TESTSROOTDIR}/tools/cluster_utils.sh

export NRECS=10
export comdb2ar=${COMDB2AR_EXE}

export FIGLET=$(which figlet)

dbname=$1
dgpid=0
first=""
cluster_count=0
do_gcore=0
NRUNS=100
#SLEEPAMOUNT=300
SLEEPAMOUNT=3000
KILL_WAIT_TIME=10
SLEEP_BETWEEN_CHECKS=.5
PIDs=""
firstNode=""
lastNode=""

export NOSOURCE=0
if [[ $DBNAME == *"nosourcegenerated"* ]]; then
    NOSOURCE=1
fi
export FIRSTFILE=0
if [[ $DBNAME == *"firstfilegenerated"* ]]; then
    FIRSTFILE=1
fi

if [[ -z "$TEST_TIMEOUT" ]]; then
    export TEST_TIMEOUT=5m
fi

function cleanFailExit()
{
    cleanupabort
    failexit $@
}

function downgradeonce()
{
    local dbname=$1
    local mnode=`getmaster`
    echo "== downgrading $mnode"
    $CDB2SQL_EXE ${CDB2_OPTIONS} --host $mnode $dbname "exec procedure sys.cmd.send('downgrade')"
}

function downgrade()
{
    local dbname=$1
    local sleepamount=${2:-4}
    while true; do
        sleep $sleepamount
        local mnode=`getmaster`
        echo "== downgrading $mnode"
        $CDB2SQL_EXE ${CDB2_OPTIONS} --host $mnode $dbname "exec procedure sys.cmd.send('downgrade')"
    done
}

function cleanup_abort()
{
    # If pkill is always available, use pkill -F fl.pid
    # fixme
    #kill -6 $(cat $REPL_DBDIR/${REPL_DBNAME}.pid)
    [[ $dgpid != 0 ]] && kill -9 $dgpid
}

function wait_for_catchup()
{
    local _repl_dbname=$1
    local _repl_host=$2
    local start=$SECONDS
    local mnode=""
    local c_lsn=""
    local r_lsn=""

    echo "== Comparing source against $_repl_dbname@$_repl_host"

    while [[ -z "$mnode" ]] || [[ -z "$c_lsn" ]] || [[ -z "$r_lsn" ]] || [[ "$c_lsn" -ne "$r_lsn" ]]; do
        sleep 0.5
        elapsed=$((SECONDS-start))
        if [[ $elapsed -gt $SLEEPAMOUNT ]] ; then
            break;
        fi

        mnode=`getmaster`
        if [[ -z "$mnode" ]]; then
            continue;
        fi
        c_lsn=`$CDB2SQL_EXE -admin --tabs $CDB2_OPTIONS $dbname --host $mnode 'select lsn from comdb2_transaction_logs(NULL, NULL, 4) limit 1' | tr -d {} | cut -f2 -d":"`
        r_lsn=`$CDB2SQL_EXE -admin --tabs $CDB2_OPTIONS ${_repl_dbname} --host ${_repl_host} 'select lsn from comdb2_transaction_logs(NULL, NULL, 4) limit 1' | tr -d {} | cut -f2 -d":"`
    done

    if [[ "$c_lsn" -ne "$r_lsn" ]] ; then
        cleanFailExit "The wait_for_lsn is not enough and we need the extra sleep because lsn on replicant can move ahead--as local log--then roll back"
    else
        echo "comdb2_transaction_logs are the same, continue"
    fi
}

function verify_fanout_overrides()
{
    local repl_metadb_name=$1
    local repl_metadb_host=$2
    local parent_db=$3

    # Add a fanout override live
    cdb2sql ${CDB2_OPTIONS} --host $repl_metadb_host $repl_metadb_name "exec procedure sys.cmd.send('physrep_fanout_override livetst 99')"

    # Grab all of the fanout overrides
    x=$(cdb2sql ${CDB2_OPTIONS} --host $repl_metadb_host $repl_metadb_name "exec procedure sys.cmd.send('physrep_fanout_dump')")

    # Verify the 2 fanout lrl configurations
    if [[ $x != *"fanouttest fanout 100"* ]]; then
        cleanFailExit "fanouttest not set to 100"
    fi

    if [[ $x != *"fanouttest2 fanout 50"* ]]; then
        cleanFailExit "fanouttest2 not set to 50"
    fi

    if [[ $x != *"$DBNAME fanout 3"* ]]; then
        cleanFailExit "$DBNAME not set to 3"
    fi

    if [[ $x != *"livetst fanout 99"* ]]; then
        cleanFailExit "livetst not set to 99"
    fi
}

function create_physrep_tables()
{
    local repl_metadb_name=$1
    local repl_metadb_host=$2

    if [[ "$FIRSTFILE" == "1" ]]; then
        cdb2sql ${CDB2_OPTIONS} --host $repl_metadb_host $repl_metadb_name "CREATE TABLE comdb2_physreps(dbname CSTRING(60), host CSTRING(120), file INT, offset INT, firstfile INT, last_keepalive DATETIME, state CSTRING(60), UNIQUE (dbname, host))"
    else
        cdb2sql ${CDB2_OPTIONS} --host $repl_metadb_host $repl_metadb_name "CREATE TABLE comdb2_physreps(dbname CSTRING(60), host CSTRING(120), file INT, offset INT, last_keepalive DATETIME, state CSTRING(60), UNIQUE (dbname, host))"
    fi

    if [ $? -ne 0 ]; then
        cleanFailExit "failed to create table on $repl_metadb_name@$repl_metadb_host"
    fi

    $CDB2SQL_EXE ${CDB2_OPTIONS} --host $repl_metadb_host $repl_metadb_name "CREATE TABLE comdb2_physrep_connections(dbname CSTRING(60), host CSTRING(120), source_dbname CSTRING(60), source_host CSTRING(120), UNIQUE (dbname, host, source_dbname, source_host), FOREIGN KEY(dbname, host) REFERENCES comdb2_physreps(dbname, host) ON DELETE CASCADE)"
    if [ $? -ne 0 ]; then
        cleanFailExit "failed to create table on $repl_metadb_name@$repl_metadb_host"
    fi

    cdb2sql ${CDB2_OPTIONS} --host $repl_metadb_host $repl_metadb_name "CREATE TABLE comdb2_physrep_sources(dbname CSTRING(60), host CSTRING(120), source_dbname CSTRING(60), source_host CSTRING(120), UNIQUE (dbname, host, source_dbname, source_host))"
    if [ $? -ne 0 ]; then
        cleanFailExit "failed to create table on $repl_metadb_name@$repl_metadb_host"
    fi

    echo "Physrep tables created"
}

function add_to_physrep_sources() {
    local _repl_metadb_name=$1
    local _repl_metadb_host=$2
    local _source_dbname=$3
    local _source_host=$4
    local _repl_dbname=$5
    local _repl_host=$6

    echo "== Adding ${_source_dbname}@${_source_host} -> ${_repl_dbname}@${_repl_host} to comdb2_physrep_sources table =="

    cdb2sql ${CDB2_OPTIONS} --host ${_repl_metadb_host} ${_repl_metadb_name} "INSERT INTO comdb2_physrep_sources VALUES ('${_repl_dbname}', '${_repl_host}', '${_source_dbname}', '${_source_host}')"
    #if [ $? -ne 0 ]; then
    #    cleanFailExit "failed to insert record in ${_repl_metadb_name}@${_repl_metadb_host}"
    #fi
}

function verify_lsn_db_node()
{
    local db=$1
    local node=$2

    file=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} $db "select logfile from comdb2_cluster where host='$node'")
    offset=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} $db "select logoffset from comdb2_cluster where host='$node'")

    if [[ "$file" == 0 || "$offset" == 0 || "$file" == "2147483647" || "$offset" == "2147483647" ]]; then
        while :; do
            echo "Error, have zero lsn $file:$offset for $db $node"
            sleep 1
        done
        #cleanFailExit "Invalid lsn for $db node $node, $file:$offset"
    fi
}

function verify_physrep_lsns()
{
    echo "== Verifying physrep lsns =="
    local _repl_dbname_prefix=$1
    local _repl_clus_dbname=$2
    if [[ -z "$CLUSTER" ]]; then
        node=$(hostname)
        _repl_dbname=${_repl_dbname_prefix}_${node}

        verify_lsn_db_node $_repl_clus_dbname $node
        verify_lsn_db_node $_repl_dbname $node

        # First check 'clustered' physrep
    else
        for node in $CLUSTER; do
            _repl_dbname=${_repl_dbname_prefix}_${node}
            verify_lsn_db_node $_repl_clus_dbname $node
            verify_lsn_db_node $_repl_dbname $node
        done
    fi
}

function restart_source_nodes()
{
    echo "== Restarting source nodes =="
    pushd $DBDIR
    if [ -n "$CLUSTER" ]; then
        for node in $CLUSTER ; do
            if [ $node == `hostname` ] ; then
                PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${node}.pid"
                $COMDB2_EXE ${DBNAME} ${PARAMS} &> $LOGDIR/${DBNAME}.${node}.db &
            else
                PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${node}.pid"
                CMD="cd ${DBDIR}; source ${REP_ENV_VARS} ; $COMDB2_EXE ${DBNAME} ${PARAMS} 2>&1 | tee $TESTDIR/${DBNAME}.db"
                ssh -n -o StrictHostKeyChecking=no -tt $node ${CMD} &> $LOGDIR/${DBNAME}.${node}.db &
                echo $! > ${TMPDIR}/${DBNAME}.${node}.pid
            fi
        done

        for node in $CLUSTER ; do
            echo "$DBNAME: waiting until ready"
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host $node ${DBNAME} 'select 1' 2>/dev/null)
            while [[ "$out" != "1" ]]; do
                sleep $SLEEP_BETWEEN_CHECKS
                out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host $node ${DBNAME}  'select 1' 2>/dev/null)
            done
        done

    else
        node=$(hostname)
        PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.pid"
        echo "$COMDB2_EXE ${DBNAME} ${PARAMS} &> $LOGDIR/${DBNAME}.db"
        $COMDB2_EXE ${DBNAME} ${PARAMS} &> $LOGDIR/${DBNAME}.db &

        echo "$DBNAME: waiting until ready"
        out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host $node ${DBNAME} 'select 1' 2>/dev/null)
        while [[ "$out" != "1" ]]; do
            sleep $SLEEP_BETWEEN_CHECKS
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host $node ${DBNAME} 'select 1' 2>/dev/null)
        done
    fi
    popd
}

function kill_source_nodes()
{
    echo "== Killing source nodes =="
    pushd $DBDIR
    export LOGDIR=$TESTDIR/logs
    if [ -n "$CLUSTER" ]; then
        for node in $CLUSTER ; do
            kill -9 $(cat ${TMPDIR}/${DBNAME}.${node}.pid)
            mv --backup=numbered $LOGDIR/${DBNAME}.${node}.db $LOGDIR/${DBNAME}.${node}.db.1
            #mv --backup=numbered $LOGDIR/${DBNAME}.${node}.db $LOGDIR/${DBNAME}.${node}.db.1
        done
    else
        kill -9 $(cat ${TMPDIR}/${DBNAME}.pid)
        mv --backup=numbered $LOGDIR/${DBNAME}.db $LOGDIR/${DBNAME}.db.1
    fi
    popd
}

function verify_fanout_myoverride()
{
    echo "== Verify fanout myoverride =="
    local _dbname=$1
    local _dbdir=$2

    if [[ -z "$CLUSTER" ]]; then # Standalone
        logFile=$TESTDIR/logs/${_dbname}.${node}.log
        egrep "db_comdb_physrep_tunables: fanout for $DBNAME is 3" $logFile
        if [[ $? -ne 0 ]]; then
            cleanFailExit "fanout for $DBNAME is not 1"
        fi
    else
        found=0
        for node in $CLUSTER ; do
            logFile=$TESTDIR/logs/${_dbname}.${node}.log
            egrep "db_comdb_physrep_tunables: fanout for $DBNAME is 3" $logFile
            if [[ $? -eq 0 ]]; then
                found=1
            fi
        done
        if [[ $found -ne 1 ]]; then
            cleanFailExit "fanout for $DBNAME is not 3"
        fi
    fi
}

function count_revconn()
{
    typeset count=0
    for node in $CLUSTER ; do
        x=$(cdb2sql ${CDB2_OPTIONS} --tabs --host $node ${REPL_CLUS_DBNAME} "exec procedure sys.cmd.send('stat thr')" | grep "reversesql" | wc -l)
        count=$((count+x))
    done
    echo $count
}

function count_standalone_revconn()
{
    local dbname=$1
    local node=$2
    x=$(${CDB2SQL_EXE} ${CDB2_OPTIONS} --tabs --host $node $dbname "exec procedure sys.cmd.send('stat thr')" | grep "reversesql" | wc -l)
    echo $x
}

function block_for_standalone_revconn()
{
    echo "== Blocking for standalone revconn =="
    local dbname=$1
    local node=$2
    local blkcnt=$3
    local count=0
    local cnt=0
    
    cnt=$(count_standalone_revconn $dbname $node)
    while [[ "$cnt" -ne $blkcnt ]]; do
        let count=count+1
        echo "Count-revconn is $cnt not $blkcnt for $dbname $node"
        sleep 1
        cnt=$(count_standalone_revconn $dbname $node)
    done
}

function block_for_clustered_revconn()
{
    echo "== Blocking for single clustered revconn =="
    local count=0

    cnt=$(count_revconn)
    while [[ "$cnt" -ne 1 ]]; do
        let count=count+1
        echo "Count-revcon is $cnt not 1, waiting for only 1 reversesql to start, count $count"
        sleep 1
        cnt=$(count_revconn)
    done
}

# Set up intermediary revconn source by cluster
function revconn_source_cluster()
{
    echo "== physrep revconn source cluster =="

    # Remove all physrep sources
    $CDB2SQL_EXE ${CDB2_OPTIONS} $REPL_META_DBNAME --host ${REPL_META_HOST} "delete from comdb2_physrep_sources where 1"

    # Block until revcons are 0
    for node in $CLUSTER ; do
        dbname="${REPL_DBNAME_PREFIX}_${node}"
        block_for_standalone_revconn $dbname $node 0
    done

    # Identify the first node of PHYS_REP_TIERED_CLUS as 'foo', the others as 'bar'
    first=""
    for node in $CLUSTER ; do
        cluster="bar"
        if [[ -z "$first" ]]; then
            first=$node
            cluster="foo"
        fi

        # Add cluster to all other dbs
        for node2 in $CLUSTER ; do
            $CDB2SQL_EXE ${CDB2_OPTIONS} $REPL_META_DBNAME --host $node2 "exec procedure sys.cmd.send('machine_cluster add $node $cluster')"
            $CDB2SQL_EXE ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node2 "exec procedure sys.cmd.send('machine_cluster add $node $cluster')"
            dbname=${REPL_DBNAME_PREFIX}_${node2}
            $CDB2SQL_EXE ${CDB2_OPTIONS} $dbname --host $node2 "exec procedure sys.cmd.send('machine_cluster add $node $cluster')"
        done

    done

    # Add reverse-connection sources by cluster
    #
    # The 'first' node is on the 'foo' cluster, a 'bar' source machine should 
    # start a reverse-connection to it
    first=""
    for node in $CLUSTER ; do
        source_cluster="foo"
        target_cluster="bar"
        if [[ -z "$first" ]] ; then
            first=$node
            source_cluster="bar"
            target_cluster="foo"
        fi

        dbname="${REPL_DBNAME_PREFIX}_${node}"
        add_to_physrep_sources ${REPL_META_DBNAME} ${REPL_META_HOST} ${REPL_CLUS_DBNAME} $source_cluster ${dbname} ${target_cluster}
    done

    # Wait for all of these to have a reverse-conn thread
    for node in $CLUSTER ; do
        dbname="${REPL_DBNAME_PREFIX}_${node}"
        block_for_standalone_revconn $dbname $node 1
    done

    # Create table, add some records
    $CDB2SQL_EXE ${CDB2_OPTIONS} $DBNAME default "create table t1(a int)"
    $CDB2SQL_EXE ${CDB2_OPTIONS} $DBNAME default "insert into t1 select * from generate_series(1, 1000)"

    # Block until all the standalone reversconns have these records
    for node in $CLUSTER ; do
        dbname="${REPL_DBNAME_PREFIX}_${node}"
        x=$($CDB2SQL_EXE --tabs ${CDB2_OPTIONS} --host $node $dbname "select count(*) from t1" 2>/dev/null)
        while [[ "$x" -ne "1000" ]]; do
            sleep 1
            x=$($CDB2SQL_EXE --tabs ${CDB2_OPTIONS} --host $node $dbname "select count(*) from t1" 2>/dev/null)
        done
        echo "Db $dbname on node $node has caught up"
    done

    $CDB2SQL_EXE ${CDB2_OPTIONS} $DBNAME default "drop table t1"
}

# Set up intermediary revconn source by class
function revconn_source_class()
{
    echo "== physrep revconn source class =="

    # Remove all physrep sources
    $CDB2SQL_EXE ${CDB2_OPTIONS} $REPL_META_DBNAME --host ${REPL_META_HOST} "delete from comdb2_physrep_sources where 1"

    # Block until revcons are 0
    for node in $CLUSTER ; do
        dbname="${REPL_DBNAME_PREFIX}_${node}"
        block_for_standalone_revconn $dbname $node 0
    done

    # Update 'class' tables for with msgtrap
    first=""
    for node in $CLUSTER ; do
        class="mips"
        if [[ -z "$first" ]]; then
            first=$node
            class="bogo"
        fi

        # Add class everywhere
        for node2 in $CLUSTER; do
            $CDB2SQL_EXE ${CDB2_OPTIONS} $REPL_META_DBNAME --host $node2 "exec procedure sys.cmd.send('machine_cache add ${REPL_CLUS_DBNAME} $class $node')"
            $CDB2SQL_EXE ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node2 "exec procedure sys.cmd.send('machine_cache add ${REPL_CLUS_DBNAME} $class $node')"
            dbname=${REPL_DBNAME_PREFIX}_${node2}
            $CDB2SQL_EXE ${CDB2_OPTIONS} ${dbname} --host $node2 "exec procedure sys.cmd.send('machine_cache add ${REPL_CLUS_DBNAME} $class $node')"
        done
    done

    # Add reverse-connection sources by class
    first=""
    for node in $CLUSTER ; do
        source_class="mips"
        if [[ -z "$first" ]]; then
            source_class="bogo"
            first=$node
        fi
        dbname="${REPL_DBNAME_PREFIX}_${node}"
        add_to_physrep_sources ${REPL_META_DBNAME} ${REPL_META_HOST} ${REPL_CLUS_DBNAME} $source_class ${dbname} ${node}
    done

    # Wait for all of these to have a reverse-conn thread
    for node in $CLUSTER ; do
        dbname="${REPL_DBNAME_PREFIX}_${node}"
        block_for_standalone_revconn $dbname $node 1
    done

    # Create table, add some records
    $CDB2SQL_EXE ${CDB2_OPTIONS} $DBNAME default "create table t1(a int)"
    $CDB2SQL_EXE ${CDB2_OPTIONS} $DBNAME default "insert into t1 select * from generate_series(1, 1000)"

    # Block until all the standalone reversconns have these records
    for node in $CLUSTER ; do
        dbname="${REPL_DBNAME_PREFIX}_${node}"
        x=$($CDB2SQL_EXE --tabs ${CDB2_OPTIONS} --host $node $dbname "select count(*) from t1" 2>/dev/null)
        while [[ "$x" -ne "1000" ]]; do
            sleep 1
            x=$($CDB2SQL_EXE --tabs ${CDB2_OPTIONS} --host $node $dbname "select count(*) from t1" 2>/dev/null)
        done
        echo "Db $dbname on node $node has caught up"
    done

    $CDB2SQL_EXE ${CDB2_OPTIONS} $DBNAME default "drop table t1"
}

function clustered_revconn()
{
    echo "== Clustered revconn =="

    if [[ -z "$CLUSTER" ]]; then
        echo "clustered-revconn test only valid for clustered test"
        return
    fi

    echo "Add all clustered physrep to reverse-conns"
    for node in $CLUSTER ; do
        for node2 in $CLUSTER ; do
            add_to_physrep_sources ${REPL_META_DBNAME} ${REPL_META_HOST} ${SOURCE_DBNAME} ${node} ${REPL_CLUS_DBNAME} ${node2}
        done
    done

    block_for_clustered_revconn

    echo "Attempt 3 downgrades"

    j=0
    while [[ $j -lt 3 ]]; do

        # Downgrade 
        for node in $CLUSTER ; do
            cdb2sql ${CDB2_OPTIONS} $REPL_CLUS_DBNAME --host $node "exec procedure sys.cmd.send('downgrade')"
        done

        echo "Sleeping for 10"
        sleep 10
        block_for_clustered_revconn

        let j=j+1
    done
}

function incoherent_test()
{
    echo "== Incoherent test =="

    echo "Creating a simple table"
    cdb2sql ${CDB2_OPTIONS} $DBNAME default "Create table t1(a int)"

    echo "Marking all as incoherent"
    for node in $CLUSTER ; do
        cdb2sql --admin ${CDB2_OPTIONS} $DBNAME --host $node "exec procedure sys.cmd.send('force_incoherent')"
        cdb2sql --admin ${CDB2_OPTIONS} $DBNAME --host $node "exec procedure sys.cmd.send('force_incoherent_master')"
        cdb2sql --admin ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node "exec procedure sys.cmd.send('force_incoherent')"
        cdb2sql --admin ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node "exec procedure sys.cmd.send('force_incoherent_master')"
    done

    echo "Sleeping for 10"
    sleep 10

    for node in $CLUSTER ; do
        cdb2sql --admin ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node "exec procedure sys.cmd.send('physrep_force_registration')"
        cdb2sql --admin ${CDB2_OPTIONS} ${REPL_DBNAME_PREFIX}_${node} --host $node "exec procedure sys.cmd.send('physrep_force_registration')"
    done

    echo "Sleeping for 10"
    sleep 10

    have_reregistered=0
    echo "Force registration"
    while [[ "$have_reregistered" -eq 0 ]]; do
        for node in $CLUSTER ; do
            x=$(cdb2sql --tabs --admin ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node "exec procedure sys.cmd.send('physrep_force_registration')")
            echo "$x"
            j=$(echo "$x" | awk '{print $NF}')
            if [[ "$j" == "0" ]]; then
                have_reregistered=1
            fi
            x=$(cdb2sql --tabs --admin ${CDB2_OPTIONS} ${REPL_DBNAME_PREFIX}_${node} --host $node "exec procedure sys.cmd.send('physrep_force_registration')")
            echo "$x"
            j=$(echo "$x" | awk '{print $NF}')
            if [[ "$j" == "0" ]]; then
                have_reregistered=1
            fi
        done
        if [[ $have_reregistered -eq 0 ]]; then
            echo "Nothing has reregistered, sleeping for 10"
            sleep 10
        fi
    done

    echo "Sleeping for 10"
    sleep 10

    echo "Unforcing incoherent"
    for node in $CLUSTER ; do

        cdb2sql --admin ${CDB2_OPTIONS} $DBNAME --host $node "exec procedure sys.cmd.send('unforce_incoherent')"
        cdb2sql --admin ${CDB2_OPTIONS} $DBNAME --host $node "exec procedure sys.cmd.send('unforce_incoherent_master')"
        cdb2sql --admin ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node "exec procedure sys.cmd.send('unforce_incoherent')"
        cdb2sql --admin ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node "exec procedure sys.cmd.send('unforce_incoherent_master')"

    done

    echo "Sleeping for 10"
    sleep 10

    echo "Generating writes for source db"
    j=0
    while [[ $j -lt 50 ]]; do
        cdb2sql -admin ${CDB2_OPTIONS} $DBNAME default "insert into t1 select * from generate_series(1, 1000)"
        let j=j+1
    done

    echo "Ask all cluster nodes to start a reverse-conn"
    if [[ -n $CLUSTER ]]; then
        for node in $CLUSTER ; do
            add_to_physrep_sources ${REPL_META_DBNAME} ${REPL_META_HOST} ${SOURCE_DBNAME} ${node} "${REPL_DBNAME_PREFIX}_${first}" ${first}
        done
    fi

    echo "Compare-physrep lsns - this will timeout if broken"
    compare_end_lsns

    echo "Marking all as coherent"
    for node in $CLUSTER ; do
        cdb2sql --admin ${CDB2_OPTIONS} $DBNAME --host $node "exec procedure sys.cmd.send('unforce_incoherent')"
        cdb2sql --admin ${CDB2_OPTIONS} $DBNAME --host $node "exec procedure sys.cmd.send('unforce_incoherent_master')"
        cdb2sql --admin ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node "exec procedure sys.cmd.send('unforce_incoherent')"
        cdb2sql --admin ${CDB2_OPTIONS} ${REPL_CLUS_DBNAME} --host $node "exec procedure sys.cmd.send('unforce_incoherent_master')"
    done

    echo "Dropping table"
    cdb2sql ${CDB2_OPTIONS} $dbname default "Drop table t1"
}

function setup_physrep_metadb()
{
    echo "== Setting up replication metadb cluster =="
    local _dbname=$1
    local _dbdir=$2
    local tmpdir=${TMPDIR:-/tmp}

    if [[ -z "$CLUSTER" ]]; then # Standalone
        node=$(hostname)
        logFile=$TESTDIR/logs/${_dbname}.${node}.log

        mkdir ${_dbdir}

        cat <<END >> ${_dbdir}/${_dbname}.lrl
name ${_dbname}
dir ${_dbdir}
physrep_fanout_override fanouttest 100
physrep_fanout_override fanouttest2 50
physrep_fanout_override $DBNAME 3
physrep_register_interval 10
revsql_debug 1
physrep_debug 1
tranlog_incoherent_timeout 10
forbid_remote_admin 0
logmsg level debug
ctrace_dbdir 1
allow_lua_print 1
physrep_update_registry_interval 1
physrep_keepalive_v2 1
END

        $COMDB2_EXE ${_dbname} --create --lrl ${_dbdir}/${_dbname}.lrl --pidfile ${_dbdir}/${_dbname}.pid >> ${logFile} 2>&1
        $COMDB2_EXE ${_dbname} --lrl ${_dbdir}/${_dbname}.lrl --pidfile ${_dbdir}/${_dbname}.pid >> ${logFile} 2>&1 &
 
        out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_dbname} 'select 1' 2>/dev/null)

        # wait until we can query it
        echo "${_dbname}: waiting until ready"
        while [[ "$out" != "1" ]]; do
            sleep $SLEEP_BETWEEN_CHECKS
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_dbname} 'select 1' 2>/dev/null)
        done

        PIDs="${PIDs} $(cat ${_dbdir}/${_dbname}.pid)"

        create_physrep_tables ${_dbname} ${node}
        verify_fanout_overrides ${_dbname} ${node}

    # Cluster
    else
        firstNode=""
        # 1. Copy data
        for node in ${CLUSTER}; do
            logFile=$TESTDIR/logs/${_dbname}.${node}.log

            ssh ${node} "mkdir ${_dbdir}" < /dev/null

            if [[ ${firstNode} = "" ]]; then
                cat <<END >> ${tmpdir}/${_dbname}.lrl
name ${_dbname}
dir ${_dbdir}
cluster nodes ${CLUSTER}
physrep_fanout_override fanouttest 100
physrep_fanout_override fanouttest2 50
physrep_fanout_override $DBNAME 3
tranlog_incoherent_timeout 10
physrep_register_interval 10
revsql_debug 1
physrep_debug 1
forbid_remote_admin 0
logmsg level debug
ctrace_dbdir 1
allow_lua_print 1
physrep_update_registry_interval 1
physrep_keepalive_v2 1
END
                scp ${tmpdir}/${_dbname}.lrl ${node}:${_dbdir}/${_dbname}.lrl
                ssh ${node} "$COMDB2_EXE ${_dbname} --create --lrl ${_dbdir}/${_dbname}.lrl --pidfile ${_dbdir}/${_dbname}.pid" >> ${logFile} 2>&1 < /dev/null
                firstNode=${node}
            else
                lastNode=${node}
                ssh $node "${COPYCOMDB2_EXE} -x ${COMDB2_EXE} $firstNode:${_dbdir}/${_dbname}.lrl $_dbdir $_dbdir" >> ${logFile} 2>&1 < /dev/null
                if [ ! $? -eq 0 ]; then
                    cleanFailExit "copycomdb2 failed"
                fi
            fi
        done

        # 2. Start instances
        for node in ${CLUSTER}; do
            logFile=$TESTDIR/logs/${_dbname}.${node}.log
            ssh ${node} "$COMDB2_EXE ${_dbname} --lrl ${_dbdir}/${_dbname}.lrl --pidfile ${_dbdir}/${_dbname}.pid" >> ${logFile} 2>&1 < /dev/null &
            PIDs="${PIDs} $!"
        done

        # 3. Wait for instances to come online
        for node in $CLUSTER ; do
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_dbname} 'select 1' 2>/dev/null)

            # wait until we can query it
            echo "${_dbname}: waiting until ready"
            while [[ "$out" != "1" ]]; do
                sleep $SLEEP_BETWEEN_CHECKS
                out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_dbname} 'select 1' 2>/dev/null)
            done
        done

        create_physrep_tables ${_dbname} ${firstNode}
        verify_fanout_overrides ${_dbname} ${firstNode}
    fi
    echo "Physrep replication metadb cluster/node started!"
}

function fix_lrl_and_restart_source_nodes()
{
    echo "== Going to update source cluster's lrl and restart it =="
    local _source_dbname=$1
    local _source_host=$2
    local _source_dbdir=$3
    local _meta_dbname=$4
    local _meta_host=$5
    local _meta_dbdir=$6

    if [[ -z "$CLUSTER" ]]; then
        node=$(hostname)
        echo "physrep_metadb ${_meta_dbname} ${_meta_host}" >> ${_source_dbdir}/${_source_dbname}.lrl
        #echo "blocking_physrep 0" >> ${_source_dbdir}/${_source_dbname}.lrl
        echo "physrep_debug 1" >> ${_source_dbdir}/${_source_dbname}.lrl
        echo "killrestart node $node"
        kill_restart_node $node $KILL_WAIT_TIME &
        sleep $KILL_WAIT_TIME

        out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host $node ${_source_dbname} 'select 1' 2>/dev/null)

        # wait until we can query it
        echo "${_source_dbname}: waiting until ready"
        while [[ "$out" != "1" ]]; do
            sleep $SLEEP_BETWEEN_CHECKS
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host $node ${_source_dbname} 'select 1' 2>/dev/null)
        done
    else

        for node in $CLUSTER ; do
            ssh ${node} "echo \"physrep_metadb ${_meta_dbname} ${_meta_host}\" >> ${_source_dbdir}/${_source_dbname}.lrl" < /dev/null
            ssh ${node} "echo \"physrep_debug 1\" >> ${_source_dbdir}/${_source_dbname}.lrl" < /dev/null
            #ssh ${node} "echo \"physrep_register_interval 5\" >> ${_source_dbdir}/${_source_dbname}.lrl"
            echo "killrestart node $node"
            kill_restart_node $node $KILL_WAIT_TIME &
        done
        sleep $KILL_WAIT_TIME

        # select 1 all nodes
        for node in $CLUSTER ; do
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host $node ${_source_dbname} 'select 1' 2>/dev/null)
            # wait until we can query it
            echo "$DBNAME: waiting until ready"
            while [[ "$out" != "1" ]]; do
                sleep $SLEEP_BETWEEN_CHECKS
                out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host $node ${_source_dbname}  'select 1' 2>/dev/null)
            done
        done
    fi
    echo "Source cluster/node restarted"
}

function setup_physrep_cluster()
{
    echo "== Setting up replication cluster =="
    local _dbname=$1
    local _dbdir=$2
    local _source_dbname=$3
    local _source_host=$4
    local _source_dbdir=$5
    local _meta_dbname=$6
    local _meta_host=$7
    local _meta_dbdir=$8

    tmpdir=${TMPDIR:-/tmp}

    if [[ -z "$CLUSTER" ]]; then # Standalone
        node=$(hostname)
        logFile=$TESTDIR/logs/${_dbname}.${node}.log

        # use copycomdb2 to create a physical replicant

        ${COPYCOMDB2_EXE} -x ${COMDB2_EXE} -H ${_dbname} -y @${_source_host} ${node}:${_source_dbdir}/${_source_dbname}.lrl ${_dbdir} ${_dbdir} >> ${logFile} 2>&1
        if [ ! $? -eq 0 ]; then
            cleanFailExit "copycomdb2 failed"
        fi

        $COMDB2_EXE ${_dbname} --lrl ${_dbdir}/${_dbname}.lrl ${_dbdir}/${_dbname}.lrl --pidfile ${_dbdir}/${_dbname}.pid >> ${logFile} 2>&1 &
 
        out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_dbname} 'select 1' 2>/dev/null)

        # wait until we can query it
        echo "${_dbname}: waiting until ready"
        while [[ "$out" != "1" ]]; do
            sleep $SLEEP_BETWEEN_CHECKS
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_dbname} 'select 1' 2>/dev/null)
        done

        PIDs="${PIDs} $(cat ${_dbdir}/${_dbname}.pid)"

    else # Cluster
        firstNode=""
        # 1. Copy data
        for node in ${CLUSTER}; do
            logFile=$TESTDIR/logs/${_dbname}.${node}.log

            if [[ ${firstNode} = "" ]]; then
                ssh $node "${COPYCOMDB2_EXE} -x ${COMDB2_EXE} -H ${_dbname} -y @${_source_host} ${_source_host}:${SOURCE_DBDIR}/${SOURCE_DBNAME}.lrl ${_dbdir} ${_dbdir}" >> ${logFile} 2>&1 </dev/null
                if [[ ! $? -eq 0 ]]; then
                    cleanFailExit "copycomdb2 failed"
                fi

                # Update the lrl
                ssh $node "echo \"cluster nodes ${CLUSTER}\" >> ${_dbdir}/${_dbname}.lrl" < /dev/null

                firstNode=${node}
            else
                ssh $node "${COPYCOMDB2_EXE} -x ${COMDB2_EXE} $firstNode:${_dbdir}/${_dbname}.lrl $_dbdir $_dbdir" >> ${logFile} 2>&1 < /dev/null
                if [ ! $? -eq 0 ]; then
                    cleanFailExit "copycomdb2 failed"
                fi
            fi
        done
        firstNode=""
        # Fake machine-class for a test
        for node in ${CLUSTER} ; do
            #ssh $node "echo \"allow reads from bogo\" >> ${_dbdir}/${_dbname}.lrl" < /dev/null
            #ssh $node "echo \"allow reads from mips\" >> ${_dbdir}/${_dbname}.lrl" < /dev/null
            ssh $node "echo \"allow writes from bogo\" >> ${_dbdir}/${_dbname}.lrl" < /dev/null
            ssh $node "echo \"allow writes from mips\" >> ${_dbdir}/${_dbname}.lrl" < /dev/null

            if [[ ${firstNode} == "" ]]; then
                ssh $node "echo \"machine_classes all bogo\" >> ${_dbdir}/${_dbname}.lrl" < /dev/null
                ssh $node "echo \"machine_class bogo\" >> ${_dbdir}/${_dbname}.lrl" < /dev/null
                firstNode=${node}
            else
                ssh $node "echo \"machine_classes all mips\" >> ${_dbdir}/${_dbname}.lrl" < /dev/null
                ssh $node "echo \"machine_class mips\" >> ${_dbdir}/${_dbname}.lrl" < /dev/null
            fi
        done

        # 2. Start instances
        for node in ${CLUSTER}; do
            logFile=$TESTDIR/logs/${_dbname}.${node}.log
        ssh ${node} "$COMDB2_EXE ${_dbname} --lrl ${_dbdir}/${_dbname}.lrl --pidfile ${_dbdir}/${_dbname}.pid" >> ${logFile} 2>&1 < /dev/null & 
        PIDs="${PIDs} $!"
        done

        # 3. Wait for instances to come online
        for node in $CLUSTER ; do
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_dbname} 'select 1' 2>/dev/null)

            # wait until we can query it
            echo "${_dbname}: waiting until ready"
            while [[ "$out" != "1" ]]; do
                sleep $SLEEP_BETWEEN_CHECKS
                out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_dbname} 'select 1' 2>/dev/null)
            done
        done
    fi
    echo "Physrep replication cluster/node started!"
}

function setup_physrep_replicants()
{
    echo "== Setting up standalone replicants =="
    local _dbname_prefix=$1
    local _dbdir_prefix=$2
    local _source_dbname=$3
    local _source_host=$4
    local _source_dbdir=$5
    local _meta_dbname=$6
    local _meta_host=$7
    local _meta_dbdir=$8

    local tmpdir=${TMPDIR:-/tmp}

    # Standalone
    if [[ -z "$CLUSTER" ]]; then
        node=$(hostname)
        _repl_dbname=${_dbname_prefix}_${node}
        _repl_dbdir=${_dbdir_prefix}_${node}

        logFile=$TESTDIR/logs/${_repl_dbname}.log

        # Add this node to comdb2_physrep_sources table to test for 'reverse connection'
        add_to_physrep_sources ${_meta_dbname} ${_meta_host} ${_source_dbname} ${_source_host} ${_repl_dbname} ${node}

        # use copycomdb2 to create a physical replicant

        ${COPYCOMDB2_EXE} -x ${COMDB2_EXE} -H ${_repl_dbname} -y @${_source_host} ${_source_host}:${_source_dbdir}/${_source_dbname}.lrl ${_repl_dbdir} ${_repl_dbdir} >> ${logFile} 2>&1
        if [ ! $? -eq 0 ]; then
            cleanFailExit "copycomdb2 failed"
        fi

        $COMDB2_EXE ${_repl_dbname} --lrl ${_repl_dbdir}/${_repl_dbname}.lrl --pidfile ${_repl_dbdir}/${_repl_dbname}.pid >> ${logFile} 2>&1 &

        out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_repl_dbname} 'select 1' 2>/dev/null)

        # Wait until we can query it
        echo "${_repl_dbname}: waiting until ready"
        while [[ "$out" != "1" ]]; do
            sleep $SLEEP_BETWEEN_CHECKS
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_repl_dbname} 'select 1' 2>/dev/null)
        done

        PIDs="${PIDs} $(cat ${_repl_dbdir}/${_repl_dbname}.pid)"
    else
        # Start replicants on all the nodes
        firstNode=""
        for node in ${CLUSTER}; do
            _repl_dbname=${_dbname_prefix}_${node}
            _repl_dbdir=${_dbdir_prefix}_${node}

            logFile=$TESTDIR/logs/${_repl_dbname}.log

            if [[ ${firstNode} = "" ]]; then
                # Add first replicant to comdb2_physrep_sources table to test for 'reverse connection'
                add_to_physrep_sources ${_meta_dbname} ${_meta_host} ${_source_dbname} ${_source_host} ${_repl_dbname} ${node}
            fi

            ssh $node "${COPYCOMDB2_EXE} -x ${COMDB2_EXE} -H ${_repl_dbname} -y @${_source_host} ${_source_host}:${_source_dbdir}/${_source_dbname}.lrl ${_repl_dbdir} ${_repl_dbdir}" >> ${logFile} 2>&1 < /dev/null
            if [ ! $? -eq 0 ]; then
                cleanFailExit "copycomdb2 failed"
            fi

            if [[ ${firstNode} = "" ]]; then
                firstNode=$node
                ssh $node "echo \"machine_class bogo\" >> ${_repl_dbdir}/${_repl_dbname}.lrl" 2>&1 < /dev/null
            else
                ssh $node "echo \"machine_class mips\" >> ${_repl_dbdir}/${_repl_dbname}.lrl" 2>&1 < /dev/null
            fi

            ssh ${node} "$COMDB2_EXE ${_repl_dbname} --lrl ${_repl_dbdir}/${_repl_dbname}.lrl --pidfile ${_repl_dbdir}/${_repl_dbname}.pid" >> ${logFile} 2>&1 < /dev/null &
            PIDs="${PIDs} $!"

            # Wait for the node to start
            out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_repl_dbname} 'select 1' 2>/dev/null)

            # wait until we can query it
            echo "${_repl_dbname}: waiting until ready"
            while [[ "$out" != "1" ]]; do
                sleep $SLEEP_BETWEEN_CHECKS
                out=$($CDB2SQL_EXE ${CDB2_OPTIONS} --tabs --host ${node} ${_repl_dbname} 'select 1' 2>/dev/null)
            done

        done
    fi
    echo "Standalone physrep replication nodes started!"
}

function generate_tests()
{
    ./generate_tests.sh
}

function verify_blkseq_dbname_node()
{
    local _repl_dbname=$1
    local _repl_host=$2

    x=$($CDB2SQL_EXE --tabs ${CDB2_OPTIONS} $_repl_dbname --host $_repl_host  "select * from comdb2_blkseq")
    if [[ -n "$x" ]]; then
        echo "physrep $_repl_dbname node $_repl_host had blkseqs"
        echo "$x"
        cleanFailExit "physrep $_repl_dbname $_repl_host had blkseqs"
    fi
}

function verify_blkseq()
{
    echo "== verify that blkseq behavior on all nodes"

    if [[ -n "$CLUSTER" ]]; then
        for node in $CLUSTER ; do 
            x=$($CDB2SQL_EXE --tabs ${CDB2_OPTIONS} $DBNAME --host $node  "select * from comdb2_blkseq")
            wc=$(echo "$x" | wc -l)
            echo "node $node, blkseq $x"
            if [[ -z "$x" || "$wc" -lt 5 ]]; then
                cleanFailExit "Parent node $node missing or not enough blkseqs"
            fi
            verify_blkseq_dbname_node ${REPL_CLUS_DBNAME} $node
            verify_blkseq_dbname_node ${REPL_DBNAME_PREFIX}_${node} $node
        done
    else
        node=$(hostname)
        x=$($CDB2SQL_EXE --tabs ${CDB2_OPTIONS} $DBNAME --ndoe $node "select * from comdb2_blkseq")
        wc=$(echo "$x" | wc -l)
        echo "blkseq is $x"
        if [[ -z "$x" || "$wc" -lt 5 ]]; then
            cleanFailExit "Parent missing or not enough blkseq"
        fi
        verify_blkseq_dbname_node ${REPL_CLUS_DBNAME} $node
        verify_blkseq_dbname_node ${REPL_DBNAME_PREFIX}_${node} $node
    fi
}

function run_generated_tests()
{
    # iterate over each test: for every .src.sql and .src.sh file there is a .query.sql file to check
    for file in `ls *.src.sql *src.sh | sort -V`; do
        echo "== executing statements from file $file"

        # for each sql test execute it
        if [ "${file: -3}" == "sql" ]; then
            ${CDB2SQL_EXE} -s --tabs --maxretries=100000 -f $file ${CDB2_OPTIONS} $dbname default || cleanFailExit "Error from $file"
            query_cmd=$(echo $file | sed 's/\.src\.sql//').query.sql

        else
            source ./"$file"

            query_cmd=$(echo $file | sed 's/\.src\.sh//').query.sql
        fi

        if [ $((RANDOM % 3)) -eq 1 ] ; then
            downgradeonce $dbname
        fi

        is_ok=1
        while [ $is_ok -ne 0 ] ; do
            sleep 2
            ${CDB2SQL_EXE} -s --tabs --maxretries=100000 -v -f $query_cmd ${CDB2_OPTIONS} $dbname default 2> src.err > src.out 
            is_ok=$?
        done

        wait_for_catchup ${REPL_CLUS_DBNAME} ${REPL_CLUS_HOST}

        ${CDB2SQL_EXE} -s --tabs -f $query_cmd ${REPL_CLUS_DBNAME} --host ${REPL_CLUS_HOST} 2> dest.err > dest.out

        if ! diff src.out dest.out ; then
            echo "Replicant not updated [correctly] vimdiff $PWD/{src.out,dest.out}"
            sleep 1
            src=$(${CDB2SQL_EXE} -s --tabs -f $query_cmd ${CDB2_OPTIONS} $dbname default 2>&1 ) 
            dest=$(${CDB2SQL_EXE} -s --tabs -f $query_cmd ${REPL_CLUS_DBNAME} --host ${REPL_CLUS_HOST} 2>&1 )
            cleanFailExit "Failed on $file test."
        fi
    done
}

function tranlog_blocklsn()
{
    echo "== tranlog blocklsn test"
    local master=$(getmaster)
    local currentlsn=$($CDB2SQL_EXE -tabs ${CDB2_OPTIONS} $DBNAME default "select lsn from comdb2_transaction_logs(NULL, NULL, 0x4) limit 1")
    local lsn=$(echo $currentlsn | tr -d {})
    local file=${lsn%:*}
    local offset=${lsn#*:}
    local waitfile=$(( file + 1 ))
    local waitlsn="{$waitfile:$offset}"

    echo "Current lsn is $currentlsn, blocking until $waitlsn"
    $CDB2SQL_EXE -tabs ${CDB2_OPTIONS} $DBNAME default "select * from comdb2_transaction_logs('${currentlsn}', NULL, 0x1, 0, '${waitlsn}')" > /dev/null &
    bpid=$!

    echo "Sleeping for 10"
    sleep 10

    if kill -0 $bpid 2>/dev/null ; then
        echo "Blocking transaction still blocking"
    else
        kill -9 $bpid
        cleanFailExit "Blocking transaction returned "
    fi

    echo "Pushing transaction log forward 3 logs"
    $CDB2SQL_EXE -tabs ${CDB2_OPTIONS} $DBNAME --host $master "exec procedure sys.cmd.send('pushlogs 3')"
    
    local exited=0

    while [[ "$exited" -eq 0 ]]; do
        sleep 1
        if kill -0 $bpid 2>/dev/null ; then
            echo "Blocking transaction still blocking"
            currentlsn=$($CDB2SQL_EXE -tabs ${CDB2_OPTIONS} $DBNAME default "select lsn from comdb2_transaction_logs(NULL, NULL, 0x4) limit 1")
            echo "Current lsn is $currentlsn, blocking until $waitlsn"
        else
            exited=1
        fi
    done
}

function tranlog_timeout()
{
    typeset begin
    typeset end
    echo "== tranlog timeout test"

    # Set timeout for 5 seconds - this should succeed if total time is between 5 and 7 seconds
    echo "Testing timeout of 5 seconds"
    begin=$(date +%s)
    cdb2sql ${CDB2_OPTIONS} $DBNAME default "select * from comdb2_transaction_logs(NULL, NULL, 1, 5)" > /dev/null
    end=$(date +%s)
    total=$(( end - begin ))
    if [[ $total -lt 5 || $total -gt 7 ]]; then
        cleanFailExit "tranlog timeout test failed, total time $total wanted 5"
    fi

    echo "Testing default timeout - should be 30 seconds"
    begin=$(date +%s)
    cdb2sql ${CDB2_OPTIONS} $DBNAME default "select * from comdb2_transaction_logs(NULL, NULL, 1)" > /dev/null
    end=$(date +%s)
    total=$(( end - begin ))
    if [[ $total -lt 29 || $total -gt 35 ]]; then
        cleanFailExit "tranlog timeout test failed, total time $total wanted 30"
    fi
}

function revconn_latency()
{
    typeset now=$(date +%s)
    typeset end=$((now + 60))
    typeset tnode=$1
    typeset failed=0
    typeset cored=0

    TESTDIR=${TESTDIR:-${PWD}/test_${TESTID}}
    TMPDIR=${TMPDIR:-${TESTDIR}/tmp}
    PIDFILE=${TMPDIR}/${DBNAME}.${tnode}.pid
    tpid=$(ssh $tnode "cat $PIDFILE" < /dev/null)

    while [[ $now -lt $end && $failed == 0 ]]; do
        cdb2sql ${CDB2_OPTIONS} $DBNAME --host $tnode "select comdb2_host()" >/dev/null 2>&1 &
        bpid=$!
        count=0
        while kill -0 $bpid 2>/dev/null ; do
            let count=count+1
            if [[ $do_gcore == 1 && $count -gt 3 && $cored == 0 ]]; then
                echo "Reached time threshold, gcoring"
                ssh $tnode "gcore -o /cores/core.comdb2 $tpid" < /dev/null
                cored=1
                failed=1
            fi
            sleep 0.100
        done
        wait $bpid

        if [[ $count -gt 5 ]]; then
            echo "Took more than 0.5 seconds to return, count is $count"
            failed=1
        fi
        now=$(date +%s)
    done

    if [[ "$failed" == 1 ]]; then
        cleanFailExit "revconn_latency took too long to return against $tnode"
    fi
}

function cleanup_internal()
{
    typeset sig=$1
    echo "Killing ${PIDs}"
    kill -9 ${PIDs}
    [[ $dgpid != 0 ]] && kill -9 $dgpid

    REPL_META_DBNAME=${TESTCASE}_META
    REPL_META_DBDIR=${DBDIR}/${REPL_META_DBNAME}

    REPL_CLUS_DBNAME=${TESTCASE}_CLUS
    REPL_CLUS_DBDIR=${DBDIR}/${REPL_CLUS_DBNAME}

    REPL_DBNAME_PREFIX=${TESTCASE}_REPL
    REPL_DBDIR_PREFIX=${DBDIR}/${REPL_DBNAME_PREFIX}

    if [[ -n "$CLUSTER" ]]; then
        for node in $CLUSTER ; do
            _repl_dbname=${REPL_DBNAME_PREFIX}_${node}
            _repl_dbdir=${REPL_DBDIR_PREFIX}_${node}
            ssh ${node} "kill -$sig \$(cat ${_repl_dbdir}/${_repl_dbname}.pid)" < /dev/null
            ssh ${node} "kill -$sig \$(cat ${REPL_CLUS_DBDIR}/${REPL_CLUS_DBNAME}.pid)" < /dev/null 
            ssh ${node} "kill -$sig \$(cat ${REPL_META_DBDIR}/${REPL_META_DBNAME}.pid)" < /dev/null
        done
    fi
}

function cleanup()
{
    cleanup_internal 9
}

function cleanupabort()
{
    cleanup_internal 15
}

# Compare LSNs of all the replicants against the source cluster/node
function compare_end_lsns()
{
    echo "== Going to compare LSNs of all the replicants =="
    if [[ -z "$CLUSTER" ]]; then
        wait_for_catchup ${REPL_CLUS_DBNAME} ${REPL_CLUS_HOST}
        wait_for_catchup ${REPL_DBNAME_PREFIX}_$(hostname) ${REPL_CLUS_HOST}
    else
        for node in ${CLUSTER}; do
            wait_for_catchup ${REPL_CLUS_DBNAME} ${node}
            wait_for_catchup ${REPL_DBNAME_PREFIX}_${node} ${node}
        done
    fi
}

function test_overlap
{
    parentlow=$1
    parenthigh=$2
    mylow=$3
    myhigh=$4
    expectedresult=$5

    x=$(${CDB2SQL_EXE} -s --tabs ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('physrep_overlap_test $parentlow $parenthigh $mylow $myhigh')")
    result=${x##*=}
    if [[ $result -ne $expectedresult ]]; then
        echo "Overlap test failed: parentlow $parentlow parenthigh $parenthigh mylow $mylow myhigh $myhigh expectedresult $expectedresult"
        cleanFailExit "Overlap test failed"
    fi
}

# Simple test to verify that skip-recovery ran against physical replicants
# Disabled for now- this does not work yet .. 
function verify_skip_recovery
{
    for node in $CLUSTER ; do
        logFile=$TESTDIR/logs/${REPL_DBNAME_PREFIX}_${node}.log
        x=$(egrep "skip-recovery truncate" $logFile | wc -l)
        if [[ "$x" == "0" ]]; then
            cleanFailExit "skip-recovery not found in $logFile"
        fi
        logFile=$TESTDIR/logs/${REPL_CLUS_DBNAME}.${node}.log
        x=$(egrep "skip-recovery truncate" $logFile | wc -l)
        if [[ "$x" == "0" ]]; then
            cleanFailExit "skip-recovery not found in $logFile"
        fi
    done
}

# Verify the reverse-connection / register_interval fix
# When broken, the first REPL node would re-register 200+ times
function verify_revconn_fix
{
    logFile=$TESTDIR/logs/${REPL_DBNAME_PREFIX}_${firstNode}.log
    x=$(egrep "Reverse connected" $logFile | wc -l)
    if [[ "$x" -gt 80 ]]; then
        cleanFailExit "Reverse connection loop in $logFile"
    fi
}

# Use message traps to verify overlap logic
function match_overlap
{
    # {parentlow} {parenthigh} {mylow} {myhigh} expectedresult
    test_overlap "{1:1}" "{100:100}" "{30:1}" "{100:99}" 1
    test_overlap "{1:1}" "{30:100}" "{31:1}" "{100:99}" 0
    test_overlap "{30:100}" "{40:100}" "{10:100}" "{29:100}" 0
    test_overlap "{30:100}" "{40:100}" "{10:100}" "{30:101}" 1

    # Now test with max-rollback
    if [[ -n $CLUSTER ]]; then
        for node in $CLUSTER; do
            $CDB2SQL_EXE --tabs ${CDB2_OPTIONS} $DBNAME --host $node "put tunable physrep_max_rollback 2"
        done
    else
        $CDB2SQL_EXE --tabs ${CDB2_OPTIONS} $DBNAME default "put tunable physrep_max_rollback 2"
    fi

    test_overlap "{1:1}" "{98:98}" "{30:1}" "{100:100}" 1
    test_overlap "{1:1}" "{98:98}" "{30:1}" "{101:101}" 0
    
    return 0
}

# Verify that we are showing generation in comdb2-transaction-logs
function verify_generation
{
    x=$(cdb2sql --tabs ${CDB2_OPTIONS} $DBNAME default "select count(*) from comdb2_transaction_logs where generation is not null") 
    if [[ $? != 0 ]]; then
        cleanFailExit "Failed reading comdb2-transactions-logs"
    fi

    if [[ $x == 0 ]]; then
        cleanFailExit "Generation not shown in comdb2_transaction_logs"
    fi
}

# Call register-replicant directly- look at the list of machines returned .. 
# Update the metadb info on the returned nodes to put them out of range, and
# verify that they are not returned the next time
#
# Finally put every machine out of range, and verify that nothing is returned
#
# This is verifying that fanout will ignore fanout if there are no machines which qualify
function phys_rep_nomatch
{
    local metadb=$1
    local metahost=$2
    echo "== physrep_rep_nomatch =="

    if [[ "$FIRSTFILE" == "0" ]]; then
        echo "rep_nomatch test is only valid for firstfile"
        return 0
    fi

    nomachines=1

    # physical replicants will send keepalive periodically
    while [[ "$nomachines" == "1" ]]; do
        # get lsn of physical-replicants
        lsn=`$CDB2SQL_EXE -admin --tabs $CDB2_OPTIONS $DBNAME default 'select lsn from comdb2_transaction_logs(NULL, NULL, 4) limit 1' | tr -d {}`

        # get list of hosts that can handle
        output=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $metadb --host $metahost "exec procedure sys.physrep.register_replicant('mydb', 'mymach', '$lsn', '$DBNAME', \"'$firstNode'\")")

        if [[ -n "$output" ]]; then
            nomachines=0
        else
            sleep 1
        fi
    done

    sql=./sql.txt

    echo -n "update comdb2_physreps set firstfile=100 where dbname in (" > $sql
    first=1

    count=0
    echo "$output" | while read ln; do
        tier=$(echo $ln | awk '{print $1}')
        if [[ "$tier" == "0" ]]; then
            cleanFailExit "register_replicant replicating against tier 0"
            return 1
        fi

        db=$(echo $ln | awk '{print $2}')
        if [[ $first -eq 0 ]]; then
            echo -n "," >> $sql
        fi
        first=0
        echo -n "'$db'" >> $sql
    done

    echo ")" >> $sql

    good=0

    echo "Putting these hosts out of range"

    # Update the file for each of these to be out-of-range
    # This races with heartbeats: do in a loop to make it reliable
    while [[ $good -ne 1 ]]; do

        echo "Executing $(cat $sql)"
        $CDB2SQL_EXE $CDB2_OPTIONS $metadb --host $metahost - < $sql

        output=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $metadb --host $metahost "exec procedure sys.physrep.register_replicant('mydb', 'mymach', '$lsn', '$DBNAME', \"'$firstNode'\")")

        # We succeed when count is 1 and the tier is 0
        if [[ -n "$output" ]]; then
            count=$(echo "$output" | wc -l)
            if [[ "$count" == "1" ]]; then
                tier=$(echo "$output" | awk '{print $1}')
                if [[ "$tier" == "0" ]]; then
                    good=1
                fi
            fi
        fi

        [[ "$good" == "0" ]] && sleep 1
    done

    echo "Putting all hosts out of range"

    good=0
    while [[ "$good" -ne 1 ]]; do
        $CDB2SQL_EXE $CDB2_OPTIONS $metadb --host $metahost "update comdb2_physreps set firstfile=100 where state != 'Pending'"

        output=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $metadb --host $metahost "exec procedure sys.physrep.register_replicant('mydb', 'mymach', '$lsn', '$DBNAME', \"'$firstNode'\")")

        if [[ -z "$output" ]]; then
            # this situation emits 'critical error' trace, which we can alert on
            echo "Register replicant returned no machines - succeeded"
            good=1
        fi

    done

    echo "Waiting for heartbeats"
    count=100
    while [[ "$count" -ne 0 ]]; do
        count=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $metadb --host $metahost "select count(*) from comdb2_physreps where firstfile=100")
        [[ "$count" > "0" ]] && sleep 1
    done

    return 0
}

trap - INT EXIT

# 1. Setup replication metadata cluster
REPL_META_DBNAME=${TESTCASE}_META
REPL_META_DBDIR=${DBDIR}/${REPL_META_DBNAME}
REPL_META_HOST=""

if [[ -z "$CLUSTER" ]]; then # Standalone
    REPL_META_HOST=$(hostname)
else                         # Cluster
    for node in ${CLUSTER}; do
        let cluster_count=cluster_count+1
    done
    for node in ${CLUSTER}; do
        first=${node}
        REPL_META_HOST=${node}
        # Downgrade now - we want to test incoherent later
        cdb2sql ${CDB2_OPTIONS} ${dbname} --host $node "exec procedure sys.cmd.send('downgrade')"
        break
    done
fi

setup_physrep_metadb ${REPL_META_DBNAME} ${REPL_META_DBDIR}

# 2. Update source cluster lrl to point to the replication metadata cluster
SOURCE_DBNAME=${dbname}
SOURCE_DBDIR=${DBDIR}
SOURCE_HOST=${REPL_META_HOST}

fix_lrl_and_restart_source_nodes ${SOURCE_DBNAME} ${SOURCE_HOST} ${SOURCE_DBDIR} ${REPL_META_DBNAME} ${REPL_META_HOST} ${REPL_META_DBDIR}

# 2.5 No-source ensures physrep cluster can start if parent is not running
if [[ "$NOSOURCE" == "1" ]]; then
    kill_source_nodes
fi

# 3. Setup physical replication cluster (nodes share same hosts as the source cluster)
REPL_CLUS_DBNAME=${TESTCASE}_CLUS
REPL_CLUS_DBDIR=${DBDIR}/${REPL_CLUS_DBNAME}
REPL_CLUS_HOST=${REPL_META_HOST}
setup_physrep_cluster ${REPL_CLUS_DBNAME} ${REPL_CLUS_DBDIR} ${SOURCE_DBNAME} ${SOURCE_HOST} ${SOURCE_DBDIR} ${REPL_META_DBNAME} ${REPL_META_HOST} ${REPL_META_DBDIR}

# 4. Setup physical replicants
REPL_DBNAME_PREFIX=${TESTCASE}_REPL
REPL_DBDIR_PREFIX=${DBDIR}/${REPL_DBNAME_PREFIX}
setup_physrep_replicants ${REPL_DBNAME_PREFIX} ${REPL_DBDIR_PREFIX} ${SOURCE_DBNAME} ${SOURCE_HOST} ${SOURCE_DBDIR} ${REPL_META_DBNAME} ${REPL_META_HOST} ${REPL_META_DBDIR}

# Verify LSNS whether or not NOSOURCE is lit 
verify_physrep_lsns ${REPL_DBNAME_PREFIX} ${REPL_CLUS_DBNAME}

if [[ "$NOSOURCE" == "1" ]]; then
    restart_source_nodes
fi

function announce
{
    typeset text=$1
    echo "$text"
    [[ -z "$FIGLET" ]] && figlet -f banner $text
}

function testcase_finish
{
    typeset testcase=$1
    announce "Finished $testcase"
}

function testcase_preamble
{
    typeset testcase=$1
    announce "Running $testcase"
}

function run_tests
{
    testcase="verify_generation"
    testcase_preamble $testcase
    verify_generation
    testcase_finish $testcase

    testcase="phys_rep_nomatch"
    testcase_preamble $testcase
    phys_rep_nomatch ${REPL_META_DBNAME} ${REPL_META_HOST}
    testcase_finish $testcase

    testcase="tranlog_timeout"
    testcase_preamble $testcase
    tranlog_timeout
    testcase_finish $testcase

    testcase="tranlog_blocklsn"
    testcase_preamble $testcase
    tranlog_blocklsn
    testcase_finish $testcase

    testcase="revconn_latency $lastNode"
    testcase_preamble $testcase
    revconn_latency $lastNode
    testcase_finish $testcase

    testcase="revconn_latency $firstNode"
    testcase_preamble $testcase
    revconn_latency $firstNode
    testcase_finish $testcase

    testcase="generated_tests"
    testcase_preamble $testcase
    generate_tests
    run_generated_tests
    testcase_finish $testcase

    testcase="verify_blkseq"
    testcase_preamble $testcase
    verify_blkseq
    compare_end_lsns
    testcase_finish $testcase

    testcase="verify_fanout_myoverride"
    testcase_preamble $testcase
    verify_fanout_myoverride ${REPL_META_DBNAME} ${REPL_META_HOST}
    testcase_finish $testcase

    testcase="incoherent_test"
    testcase_preamble $testcase
    incoherent_test
    testcase_finish $testcase

    testcase="clustered_revconn"
    testcase_preamble $testcase
    clustered_revconn
    testcase_finish $testcase

    testcase="revconn_source_cluster"
    testcase_preamble $testcase
    revconn_source_cluster
    testcase_finish $testcase

    testcase="revconn_source_class"
    testcase_preamble $testcase
    revconn_source_class
    testcase_finish $testcase

    testcase="match_overlap"
    testcase_preamble $testcase
    match_overlap
    testcase_finish $testcase

    # TODO: skip-recovery seems to cause corruption for physreps- disable for now
    #testcase="verify_skip_recovery"
    #testcase_preamble $testcase
    #verify_skip_recovery
    #testcase_finish $testcase

    testcase="verify_revconn_fix"
    testcase_preamble $testcase
    verify_revconn_fix
    testcase_finish $testcase
}

run_tests
cleanup

exit 0
