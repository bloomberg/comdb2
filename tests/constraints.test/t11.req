drop table if exists p;
drop table if exists c;
create table p {schema{int i} keys{"pki" = i}} $$
create table c {schema{int i} keys{"cki" = i} constraints{"cki" -> <"p" : "pki"> on update cascade on delete cascade }} $$

insert into p values (1)
insert into c values (1)

select "the following transacion should fail with dup on c.key" as comment
begin
insert into c values (1)
delete from p where i = 1
commit
select * from c
select * from p

select "the following transacion should fail with dup on c.key" as comment
begin
insert into c values (1)
update p set i = i+i where i = 1
commit
select * from c
select * from p

drop table c;
drop table p;

select "the following transacions should succeed because c has non dup key" as comment
create table p {schema{int i} keys{"pki" = i}} $$
create table c {schema{int i} keys{dup "cki" = i} constraints{"cki" -> <"p" : "pki"> on update cascade on delete cascade }} $$


-- doing this without rows in table is currently broken
-- insert into p values (1)
-- insert into c values (1)

-- select "the following transacion should delete content on both tables" as comment
-- begin
-- insert into c values (1)
-- delete from p where i = 1
-- commit
-- select * from c
-- select * from p


insert into p values (1)
insert into c values (1)

select "the following transacion should result in all rows including the inserted to c within the transaction being updated to 2" as comment
begin
insert into c values (1)
update p set i = i+i where i = 1
commit
select * from c
select * from p

insert into p values (1)
insert into c values (1)

select "the following transacion should delete all i=1 content on both tables, the delet from c happens as cascade at the very end of the transaction" as comment
begin
insert into c values (1)
delete from p where i = 1
commit
select * from c order by i
select * from p order by i

