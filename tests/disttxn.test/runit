#!/usr/bin/env bash
bash -n "$0" | exit 1

. ${TESTSROOTDIR}/tools/cluster_utils.sh
. ${TESTSROOTDIR}/tools/runit_common.sh
. ${TESTSROOTDIR}/tools/hrtime.sh

# permissive maxtime because im killing my hardware
export maxtime=300000
export stopfile=./stopfile.txt

export debug=1

[[ $debug == "1" ]] && set -x

export comdb2db_hosts="${SENARY_DBNAME}:1234"
export COMDB2DB_DBNAME=${SENARY_DBNAME}
export COMDB2DB_OPTIONS=${SENARY_CDB2_OPTIONS}
export LOGDIR=$TESTDIR/logs
export LONGINSERTTIME=10000

export LONGUPDATETIME=30000
export FAIL_ON_LONG_INSERT=1
export UPDATE_SCOPE=5
export DELETE_SCOPE=5

#export DEBUGTRACE="--debugtrace"
export DEBUGTRACE=""
export FIGLET=$(which figlet)
export keepup_on_failure=0

function stop_all_databases
{
    for node in $CLUSTER ; do
         kill -9 $(cat ${TMPDIR}/${DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${SECONDARY_DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${TERTIARY_DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${QUATERNARY_DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${QUINARY_DBNAME}.${node}.pid)
         kill -9 $(cat ${TMPDIR}/${SENARY_DBNAME}.${node}.pid)
    done
}

function fail_exit()
{
    echo "Failed $@" | tee ${DBNAME}.fail_exit # runtestcase script looks for this file
    touch $stopfile
    if [[ $keepup_on_failure == 0 ]]; then
        stop_all_databases
        exit -1
    fi
}

function send_message_machine
{
    typeset msg="$1"
    typeset mach="$2"

    $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME --host $mach "exec procedure sys.cmd.send(\"$msg\")"
    $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $mach "exec procedure sys.cmd.send(\"$msg\")"
    $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $mach "exec procedure sys.cmd.send(\"$msg\")"
    $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $mach "exec procedure sys.cmd.send(\"$msg\")"
    $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $mach "exec procedure sys.cmd.send(\"$msg\")"
}

function send_message_all
{
    typeset msg="$1"
    for node in $CLUSTER ; do
        send_message_machine "$msg" "$node"
    done
}

function send_message_db_machine
{
    typeset msg="$1"
    typeset dbname="$2"
    typeset options="$3"
    typeset mach="$4"

    $CDB2SQL_EXE -admin $options $dbname --host $mach "exec procedure sys.cmd.send('$msg')"
}

function send_message_cluster
{
    typeset msg="$1"
    typeset dbname="$2"
    typeset options="$3"

    for node in $CLUSTER ; do
        send_message_db_machine "$msg" "$dbname" "$options" "$node"
    done
}

function forbid_coordinator
{
    send_message_all "forbid-coordinator $DBNAME/prod"
    send_message_all "forbid-coordinator $SECONDARY_DBNAME/prod"
    send_message_all "forbid-coordinator $TERTIARY_DBNAME/prod"
    send_message_all "forbid-coordinator $QUATERNARY_DBNAME/prod"
    send_message_all "forbid-coordinator $QUINARY_DBNAME/prod"
}

# Verify-tunable string
function verify_tunable
{
    typeset dbname=$1
    typeset options=$2
    typeset tunable=$3
    typeset value=$4

    x=$($CDB2SQL_EXE --tabs $options $dbname default "select value from comdb2_tunables where name='${tunable}'" 2>&1)
    if [[ "$x" != "$value" ]]; then
        echo "Tunable $tunable is not set to $value in $dbname"
        fail_exit "Tunable $tunable is not set to $value in $dbname"
    fi
}

# Added 'foobardb/prod dbeefdb/prod' through the lrl .. verify that it's set everywhere
function verify_allow_coordinator
{
    verify_tunable $DBNAME "$CDB2_OPTIONS" allow_coordinator "foobardb/prod dbeefdb/prod"
    verify_tunable $SECONDARY_DBNAME "$SECONDARY_CDB2_OPTIONS" allow_coordinator "foobardb/prod dbeefdb/prod"
    verify_tunable $TERTIARY_DBNAME "$TERTIARY_CDB2_OPTIONS" allow_coordinator "foobardb/prod dbeefdb/prod"
    verify_tunable $QUATERNARY_DBNAME "$QUATERNARY_CDB2_OPTIONS" allow_coordinator "foobardb/prod dbeefdb/prod"
    verify_tunable $QUINARY_DBNAME "$QUINARY_CDB2_OPTIONS" allow_coordinator "foobardb/prod dbeefdb/prod"
}

function allow_coordinator
{
    send_message_all "allow-coordinator $DBNAME/prod"
    send_message_all "allow-coordinator $SECONDARY_DBNAME/prod"
    send_message_all "allow-coordinator $TERTIARY_DBNAME/prod"
    send_message_all "allow-coordinator $QUATERNARY_DBNAME/prod"
    send_message_all "allow-coordinator $QUINARY_DBNAME/prod"
}

function set_tunable_machine
{
    typeset tunable=$1
    typeset value=$2
    typeset mach=$3

    $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME --host $mach "put tunable $tunable $value" >/dev/null 2>&1
    $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $mach "put tunable $tunable $value" >/dev/null 2>&1
    $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $mach "put tunable $tunable $value" >/dev/null 2>&1
    $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $mach "put tunable $tunable $value" >/dev/null 2>&1
    $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $mach "put tunable $tunable $value" >/dev/null 2>&1
}

function benchmark_common_tunables
{
    for mach in ${CLUSTER}; do
        set_tunable_machine debug_disttxn_trace 0 $mach
        set_tunable_machine verbose_toblock_backouts 0 $mach
        set_tunable_machine dump_blkseq 0 $mach
        set_tunable_machine ack_trace 0 $mach
        set_tunable_machine set_coherent_state_trace 0 $mach
        set_tunable_machine wait_for_seqnum_trace 0 $mach
        set_tunable_machine gbl_extended_sql_debug_trace 0 $mach
        set_tunable_machine fdbdebg 0 $mach
        set_tunable_machine bdblock_debug 0 $mach
    done
}

# Disables all safety measures
function benchmark_loose_tunables
{
    for mach in ${CLUSTER}; do
        set_tunable_machine coordinator_sync_on_commit 0 $mach
        set_tunable_machine flush_on_prepare 0 $mach
        set_tunable_machine flush_on_replicant_prepare 0 $mach
        set_tunable_machine wait_for_prepare_seqnum 0 $mach
    done
}

function benchmark_austere_tunables
{
    for mach in ${CLUSTER}; do
        set_tunable_machine coordinator_sync_on_commit 1 $mach
        set_tunable_machine flush_on_prepare 1 $mach
        set_tunable_machine flush_on_replicant_prepare 1 $mach
        set_tunable_machine wait_for_prepare_seqnum 1 $mach
    done
}

function update_all_tunables
{
    # Update tunables
    if [[ -z ${CLUSTER} ]]; then
        $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

        $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

        $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

        $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

        $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
        $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1
    else
        for mach in ${CLUSTER}; do
            $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

            $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

            $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

            $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1

            $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $mach "put tunable foreign_metadb '${COMDB2DB_DBNAME}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $mach "put tunable foreign_metadb_class 'local'" >/dev/null 2>&1
        done
    fi
}

# Setup comdb2db tables- modeled from incoh_remsql test
function create_comdb2db
{
    # Create comdb2db tables
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "create table if not exists clusters {`cat clusters.csc2`}" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "create table if not exists machines {`cat machines.csc2`}" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "create table if not exists databases {`cat databases.csc2`}" >/dev/null 2>&1

    # Populate databases
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${DBNAME}', 1234) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${SECONDARY_DBNAME}', 1235) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${TERTIARY_DBNAME}', 1236) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${QUATERNARY_DBNAME}', 1237) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${QUINARY_DBNAME}', 1237) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${SENARY_DBNAME}', 1238) on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into databases(name, dbnum) values('${COMDB2DB_DBNAME}', 1239) on conflict do nothing" >/dev/null 2>&1

    # Populate clusters
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${SECONDARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${TERTIARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${QUATERNARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${QUINARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${SENARY_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1
    $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into clusters(name, cluster_name, cluster_machs) values('${COMDB2DB_DBNAME}', 'prod', 'KABOOM') on conflict do nothing" >/dev/null 2>&1

    # Populate machines
    if [[ -z ${CLUSTER} ]]; then
        $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into machines(name, cluster, room) values ('localhost', 'KABOOM', 'NY') on conflict do nothing" >/dev/null 2>&1
        comdb2db_hosts="${comdb2db_hosts}:localhost"
    else
        let nnodes=0
        for mach in ${CLUSTER} ; do
            $CDB2SQL_EXE $COMDB2DB_OPTIONS $COMDB2DB_DBNAME default "insert into machines(name, cluster, room) values('${mach}', 'KABOOM', 'NY') on conflict do nothing" >/dev/null 2>&1
            comdb2db_hosts="${comdb2db_hosts}:${mach}"
            let nnodes=nnodes+1
        done
    fi

    echo "Refreshing all tunables"
    update_all_tunables

    echo "Allowing coordinator on all nodes"
    allow_coordinator
}

function find_master
{
    $CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default 'select host from comdb2_cluster where is_master="Y"'
}

function find_secondary_master
{
    $CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default 'select host from comdb2_cluster where is_master="Y"'
}

function find_tertiary_master
{
    $CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default 'select host from comdb2_cluster where is_master="Y"'
}

function find_quaternary_master
{
    $CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default 'select host from comdb2_cluster where is_master="Y"'
}

function create_tables
{
    # Create t1 DBNAME
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create table if not exists t1(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t1 for $DBNAME $x"
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create unique index if not exists t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $DBNAME $x"

    # Create d1
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create table if not exists d1(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d1 for $DBNAME $x"
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create index if not exists d1a on d1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $DBNAME $x"

    # Create d2
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create table if not exists d2(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d2 for $DBNAME $x"
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create index if not exists d2a on d2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $DBNAME $x"

    # Create t2 DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create table if not exists t2(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t2 for $DBNAME $x"
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create unique index if not exists t2a on t2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $DBNAME $x"

    # Create t3 DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create table if not exists t3(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t3 for $DBNAME $x"
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create unique index if not exists t3a on t3(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $DBNAME $x"

    # Create t4 DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create table if not exists t4(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t4 for $DBNAME $x"
    x=$($CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create unique index if not exists t4a on t4(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $DBNAME $x"

    # Create t1 SECONDARY
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create table if not exists t1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t1 for $SECONDARY_DBNAME $x"
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create unique index if not exists t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $SECONDARY_DBNAME $x"

    # Create t2 DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create table if not exists t2(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t2 for $SECONDARY_DBNAME $x"
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create unique index if not exists t2a on t2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $SECONDARY_DBNAME $x"

    # Create t3 SECONDARY_DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create table if not exists t3(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t3 for $SECONDARY_DBNAME $x"
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create unique index if not exists t3a on t3(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $SECONDARY_DBNAME $x"

    # Create t4 SECONDARY_DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create table if not exists t4(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t4 for $SECONDARY_DBNAME $x"
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create unique index if not exists t4a on t4(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $SECONDARY_DBNAME $x"


    # Create secondary d1
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create table if not exists d1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d1 for $SECONDARY_DBNAME $x"
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create index if not exists d1a on d1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $SECONDARY_DBNAME $x"

    # Create secondary d2
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create table if not exists d2(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d2 for $SECONDARY_DBNAME $x"
    x=$($CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "create index if not exists d2a on d2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $SECONDARY_DBNAME $x"


    # Create t1 TERTIARY
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create table if not exists t1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t1 for $TERTIARY_DBNAME $x"
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create unique index if not exists t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $TERTIARY_DBNAME $x"

    # Create d1 tertiary
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create table if not exists d1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d1 for $TERTIARY_DBNAME $x"
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create index if not exists d1a on d1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $TERTIARY_DBNAME $x"

    # Create t2 DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create table if not exists t2(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t2 for $TERTIARY_DBNAME $x"
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create unique index if not exists t2a on t2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $TERTIARY_DBNAME $x"

    # Create t3 TERTIARY_DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create table if not exists t3(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t3 for $TERTIARY_DBNAME $x"
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create unique index if not exists t3a on t3(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $TERTIARY_DBNAME $x"

    # Create t4 TERTIARY_DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create table if not exists t4(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t4 for $TERTIARY_DBNAME $x"
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create unique index if not exists t4a on t4(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $TERTIARY_DBNAME $x"


    # Create d2 tertiary
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create table if not exists d2(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d1 for $TERTIARY_DBNAME $x"
    x=$($CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "create index if not exists d2a on d2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $TERTIARY_DBNAME $x"


    # Create t1 QUATERNARY
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create table if not exists t1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t1 for $QUATERNARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create unique index if not exists t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $QUATERNARY_DBNAME $x"


    # Create t2 DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create table if not exists t2(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t2 for $QUATERNARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create unique index if not exists t2a on t2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $QUATERNARY_DBNAME $x"

    # Create t3 QUATERNARY_DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create table if not exists t3(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t3 for $QUATERNARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create unique index if not exists t3a on t3(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $QUATERNARY_DBNAME $x"

    # Create t4 QUATERNARY_DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create table if not exists t4(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t4 for $QUATERNARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create unique index if not exists t4a on t4(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $QUATERNARY_DBNAME $x"


    # Create d1 QUATERNARY
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create table if not exists d1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d1 for $QUATERNARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create index if not exists d1a on d1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $QUATERNARY_DBNAME $x"

    # Create d2 QUATERNARY
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create table if not exists d2(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d1 for $QUATERNARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "create index if not exists d2a on d2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $QUATERNARY_DBNAME $x"

    # Create t1 QUINARY
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create table if not exists t1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t1 for $QUINARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create unique index if not exists t1a on t1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $QUINARY_DBNAME $x"


    # Create t2 DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create table if not exists t2(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t2 for $QUINARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create unique index if not exists t2a on t2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $QUINARY_DBNAME $x"

    # Create t3 QUINARY_DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create table if not exists t3(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t3 for $QUINARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create unique index if not exists t3a on t3(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $QUINARY_DBNAME $x"

    # Create t4 QUINARY_DBNAME (for benchmark)
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create table if not exists t4(a int)" 2>&1) 
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table t4 for $QUINARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create unique index if not exists t4a on t4(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating unique index for $QUINARY_DBNAME $x"


    # Create d1 QUINARY
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create table if not exists d1(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d1 for $QUINARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create index if not exists d1a on d1(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $QUINARY_DBNAME $x"

    # Create d2 QUINARY
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create table if not exists d2(a int)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating table d1 for $QUINARY_DBNAME $x"
    x=$($CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "create index if not exists d2a on d2(a)" 2>&1)
    r=$? ; [[ "$r" == "0" ]] || fail_exit "failed creating index for $QUINARY_DBNAME $x"
}

function wait_dist_table
{
    typeset max=10
    typeset j=0
    typeset count=0
    echo "wait_dist_table"
    while [[ $j -lt $max && "$count" -ne "1" ]]; do
        count=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from comdb2_tables where tablename='comdb2_distributed_transactions'")
        if [[ "$count" -ne "1" ]]; then
            echo "Waiting for comdb2_distributed_transactions table"
            sleep 2
        fi
        let j=j+1
    done
    [[ "$count" == "1" ]] || fail_exit "missing distributed transactions table"
}

function delete_records_ignore_error
{
    echo "delete_records_ignore_error"
    typeset r=1
    typeset c=0
    typeset j=0
    while [[ "$r" -ne "0" ]]; do
    r=0
    let j=j+1
    echo "begin
delete from t1 where 1
delete from $SECONDARY_DBNAME.t1 where 1
delete from $TERTIARY_DBNAME.t1 where 1
delete from $QUATERNARY_DBNAME.t1 where 1
delete from $QUINARY_DBNAME.t1 where 1
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    c=$? ; if [[ "$c" != "0" ]]; then r=$c; fi

    echo "begin
delete from t2 where 1
delete from $SECONDARY_DBNAME.t2 where 1
delete from $TERTIARY_DBNAME.t2 where 1
delete from $QUATERNARY_DBNAME.t2 where 1
delete from $QUINARY_DBNAME.t2 where 1
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    c=$? ; if [[ "$c" != "0" ]]; then r=$c; fi

    echo "begin
delete from t3 where 1
delete from $SECONDARY_DBNAME.t3 where 1
delete from $TERTIARY_DBNAME.t3 where 1
delete from $QUATERNARY_DBNAME.t3 where 1
delete from $QUINARY_DBNAME.t3 where 1
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    c=$? ; if [[ "$c" != "0" ]]; then r=$c; fi

    echo "begin
delete from t4 where 1
delete from $SECONDARY_DBNAME.t4 where 1
delete from $TERTIARY_DBNAME.t4 where 1
delete from $QUATERNARY_DBNAME.t4 where 1
delete from $QUINARY_DBNAME.t4 where 1
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    c=$? ; if [[ "$c" != "0" ]]; then r=$c; fi

    echo "begin
delete from d1 where 1
delete from $SECONDARY_DBNAME.d1 where 1
delete from $TERTIARY_DBNAME.d1 where 1
delete from $QUATERNARY_DBNAME.d1 where 1
delete from $QUINARY_DBNAME.d1 where 1
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    c=$? ; if [[ "$c" != "0" ]]; then r=$c; fi

    echo "begin
delete from d2 where 1
delete from $SECONDARY_DBNAME.d2 where 1
delete from $TERTIARY_DBNAME.d2 where 1
delete from $QUATERNARY_DBNAME.d2 where 1
delete from $QUINARY_DBNAME.d2 where 1
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    c=$? ; if [[ "$c" != "0" ]]; then r=$c; fi
    
    if [[ "$r" -ne "0" ]] ; then
        echo "Error deleting iteration $j"
        update_all_tunables
        sleep 1
    fi
    done
}

function delete_records
{
    echo "delete_records"
    typeset j=0
    echo "begin
delete from t1 where 1
delete from $SECONDARY_DBNAME.t1 where 1
delete from $TERTIARY_DBNAME.t1 where 1
delete from $QUATERNARY_DBNAME.t1 where 1
delete from $QUINARY_DBNAME.t1 where 1
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
    r=$?
    [[ "$r" == "0" ]] || fail_exit "failed deleting records"

    # Verify that they are deleted
    echo "Sleeping for 3"
    sleep 3

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $SECONDARY_DBNAME.t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$SECONDARY_DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $TERTIARY_DBNAME.t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$TERTIARY_DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUATERNARY_DBNAME.t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$QUATERNARY_DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUINARY_DBNAME.t1")
    if [[ "$x" -ne "0" ]]; then
        fail_exit "$QUINARY_DBNAME has $x records after delete"
    fi
}

function insert_records_bulk
{
    echo "insert_records_bulk"
    typeset j=0
    typeset count=$1
    typeset iterations=$2
    while [[ $j -lt $iterations ]]; do
        echo "begin
insert into t1(a) select * from generate_series($(( ( j * count ) + 1)), $(( ( j + 1 ) * count )))
insert into $SECONDARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into $TERTIARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into $QUATERNARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into $QUINARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"
        let j=j+1
    done
}

function verify_no_distcommit
{
    echo "verify_no_distcommit"
    typeset beforecnt=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from comdb2_distributed_transactions")
    typeset aftercnt=""
    j=0
    while [[ $j -lt 10 ]]; do
        echo "begin
update t1 set a = a+1 where a = 100000
update $SECONDARY_DBNAME.t1 set a = a+1 where a = 100000
update $TERTIARY_DBNAME.t1 set a = a+1 where a = 100000
update $QUATERNARY_DBNAME.t1 set a = a+1 where a = 100000
update $QUINARY_DBNAME.t1 set a = a+1 where a = 100000
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" != "0" ]] && fail_exit "got bad rcode for empty update iteration $j"
        let j=j+1
    done
    aftercnt=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from comdb2_distributed_transactions")
    [[ "$beforecnt" == "$aftercnt" ]] || fail_exit "expected no distributed transactions, but found $aftercnt - $beforecnt"
}

function no_coordinator_writes
{
    echo "no_coordinator_writes"
    j=0
    while [[ $j -lt 10 ]]; do
        echo "begin
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"
        let j=j+1
    done

    # Verify that there are 10 records in each participant database, and no records locally
    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && fail_exit "$DBNAME should not have any record, it has $x records"

    x=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$SECONDARY_DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$TERTIARY_DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$QUATERNARY_DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$QUINARY_DBNAME has only $x records"

    # Do it again.. this time we should fail with a constraint violation because records 
    # are already there
    #
    j=0
    while [[ $j -lt 10 ]]; do
        typeset d2=11
        typeset d3=11
        typeset d4=11
        typeset d5=11
        typeset r=$(( RANDOM % 4 ))
        case $r in
            0)
                d2=1
                ;;
            1)
                d3=1
                ;;
            2)
                d4=1
                ;;
            3)
                d5=1
                ;;
        esac
        echo "begin
insert into $SECONDARY_DBNAME.t1(a) values($d2)
insert into $TERTIARY_DBNAME.t1(a) values($d3)
insert into $QUATERNARY_DBNAME.t1(a) values($d4)
insert into $QUINARY_DBNAME.t1(a) values($d5)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" != "0" ]] || fail_exit "expected failure inserting iteration $j"
        let j=j+1
    done

    delete_records
}

function insert_records_to_normalize
{
    echo "insert_records_to_normalize"
    j=0
    while [[ $j -lt 10 ]]; do
        echo "begin
insert into t1(a) values($j)
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"
        let j=j+1
    done

    # Verify that there are 10 records in each database
    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$SECONDARY_DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$TERTIARY_DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$QUATERNARY_DBNAME has only $x records"

    x=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "10" ]] && fail_exit "$QUINARY_DBNAME has only $x records"

    delete_records
}

function insert_records_basic
{
    echo "insert_records_basic"
    j=0
    startms=$(timems)
    records=200
    while [[ $j -lt $records ]]; do
        startsinglems=$(timems)
        echo "begin
insert into t1(a) values($j)
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
        r=$?
        stopsinglems=$(timems)
        [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"
        if [[ "$(( stopsinglems - startsinglems ))" -gt $maxtime ]]; then
            #fail_exit "Single record test took $(( stopsinglems - startsinglems )) ms"
            while :; do
                echo "test failed, single record took $(( stopsinglems - startsinglems )) ms"
                sleep 1
            done
        fi
        let j=j+1
    done
    donems=$(timems)
    elapsed=$(( donems - startms ))
    echo "Elapsed time is $elapsed"

    # Verify counts
    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    if [[ "$x" != "$records" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME --host $node "select * from t1 order by a")
        done
        fail_exit "$DBNAME has only $x records"
    fi 

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $SECONDARY_DBNAME.t1")
    if [[ "$x" != "$records" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $node "select * from t1 order by a")
        done
        fail_exit "$SECONDARY_DBNAME has only $x records"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $TERTIARY_DBNAME.t1")
    if [[ "$x" != "$records" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $node "select * from t1 order by a")
        done
        fail_exit "$TERTIARY_DBNAME has only $x records"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUATERNARY_DBNAME.t1")
    if [[ "$x" != "$records" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $node "select * from t1 order by a")
        done
        fail_exit "$QUATERNARY_DBNAME has only $x records"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUINARY_DBNAME.t1")
    if [[ "$x" != "$records" ]] ; then 
        for node in $CLUSTER ; do
            echo "Node $node"
            x=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $node "select count(*) from t1")
            x=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $node "select * from t1 order by a")
        done
        fail_exit "$QUINARY_DBNAME has only $x records"
    fi
}

function setup
{
    verify_allow_coordinator
    create_comdb2db
    create_tables
    wait_dist_table
    allow_coordinator
}

function basic_test
{
    typeset j=0
    typeset cnt=${1:-1}
    while [[ $j -lt $cnt ]]; do
        insert_records_basic
        delete_records
        let j=j+1
    done
}

function bulk_test
{
    typeset cnt=${1:-1}
    typeset j=0
    while [[ $j -lt "$cnt" ]]; do
        insert_records_bulk 1000 20
        delete_records
        let j=j+1
    done
}

function toggle_tunable
{
    typeset tunable=$1
    typeset onoff=$2
    typeset skip_coordinator=$3
    typeset only_coordinator=$4

    if [[ -z ${CLUSTER} ]]; then
        if [[ "$skip_coordinator" == "0" ]]; then
            $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME default "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
        fi
        if [[ "$only_coordinator" == "0" ]]; then
            $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
            $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
        fi
    else
        for mach in ${CLUSTER}; do
            if [[ "$skip_coordinator" == "0" ]]; then
                $CDB2SQL_EXE -admin $CDB2_OPTIONS $DBNAME --host $mach "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
            fi
            if [[ "$only_coordinator" == "0" ]]; then
                $CDB2SQL_EXE -admin $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $mach "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
                $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $mach "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
                $CDB2SQL_EXE -admin $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $mach "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
                $CDB2SQL_EXE -admin $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME --host $mach "put tunable ${tunable} '${onoff}'" >/dev/null 2>&1
            fi
        done
    fi
}

function set_sleep_before_dispatch_tertiary
{
    typeset slp=$1
    if [[ -z ${CLUSTER} ]]; then
        $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "put tunable 'sleep_before_dispatch' '${slp}'"
    else
        for mach in ${CLUSTER}; do
            $CDB2SQL_EXE -admin $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $mach "put tunable 'sleep_before_dispatch' '${slp}'"
        done
    fi
}

function toggle_disable_waitdie_deadlock_detection
{
    typeset onoff=$1
    toggle_tunable debug_disable_waitdie_deadlock_detection $onoff 0 0
}

function toggle_random_deadlocks
{
    typeset onoff=$1
    toggle_tunable debug.toblock_random_deadlock_trans $onoff 0 0
}

function toggle_random_verify_errors
{
    typeset onoff=$1
    # Skip coordinator at first to see if it works
    toggle_tunable debug.toblock_random_verify_error $onoff 0 0
}

function toggle_verify_retry_max
{
    typeset max=$1
    toggle_tunable osql_verify_retry_max $max 0 0
}

function toggle_debug_coordinator_dispatch_failure
{
    typeset onoff=$1
    toggle_tunable debug_coordinator_dispatch_failure $onoff 0 0
}

function toggle_debug_wait_on_verify_off
{
    typeset onoff=$1
    toggle_tunable debug_wait_on_verify_off $onoff 0 0
}

function toggle_debug_sleep_before_prepare
{
    typeset onoff=$1
    toggle_tunable debug_sleep_before_prepare $onoff 1 0
}

function toggle_debug_sleep_coordinator_before_commit
{
    typeset onoff=$1
    toggle_tunable debug_sleep_coordinator_before_commit $onoff 0 1
}

function toggle_debug_sleep_on_set_read_only
{
    typeset onoff=$1
    toggle_tunable debug_sleep_on_set_read_only $onoff 0 1
}

function quinary_coordinator_insert
{
    typeset j=$1
    typeset tbl=$2
    typeset tbl2=$3
    startms=$(timems)
    echo "$startms START QUINARY INSERT"
    echo "begin
insert into $DBNAME.$tbl(a) values($j)
insert into $SECONDARY_DBNAME.$tbl(a) values($j)
insert into $TERTIARY_DBNAME.$tbl(a) values($j)
insert into $QUATERNARY_DBNAME.$tbl(a) values($j)
insert into $tbl(a) values($j)
insert into $DBNAME.$tbl2(a) values($j)
insert into $SECONDARY_DBNAME.$tbl2(a) values($j)
insert into $TERTIARY_DBNAME.$tbl2(a) values($j)
insert into $QUATERNARY_DBNAME.$tbl2(a) values($j)
insert into $tbl2(a) values($j)
commit
" | $CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    if [[ "$totalms" -gt "$LONGINSERTTIME" ]]; then
        echo "Long insert $totalms ms investigate time $startms to $donems for $j on $QUINARY_DBNAME"
        [[ "$FAIL_ON_LONG_INSERT" -ne "0" ]] && fail_exit "long insert"
    fi
    echo "$r"
}

function quaternary_coordinator_insert
{
    typeset j=$1
    typeset tbl=$2
    typeset tbl2=$3
    startms=$(timems)
    echo "$startms START QUATERNARY INSERT"
    echo "begin
insert into $DBNAME.$tbl(a) values($j)
insert into $SECONDARY_DBNAME.$tbl(a) values($j)
insert into $TERTIARY_DBNAME.$tbl(a) values($j)
insert into $tbl(a) values($j)
insert into $QUINARY_DBNAME.$tbl(a) values($j)
insert into $DBNAME.$tbl2(a) values($j)
insert into $SECONDARY_DBNAME.$tbl2(a) values($j)
insert into $TERTIARY_DBNAME.$tbl2(a) values($j)
insert into $tbl2(a) values($j)
insert into $QUINARY_DBNAME.$tbl2(a) values($j)
commit
" | $CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    if [[ "$totalms" -gt "$LONGINSERTTIME" ]]; then
        echo "Long insert $totalms ms investigate time $startms to $donems for $j on $QUATERNARY_DBNAME"
        [[ "$FAIL_ON_LONG_INSERT" -ne "0" ]] && fail_exit "long insert"
    fi
    echo "$r"
}

function tertiary_coordinator_insert
{
    typeset j=$1
    typeset tbl=$2
    typeset tbl2=$3
    startms=$(timems)
    startms=$(timems)
    echo "$startms START TERTIARY INSERT"
    echo "begin
insert into $DBNAME.$tbl(a) values($j)
insert into $SECONDARY_DBNAME.$tbl(a) values($j)
insert into $tbl(a) values($j)
insert into $QUATERNARY_DBNAME.$tbl(a) values($j)
insert into $QUINARY_DBNAME.$tbl(a) values($j)
insert into $DBNAME.$tbl2(a) values($j)
insert into $SECONDARY_DBNAME.$tbl2(a) values($j)
insert into $tbl2(a) values($j)
insert into $QUATERNARY_DBNAME.$tbl2(a) values($j)
insert into $QUINARY_DBNAME.$tbl2(a) values($j)
commit
" | $CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    if [[ "$totalms" -gt "$LONGINSERTTIME" ]]; then
        echo "Long insert $totalms ms investigate time $startms to $donems for $j on $TERTIARY_DBNAME"
        [[ "$FAIL_ON_LONG_INSERT" -ne "0" ]] && fail_exit "long insert"
    fi
    echo "$r"
}

function secondary_coordinator_insert
{
    typeset j=$1
    typeset tbl=$2
    typeset tbl2=$3
    startms=$(timems)
    echo "$startms START SECONDARY INSERT"
    echo "begin
insert into $DBNAME.$tbl(a) values($j)
insert into $tbl(a) values($j)
insert into $TERTIARY_DBNAME.$tbl(a) values($j)
insert into $QUATERNARY_DBNAME.$tbl(a) values($j)
insert into $QUINARY_DBNAME.$tbl(a) values($j)
insert into $DBNAME.$tbl2(a) values($j)
insert into $tbl2(a) values($j)
insert into $TERTIARY_DBNAME.$tbl2(a) values($j)
insert into $QUATERNARY_DBNAME.$tbl2(a) values($j)
insert into $QUINARY_DBNAME.$tbl2(a) values($j)
commit
" | $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    if [[ "$totalms" -gt "$LONGINSERTTIME" ]]; then
        echo "Long insert $totalms ms investigate time $startms to $donems for $j on $SECONDARY_DBNAME"
        [[ "$FAIL_ON_LONG_INSERT" -ne "0" ]] && fail_exit "long insert"
    fi
    echo "$r"
}

function normal_coordinator_insert
{
    typeset j=$1
    typeset tbl=$2
    typeset tbl2=$3
    startms=$(timems)
    echo "$startms START PRIMARY INSERT"
    echo "begin
insert into $tbl(a) values($j)
insert into $SECONDARY_DBNAME.$tbl(a) values($j)
insert into $TERTIARY_DBNAME.$tbl(a) values($j)
insert into $QUATERNARY_DBNAME.$tbl(a) values($j)
insert into $QUINARY_DBNAME.$tbl(a) values($j)
insert into $tbl2(a) values($j)
insert into $SECONDARY_DBNAME.$tbl2(a) values($j)
insert into $TERTIARY_DBNAME.$tbl2(a) values($j)
insert into $QUATERNARY_DBNAME.$tbl2(a) values($j)
insert into $QUINARY_DBNAME.$tbl2(a) values($j)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    if [[ "$totalms" -gt "$LONGINSERTTIME" ]]; then
        echo "Long insert $totalms ms investigate time $tbl $startms to $donems for $j on $DBNAME"
        [[ "$FAIL_ON_LONG_INSERT" -ne "0" ]] && fail_exit "long insert"
    fi
    echo "$r"
}

function normal_coordinator_nodist_insert
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset st=$(( j - 100 ))
    typeset ed=$(( j + 100 ))
    typeset back=$(( RANDOM % 2 ))
    startms=$(timems)
    if [[ "$back" == "1" ]]; then
        echo "begin
insert into $tbl select * from generate_series($ed, $st, -1)
insert into $tbl2 select * from generate_series($ed, $st, -1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    else
        echo "begin
insert into $tbl select * from generate_series($ed, $st)
insert into $tbl2 select * from generate_series($ed, $st)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?

    fi
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function normal_coordinator_nodist_delete
{
    typeset j=$1
    typeset tbl=${2:-t1}
    typeset tbl2=${2:-t1}
    startms=$(timems)
    echo "begin
delete from $tbl where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
delete from $tbl2 where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function secondary_coordinator_nodist_delete
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    startms=$(timems)
    echo "begin
delete from $tbl where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
delete from $tbl2 where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
commit
" | $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function tertiary_coordinator_nodist_delete
{
    typeset j=$1
    typeset tbl=${2:-t1}
    startms=$(timems)
    echo "begin
delete from $tbl where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
delete from $tbl2 where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
commit
" | $CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function quaternary_coordinator_nodist_delete
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    startms=$(timems)
    echo "begin
delete from $tbl where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
delete from $tbl2 where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
commit
" | $CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function quinary_coordinator_nodist_delete
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${2:-d2}
    startms=$(timems)
    echo "begin
delete from $tbl where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
delete from $tbl2 where a > $(( j - DELETE_SCOPE )) and a < $(( j + DELETE_SCOPE ))
commit
" | $CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function secondary_coordinator_nodist_insert
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset st=$(( j - 100 ))
    typeset ed=$(( j + 100 ))
    typeset back=$(( RANDOM % 2 ))
    startms=$(timems)
    if [[ "$back" == "1" ]]; then
        echo "begin
insert into $tbl select * from generate_series($ed, $st, -1)
insert into $tbl2 select * from generate_series($ed, $st, -1)
commit
" | $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default -
        r=$?
    else
        echo "begin
insert into $tbl select * from generate_series($ed, $st)
insert into $tbl2 select * from generate_series($ed, $st)
commit
" | $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default -
        r=$?
    fi
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function tertiary_coordinator_nodist_insert
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset st=$(( j - 100 ))
    typeset ed=$(( j + 100 ))
    typeset back=$(( RANDOM % 2 ))
    if [[ "$back" == "1" ]]; then
        echo "begin
insert into $tbl select * from generate_series($ed, $st, -1)
insert into $tbl2 select * from generate_series($ed, $st, -1)
commit
" | $CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default -
        r=$?
    else
        echo "begin
insert into $tbl select * from generate_series($ed, $st)
insert into $tbl2 select * from generate_series($ed, $st)
commit
" | $CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default -
        r=$?
    fi
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function quaternary_coordinator_nodist_insert
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset st=$(( j - 100 ))
    typeset ed=$(( j + 100 ))
    typeset back=$(( RANDOM % 2 ))
    startms=$(timems)
    if [[ "$back" == "1" ]]; then
        echo "begin
insert into $tbl select * from generate_series($ed, $st, -1)
insert into $tbl2 select * from generate_series($ed, $st, -1)
commit
" | $CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default -
        r=$?
    else
        echo "begin
insert into $tbl select * from generate_series($ed, $st)
insert into $tbl2 select * from generate_series($ed, $st)
commit
" | $CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default -
        r=$?
    fi
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function quinary_coordinator_nodist_insert
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset st=$(( j - 100 ))
    typeset ed=$(( j + 100 ))
    typeset back=$(( RANDOM % 2 ))
    startms=$(timems)
    if [[ "$back" == "1" ]]; then
        echo "begin
insert into $tbl select * from generate_series($ed, $st, -1)
insert into $tbl2 select * from generate_series($ed, $st, -1)
commit
" | $CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default -
        r=$?
    else
        echo "begin
insert into $tbl select * from generate_series($ed, $st)
insert into $tbl2 select * from generate_series($ed, $st)
commit
" | $CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default -
        r=$?
    fi
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

# This is purposely not a distributed txn
function normal_coordinator_nodist_update
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset st=$(( j - UPDATE_SCOPE ))
    typeset ed=$(( j + UPDATE_SCOPE ))
    startms=$(timems)
    #$CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "update $tbl set a = a where a > $st and a < $ed"
    echo "begin
update $tbl set a = a where a > $st and a < $ed
update $tbl2 set a = a where a > $st and a < $ed
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function secondary_coordinator_nodist_update
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset st=$(( j - UPDATE_SCOPE ))
    typeset ed=$(( j + UPDATE_SCOPE ))
    startms=$(timems)
    echo "begin
update $tbl set a = a where a > $st and a < $ed
update $tbl2 set a = a where a > $st and a < $ed
commit
" | $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function tertiary_coordinator_nodist_update
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset st=$(( j - UPDATE_SCOPE ))
    typeset ed=$(( j + UPDATE_SCOPE ))
    startms=$(timems)
    echo "begin
update $tbl set a = a where a > $st and a < $ed
update $tbl2 set a = a where a > $st and a < $ed
commit
" | $CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function quaternary_coordinator_nodist_update
{
    typeset j=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset st=$(( j - UPDATE_SCOPE ))
    typeset ed=$(( j + UPDATE_SCOPE ))
    startms=$(timems)
    echo "begin
update $tbl set a = a where a > $st and a < $ed
update $tbl2 set a = a where a > $st and a < $ed
commit
" | $CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function quinary_coordinator_nodist_update
{
    typeset j=$1
    typeset tbl=${2:-t1}
    typeset tbl2=${2:-t1}
    typeset st=$(( j - UPDATE_SCOPE ))
    typeset ed=$(( j + UPDATE_SCOPE ))
    startms=$(timems)
    echo "begin
update $tbl set a = a where a > $st and a < $ed
update $tbl2 set a = a where a > $st and a < $ed
commit
" | $CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    echo "$r"
}

function quinary_coordinator_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset rand=${4:-0}
    typeset val=5
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        if [[ "$rand" == "1" ]]; then
            let val=$(( RANDOM % max ))
            quinary_coordinator_insert $val $tbl $tbl2
        else
            quinary_coordinator_insert $val $tbl $tbl2
        fi
        let val=val+skip
        let j=j+1
    done
}

function quaternary_coordinator_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset rand=${4:-0}
    typeset val=4
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        if [[ "$rand" == "1" ]]; then
            let val=$(( RANDOM % max ))
            quaternary_coordinator_insert $val $tbl $tbl2
        else
            quaternary_coordinator_insert $val $tbl $tbl2
        fi
        let val=val+skip
        let j=j+1
    done
}

function tertiary_coordinator_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset rand=${4:-0}
    typeset val=3
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        if [[ "$rand" == "1" ]]; then
            let val=$(( RANDOM % max ))
            tertiary_coordinator_insert $val $tbl $tbl2
        else
            tertiary_coordinator_insert $val $tbl $tbl2
        fi
        let val=val+skip
        let j=j+1
    done
}

function secondary_coordinator_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${2:-d2}
    typeset rand=${3:-0}
    typeset val=2
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        if [[ "$rand" == "1" ]]; then
            let val=$(( RANDOM % max ))
            secondary_coordinator_insert $val $tbl $tbl2
        else
            secondary_coordinator_insert $val $tbl $tbl2
        fi
        let val=val+skip
        let j=j+1
    done
}

function normal_coordinator_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset rand=${4:-0}
    typeset val=1
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        if [[ "$rand" == "1" ]]; then
            let val=$(( RANDOM % max ))
            normal_coordinator_insert $val $tbl $tbl2
        else
            normal_coordinator_insert $val $tbl $tbl2
        fi
        let val=val+skip
        let j=j+1
    done
}

function normal_coordinator_nodist_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset val=1
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        normal_coordinator_nodist_update $val $tbl $tbl2
        normal_coordinator_nodist_insert $val $tbl $tbl2
        normal_coordinator_nodist_delete $val $tbl $tbl2
        let val=val+skip
        let j=j+1
    done
}

function secondary_coordinator_nodist_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset val=1
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        secondary_coordinator_nodist_update $val $tbl $tbl2
        secondary_coordinator_nodist_insert $val $tbl $tbl2
        secondary_coordinator_nodist_delete $val $tbl $tbl2
        let val=val+skip
        let j=j+1
    done
}

function tertiary_coordinator_nodist_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset val=1
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        tertiary_coordinator_nodist_update $val $tbl $tbl2
        tertiary_coordinator_nodist_insert $val $tbl $tbl2
        tertiary_coordinator_nodist_delete $val $tbl $tbl2
        let val=val+skip
        let j=j+1
    done
}

function quaternary_coordinator_nodist_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset val=1
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        quaternary_coordinator_nodist_update $val $tbl $tbl2
        quaternary_coordinator_nodist_insert $val $tbl $tbl2
        quaternary_coordinator_nodist_delete $val $tbl $tbl2
        let val=val+skip
        let j=j+1
    done
}

function quinary_coordinator_nodist_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}
    typeset val=1
    typeset skip=10
    typeset j=0
    while [[ $j -lt $max ]]; do
        quinary_coordinator_nodist_update $val $tbl $tbl2
        quinary_coordinator_nodist_insert $val $tbl $tbl2
        quinary_coordinator_nodist_delete $val $tbl $tbl2
        let val=val+skip
        let j=j+1
    done
}

# 'Simple' version of this shows logic working when ONLY dist-txns are in the
# picture.  It is easily handled in lock_get
function distributed_deadlocks_simple
{
    typeset iters=1000
    echo "distributed_deadlocks"

    startms=$(timems)
    normal_coordinator_loop $iters &
    secondary_coordinator_loop $iters &
    tertiary_coordinator_loop $iters &
    quaternary_coordinator_loop $iters &
    quinary_coordinator_loop $iters &
    wait
    endms=$(timems)

    # Verify integrity of our txns
    mycount=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1" 2>&1)
    echo "No distributed deadlock, added $mycount records out of $(( iters * 5 )) in $(( endms - startms )) ms"

    primary=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select * from t1 order by a" 2>&1)
    secondary=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select * from t1 order by a" 2>&1)
    tertiary=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select * from t1 order by a" 2>&1)
    quaternary=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select * from t1 order by a" 2>&1)
    quinary=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select * from t1 order by a" 2>&1)

    [[ "$secondary" != "$primary" ]] && fail_exit "Secondary dataset doesnt match"
    [[ "$tertiary" != "$primary" ]] && fail_exit "Tertiary dataset doesnt match"
    [[ "$quaternary" != "$primary" ]] && fail_exit "Quaternary dataset doesnt match"
    [[ "$quinary" != "$primary" ]] && fail_exit "Quinary dataset doesnt match"

    delete_records_ignore_error
}

function random_nodist_insert
{
    typeset val=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}

    typeset coord=$(( RANDOM % 5 ))
    case $coord in
        0) 
            dbname=$DBNAME
            opts=$CDB2_OPTIONS
            ;;
        1) 
            dbname=$SECONDARY_DBNAME
            opts=$SECONDARY_CDB2_OPTIONS
            ;;
        2) 
            dbname=$TERTIARY_DBNAME
            opts=$TERTIARY_CDB2_OPTIONS
            ;;
        3) 
            dbname=$QUATERNARY_DBNAME
            opts=$QUATERNARY_CDB2_OPTIONS
            ;;
        4) 
            dbname=$QUINARY_DBNAME
            opts=$QUINARY_CDB2_OPTIONS
            ;;
    esac
    startms=$(timems)
    echo "begin
insert into $tbl(a) values($val)
insert into $tbl2(a) values($val)
commit
" | $CDB2SQL_EXE $opts $dbname default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    if [[ "$totalms" -gt "$LONGINSERTTIME" ]]; then
        echo "Long insert $totalms ms investigate time $tbl $startms to $donems for $j on $dbname"
        [[ "$FAIL_ON_LONG_INSERT" -ne "0" ]] && fail_exit "long insert"
    fi
}

function random_dist_insert
{
    typeset val=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}

    typeset coord=$(( RANDOM % 5 ))
    typeset dbname=""
    typeset first_dbname=""
    typeset second_dbname=""
    typeset third_dbname=""
    typeset forth_dbname=""
    typeset opts=""

    case $coord in
        0) 
            dbname=$DBNAME
            opts=$CDB2_OPTIONS
            ;;
        1) 
            dbname=$SECONDARY_DBNAME
            opts=$SECONDARY_CDB2_OPTIONS
            ;;
        2) 
            dbname=$TERTIARY_DBNAME
            opts=$TERTIARY_CDB2_OPTIONS
            ;;
        3) 
            dbname=$QUATERNARY_DBNAME
            opts=$QUATERNARY_CDB2_OPTIONS
            ;;
        4) 
            dbname=$QUINARY_DBNAME
            opts=$QUINARY_CDB2_OPTIONS
            ;;
    esac

    typeset db=$(( RANDOM % 5 ))
    case $db in
        0) 
            first_dbname=$DBNAME
            ;;
        1) 
            first_dbname=$SECONDARY_DBNAME
            ;;
        2) 
            first_dbname=$TERTIARY_DBNAME
            ;;
        3) 
            first_dbname=$QUATERNARY_DBNAME
            ;;
        4) 
            first_dbname=$QUINARY_DBNAME
            ;;
    esac

    typeset db=$(( RANDOM % 5 ))
    case $db in
        0) 
            second_dbname=$DBNAME
            ;;
        1) 
            second_dbname=$SECONDARY_DBNAME
            ;;
        2) 
            second_dbname=$TERTIARY_DBNAME
            ;;
        3) 
            second_dbname=$QUATERNARY_DBNAME
            ;;
        4) 
            second_dbname=$QUINARY_DBNAME
            ;;
    esac

    typeset db=$(( RANDOM % 5 ))
    case $db in
        0) 
            third_dbname=$DBNAME
            ;;
        1) 
            third_dbname=$SECONDARY_DBNAME
            ;;
        2) 
            third_dbname=$TERTIARY_DBNAME
            ;;
        3) 
            third_dbname=$QUATERNARY_DBNAME
            ;;
        4) 
            third_dbname=$QUINARY_DBNAME
            ;;
    esac

    typeset db=$(( RANDOM % 5 ))
    case $db in
        0) 
            fourth_dbname=$DBNAME
            ;;
        1) 
            fourth_dbname=$SECONDARY_DBNAME
            ;;
        2) 
            fourth_dbname=$TERTIARY_DBNAME
            ;;
        3) 
            fourth_dbname=$QUATERNARY_DBNAME
            ;;
        4) 
            fourth_dbname=$QUINARY_DBNAME
            ;;
    esac

    startms=$(timems)
    echo " begin
insert into $first_dbname.$tbl(a) values($val)
insert into $second_dbname.$tbl(a) values($val)
insert into $third_dbname.$tbl2(a) values($val)
insert into $fourth_dbname.$tbl2(a) values($val)
commit
" | $CDB2SQL_EXE $opts $dbname default -
    r=$?
    donems=$(timems)
    totalms=$(( donems - startms ))
    if [[ "$totalms" -gt "$LONGINSERTTIME" ]]; then
        echo "Long insert $totalms ms investigate time $tbl $startms to $donems for $j on $dbname"
        [[ "$FAIL_ON_LONG_INSERT" -ne "0" ]] && fail_exit "long insert"
    fi
}

function random_nodist_insert_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}

    typeset j=0
    while [[ $j -lt $max ]]; do
        random_nodist_insert $j $tbl $tbl2
        let j=j+1
    done
}

function random_dist_insert_loop
{
    typeset max=$1
    typeset tbl=${2:-d1}
    typeset tbl2=${3:-d2}

    typeset j=0
    while [[ $j -lt $max ]]; do
        random_dist_insert $j $tbl $tbl2
        let j=j+1
    done
}

function distributed_deadlocks_compound_int
{
    typeset iters=1000
    echo "compound-distributed_deadlocks"

    startms=$(timems)

    random_dist_insert_loop $iters d1 d2 &
    random_dist_insert_loop $iters d1 d2 &
    random_dist_insert_loop $iters d1 d2 &
    random_dist_insert_loop $iters d1 d2 &
    random_dist_insert_loop $iters d1 d2 &

    random_nodist_insert_loop $iters d1 d2 &
    random_nodist_insert_loop $iters d1 d2 &
    random_nodist_insert_loop $iters d1 d2 &
    random_nodist_insert_loop $iters d1 d2 &
    random_nodist_insert_loop $iters d1 d2 &

    wait

    endms=$(timems)
    echo "compound-distributed-deadlocks took $(( endms - startms )) ms"

    delete_records_ignore_error
}

# 'Compound' version of this shows logic working when both normal and dist-txns exist.
# This requires special handling in deadlock-detection
function distributed_deadlocks_compound_try1_int
{
    typeset iters=1000
    echo "compound-distributed_deadlocks-try1"

    startms=$(timems)

    normal_coordinator_loop $iters d1 d2 &
    normal_coordinator_loop $iters d2 d1 &
    normal_coordinator_nodist_loop $iters d1 d2 &
    normal_coordinator_nodist_loop $iters d2 d1 &

    secondary_coordinator_loop $iters d1 d2 &
    secondary_coordinator_loop $iters d2 d1 &
    secondary_coordinator_nodist_loop $iters d1 d2 &
    secondary_coordinator_nodist_loop $iters d2 d1 &

    tertiary_coordinator_loop $iters d1 d2 &
    tertiary_coordinator_loop $iters d2 d1 &
    tertiary_coordinator_nodist_loop $iters d1 d2 &
    tertiary_coordinator_nodist_loop $iters d2 d1 &

    quaternary_coordinator_loop $iters d1 d2 &
    quaternary_coordinator_loop $iters d2 d1 &
    quaternary_coordinator_nodist_loop $iters d1 d2 &
    quaternary_coordinator_nodist_loop $iters d2 d1 &

    quinary_coordinator_loop $iters d1 d2 &
    quinary_coordinator_loop $iters d2 d1 &
    quinary_coordinator_nodist_loop $iters d1 d2 &
    quinary_coordinator_nodist_loop $iters d2 d1 &

    wait
    endms=$(timems)
    echo "compound-distributed-deadlocks took $(( endms - startms )) ms"

    delete_records_ignore_error
}

# This works
function random_deadlocks
{
    toggle_random_deadlocks 1
    insert_records_basic
    delete_records
    toggle_random_deadlocks 0
}

# This works
function random_verify_errors
{
    toggle_random_verify_errors 1
    insert_records_basic
    delete_records
    toggle_random_verify_errors 0
}

function participant_constraint_violation
{
    typeset j=0
    typeset r=0
    while [[ $j -lt 10 ]]; do
    startms=$(timems)
    echo "begin
insert into t1(a) values($j)
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -

    r=$?
    donems=$(timems)
    [[ "$r" == "0" ]] || fail_exit "participant_constraint_violation failed inserting"


    if [[ "$(( donems - startms ))" -gt $maxtime ]]; then
        fail_exit "took excessive time to insert good record"
    fi

    # Try each case in turn
    if [[ "$(( j % 4 ))" == "0" ]]; then
    startms=$(timems)
    output=$(echo "set verifyretry off
begin
insert into t1(a) values($(( j + 1 )))
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUATERNARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUINARY_DBNAME.t1(a) values($(( j + 1 )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1)
    r=$?
    donems=$(timems)
    fi

    if [[ "$(( j % 4 ))" == "1" ]]; then
    startms=$(timems)
    output=$(echo "set verifyretry off
begin
insert into t1(a) values($(( j + 1 )))
insert into $SECONDARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUINARY_DBNAME.t1(a) values($(( j + 1 )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1)
    r=$?
    donems=$(timems)
    fi

    if [[ "$(( j % 4 ))" == "2" ]]; then
    startms=$(timems)
    output=$(echo "set verifyretry off
begin
insert into t1(a) values($(( j + 1 )))
insert into $SECONDARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $TERTIARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($(( j + 1 )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1)
    r=$?
    donems=$(timems)
    fi

    if [[ "$(( j % 4 ))" == "3" ]]; then
    startms=$(timems)
    output=$(echo "set verifyretry off
begin
insert into t1(a) values($(( j + 1 )))
insert into $SECONDARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $TERTIARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUATERNARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1)
    r=$?
    donems=$(timems)
    fi

    [[ "$r" != "0" ]] || fail_exit "participant_constraint_violation succeeded incorrectly"
    if [[ "$output" == *"failed with rc 299"* ]]; then
        echo "participant_constraint_violation failed with correct rcode 299"
    else
        echo "participant_constraint_violation failed with incorrect rcode: $output"
        fail_exit "participant_constraint_violation failed with incorrect rcode"
    fi
    #echo "participant_constraint_violation output is $output"
    #echo "participant_constraint_violation failed with rcode $r"

    if [[ "$(( donems - startms ))" -gt $maxtime ]]; then
        fail_exit "took excessive time to fail to insert"
    fi
    
    let j=j+1
    done

    delete_records
}

function coordinator_constraint_violation
{
    typeset j=0
    while [[ $j -lt 10 ]]; do
    startms=$(timems)
    echo "begin
insert into t1(a) values($j)
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?

    donems=$(timems)

    [[ "$r" == "0" ]] || fail_exit "coordonator_constraint+violation failed inserting, r=$r"

    if [[ "$(( donems - startms ))" -gt $maxtime ]]; then
        fail_exit "coordinator took excessive time to insert good record"
    fi

    startms=$(timems)
    output=$(echo "set verifyretry off
begin
insert into $SECONDARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $TERTIARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUATERNARY_DBNAME.t1(a) values($(( j + 1 )))
insert into $QUINARY_DBNAME.t1(a) values($(( j + 1 )))
insert into t1(a) values(${j})
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1)
    r=$?

    donems=$(timems)

    [[ "$r" != "0" ]] || fail_exit "coordinator_constraint_violation succeeded incorrectly rcode=$r"
    
    if [[ "$(( donems - startms ))" -gt $maxtime ]]; then
        fail_exit "coordinator took excessive time to fail to insert insert bad record"
    fi
    if [[ "$output" == *"failed with rc 299"* ]]; then
        echo "coordinator_constraint_violation failed with correct rcode 299"
    else
        echo "coordinator_constraint_violation failed with incorrect rcode: $output"
        fail_exit "coordinator_constraint_violation failed with incorrect rcode"
    fi

    let j=j+1
    done

    delete_records
}

function forbid_disttxn_write_to_disttxn_table
{
    startms=$(timems)
    echo "begin
insert into comdb2_distributed_transactions(dist_txnid, timestamp) values ('hello2', now())
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    donems=$(timems)
    [[ "$r" == "0" ]] && fail_exit "forbid_write_to_disttxn_table incorrectly succeeded write to disttxn-table on coordinator"

    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.comdb2_distributed_transactions(dist_txnid, timestamp) values ('hello2', now())
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    donems=$(timems)
    [[ "$r" == "0" ]] && fail_exit "forbid_write_to_disttxn_table incorrectly succeeded write to disttxn-table on participant"

    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.comdb2_distributed_transactions(dist_txnid, timestamp) values ('hello2', now())
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    donems=$(timems)
    [[ "$r" == "0" ]] && fail_exit "forbid_write_to_disttxn_table incorrectly succeeded write to disttxn-table on participant"


    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.comdb2_distributed_transactions(dist_txnid, timestamp) values ('hello2', now())
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    donems=$(timems)
    [[ "$r" == "0" ]] && fail_exit "forbid_write_to_disttxn_table incorrectly succeeded write to disttxn-table on participant"

    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.comdb2_distributed_transactions(dist_txnid, timestamp) values ('hello2', now())
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    donems=$(timems)
    [[ "$r" == "0" ]] && fail_exit "forbid_write_to_disttxn_table incorrectly succeeded write to disttxn-table on participant"
}

function allow_write_to_disttxn_table
{
    startms=$(timems)
    echo "begin
insert into comdb2_distributed_transactions(dist_txnid, timestamp) values ('hello1', now())
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    donems=$(timems)
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "delete from comdb2_distributed_transactions where dist_txnid = 'hello1'" >/dev/null 2>&1
    [[ "$r" != "0" ]] && fail_exit "allow_write_to_disttxn_table failed to insert to disttxn-table rcode=$r"
}

function kill_restart_cluster
{
    typeset dbname=$1
    typeset options=$2
    typeset dbdir=$3
    typeset sleeptime=$4
    typeset skipmach=$5

    # Add 3 second of latency to respond to a prepare
    sleep 3

    REP_ENV_VARS="${dbdir}/replicant_env_vars"
    # Kill first
    for node in $CLUSTER ; do
        if [[ "$node" != "$skipmach" ]]; then
            $CDB2SQL_EXE $options $dbname --host $node "exec procedure sys.cmd.send('flush')"
            kill -9 $(cat ${TMPDIR}/${dbname}.${node}.pid)
        fi
    done

    # sleep
    sleep $sleeptime

    # restart
    for node in $CLUSTER ; do
        if [[ "$node" != "$skipmach" ]]; then
            PARAMS="$dbname --no-global-lrl"
            CMD="source ${REP_ENV_VARS} ; ${COMDB2_EXE} ${PARAMS} --lrl $dbdir/${dbname}.lrl --pidfile ${TMPDIR}/${dbname}.pid"
            if [ $node == $(hostname) ] ; then

            (
                #kill -9 $(cat ${TMPDIR}/${dbname}.${node}.pid)
                mv --backup=numbered $LOGDIR/${dbname}.db $LOGDIR/${dbname}.db.1
                ${DEBUG_PREFIX} ${COMDB2_EXE} ${PARAMS} --lrl $dbdir/${dbname}.lrl --pidfile ${TMPDIR}/${dbname}.${node}.pid 2>&1 | gawk '{ print strftime("%H:%M:%S>"), $0; fflush(); }' >$TESTDIR/logs/${dbname}.${node}.db 2>&1
            ) &

            else

                #kill -9 $(cat ${TMPDIR}/${dbname}.${node}.pid)
                mv --backup=numbered $LOGDIR/${dbname}.${node}.db $LOGDIR/${dbname}.${node}.db.1
                ssh -o StrictHostKeyChecking=no -tt $node ${DEBUG_PREFIX} ${CMD} 2>&1 </dev/null > >(gawk '{ print strftime("%H:%M:%S>"), $0; fflush(); }' >> $TESTDIR/logs/${dbname}.${node}.db) &
                echo $! > ${TMPDIR}/${dbname}.${node}.pid

            fi
        fi
    done
}

function block_until_cluster_is_up
{
    typeset dbname=$1
    typeset options=$2
    typeset isup=0

    while [[ "$isup" == 0 ]]; do
        isup=1
        for node in ${CLUSTER}; do
            $CDB2SQL_EXE $options $dbname --host $node "select 1"
            if [[ $? != 0 ]]; then
                isup=0
            fi
        done
        [[ "$isup" == 0 ]] && sleep 1
    done
}

# Setting the linger-time to 0 to force coordinator to search dist-txn table 
# to resolve participant's prepared txn
function exit_participant_after_prepare_from_table
{
    echo "exit_participant_after_prepare_from_table"
    typeset failed=0
    typeset master=$(find_tertiary_master)
    typeset coordinator_master=$(find_master)
    $CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $master "put tunable debug_exit_participant_after_prepare '1'"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $coordinator_master "put tunable disttxn_linger '0'"

    startms=$(timems)

    echo "Killing and restarting $TERTIARY_DBNAME in the background"
    kill_restart_cluster $TERTIARY_DBNAME "$TERTIARY_CDB2_OPTIONS" $TERTIARY_DBDIR 5 noskip &
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    endms=$(timems)

    if [[ "$r" != "0" ]] ; then 
        echo "Participant did not recover transaction rcode=$r"
        failed=1
    fi

    echo "sleeping for 60 seconds for cluster to restart and for orphaned prepare to resolve"
    sleep 60

    echo "Reset linger-time to 10 seconds"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $coordinator_master "put tunable disttxn_linger '10'"

    echo "Find $TERTIARY_DBNAME master"

    master=""
    while [[ -z "$master" ]]; do
        sleep 1
        master=$(find_tertiary_master)
    done

    echo "Update all tunables"
    update_all_tunables

    echo "Allowing coordinator on all nodes"
    allow_coordinator

    echo "Verify record is there"

    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $SECONDARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME --host $master "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $TERTIARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $QUATERNARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $QUINARY_DBNAME"

    [[ "$failed" != 0 ]] && fail_exit "Bad rcode $r from original transaction"

    delete_records
}

function exit_participant_after_prepare
{
    echo "exit_participant_after_prepare"
    typeset master=$(find_secondary_master)
    $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $master "put tunable debug_exit_participant_after_prepare '1'"

    startms=$(timems)
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    endms=$(timems)

    if [[ "$r" != "0" ]] ; then 
        #stop_all_databases
        echo "participant did not recover transaction rcode=$r"
    fi

    echo "verify we can contact secondary db"
    r=1
    while [[ "$r" -ne "0" ]]; do
        $CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select 1"
        r=$?
        [[ "$r" -ne 0 ]] && sleep 1
    done

    echo "sleeping for 10 seconds for sanity"
    sleep 10

    echo "Verify record is there"

    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $SECONDARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $TERTIARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $QUATERNARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select * from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $QUINARY_DBNAME"

    echo "Restart $SECONDARY_DBNAME on $master"
    pushd $SECONDARY_DBDIR
    export LOGDIR=$TESTDIR/logs
    if [ $master == `hostname` ] ; then
        PARAMS="--no-global-lrl --lrl $SECONDARY_DBDIR/${SECONDARY_DBNAME}.lrl --pidfile ${TMPDIR}/${SECONDARY_DBNAME}.${master}.pid"
        $COMDB2_EXE ${SECONDARY_DBNAME} ${PARAMS} &> $LOGDIR/${SECONDARY_DBNAME}.${master}.db.1 &
    else
        PARAMS="--no-global-lrl --lrl $SECONDARY_DBDIR/${SECONDARY_DBNAME}.lrl --pidfile ${TMPDIR}/${SECONDARY_DBNAME}.${master}.pid"
        CMD="cd ${SECONDARY_DBDIR}; source ${REP_ENV_VARS} ; $COMDB2_EXE ${SECONDARY_DBNAME} ${PARAMS} 2>&1 | tee $TESTDIR/${SECONDARY_DBNAME}.${master}.db.1"
        ssh -n -o StrictHostKeyChecking=no -tt $master ${CMD} &> $LOGDIR/${SECONDARY_DBNAME}.${master}.db.1 &
        echo $! > ${TMPDIR}/${SECONDARY_DBNAME}.${master}.pid
    fi
    popd

    echo "Pause until it comes up"
    r=-1
    while [[ "$r" -ne "0" ]]; do
        $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME --host $master "select 1"
        r=$?
        sleep 1
    done

    echo "Refreshing all tunables"
    update_all_tunables

    echo "Allowing coordinator on all nodes"
    allow_coordinator

    delete_records
}

function non_durable_prepare_int
{
    echo "non_durable_prepare"
    typeset master=$(find_quaternary_master)

    kill_restart_cluster $QUATERNARY_DBNAME "$QUATERNARY_CDB2_OPTIONS" $QUATERNARY_DBDIR 0 $master &

    output=$(echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1)
    r=$?

    
    [[ "$r" == 0 ]] && fail_exit "Succeeded incorrectly on non-durable prepare record"

    if [[ "$output" != *"Prepare was not durable"* ]]; then
        fail_exit "Expected prepare-was-not-durable rcode"
    fi

    for node in $CLUSTER; do
        r=-1
        while [[ "$r" -ne "0" ]]; do
            $CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME --host $node "select 1"
            r=$?
            sleep 1
        done
    done

    echo "updating all tunables"
    update_all_tunables

    echo "allowing coordinator on all nodes"
    allow_coordinator
}

function non_durable_prepare
{
    toggle_debug_sleep_before_prepare 1
    non_durable_prepare_int
    toggle_debug_sleep_before_prepare 0
}

function timed_insert
{
    typeset val=$1
    startms=$(timems)
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1(a) values($val)"
    r=$?
    endms=$(timems)
    echo "Insert $val took $(( endms -  startms )) ms, rcode=$r"
}

function sleep_insert
{
    typeset sleeptime=$1
    echo "sleep_insert"
    sleep $sleeptime
    timed_insert 2 &
    timed_insert 3 &
    timed_insert 4 &
    timed_insert 5 &
    timed_insert 6 &
    timed_insert 7 &
    timed_insert 8 &
    timed_insert 9 &
    timed_insert 10 &
}

function non_durable_commit_int
{
    echo "non_durable_commit"
    typeset master=$(find_master)
    typeset newmaster=""

    kill_restart_cluster $DBNAME "$CDB2_OPTIONS" $DBDIR 20 $master &

    sleep_insert 1 &
    startms=$(timems)
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    endms=$(timems)
    echo "Coordinator took $(( endms - startms )) ms to complete txn with rcode $r"

    [[ "$r" == 0 ]] && fail_exit "Should have exited when replicant was aborted"

    # Look at lock-table to make sure inserts are blocked on prepare
    x=$($CDB2SQL_EXE --tabs --admin $CDB2_OPTIONS $DBNAME --host $master "select count(*) from comdb2_locks where locktype='PAGE' and status='WAIT'")

    [[ "$x" == 0 ]] && fail_exit "Inserts are not blocked on prepare"

    # Sleep for a bit to make sure other nodes have exited
    sleep 4

    # Toggle set-readonly to 0 now for sane downgrade / election times
    toggle_debug_sleep_on_set_read_only 0

    # Sleep for a while to let nodes come back up
    sleep 30

    # Do a select, but this might take a while

    for node in $CLUSTER; do
        r=-1
        while [[ "$r" -ne "0" ]]; do
            $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $node "select 1"
            r=$?
            sleep 1
        done
    done

    echo "Refreshing all tunables"
    update_all_tunables

    echo "Allowing coordinator on all nodes"
    allow_coordinator

    sleep 1
    newmaster=$(find_master)

    # Okay this one is tricky.. going to sniff for trace to verify that
    # we've hit the conditions we are looking for:

    # 1
    # The distrbuted-commit didn't replicate to a quorum on original master.  
    # First, verify that bdb_block_durable polled for a few seconds waiting 
    # for this to occur before finally returning LOCK_DESIRED when the master
    # wants to downgrade.
    #
    # I've seen the database not emit this trace even though it is working 
    # correctly.  I think this is because the bdb-lock is already desired 
    # by the time it reaches this line of code.  I've increased the debug-
    # sleep-on-set-read-only timer to 6 seconds, to make this more reliable.

    x=$(egrep "bdb_block_durable waiting for lsn" $TESTDIR/logs/${DBNAME}.${master}.db 2>&1)
    cnt=$(echo "$x" | wc -l)
    echo "$x"

    [[ "$cnt" -le "1" ]] && fail_exit "Coordinator master didn't block on non-durable commit"

    echo "Coordinator correctly blocked on non-durable commit"

    # 2
    # Coordinator failed to commit durably because 'lock-is-desired' ..
    # search for this trace
    x=$(egrep "failed to commit durably" $TESTDIR/logs/${DBNAME}.${master}.db 2>&1)
    echo "$x"
    [[ -z "$x" ]] && fail_exit "Coordinator master didn't fail to commit durably"

    # 3
    # We should see the coordinator master aborting the blocked inserts
    x=$(egrep "abort waiter with lock" $TESTDIR/logs/${DBNAME}.${master}.db 2>&1)
    echo "$x"
    [[ -z "$x" ]] && fail_exit "Coordinator master didn't abort waiters"

    # 4
    # Coordinator master should have 'discarded' the prepared txn
    x=$(egrep "toblock_main_int disttxn discarding prepared txn" $TESTDIR/logs/${DBNAME}.${master}.db 2>&1)
    echo "$x"
    [[ -z "$x" ]] && fail_exit "Coordinator master never discarded txn"

    # 5
    # Make sure that the participants eventually receive an 'HAS_COMMITTED' or 'HAS_ABORTED' message 
    # from the new master.  If we miss one, it implies that the old master told them to commit even 
    # though the commit record was not written to a quorum
    shouldsee=1
    x=$(egrep "transaction_has_committed from " $TESTDIR/logs/${DBNAME}.${newmaster}.db | egrep "HAS_COMMITTED" 2>&1)
    if [[ -z "$x" ]]; then
        x=$(egrep "transaction_has_committed from " $TESTDIR/logs/${DBNAME}.${newmaster}.db | egrep "HAS_ABORTED" 2>&1)
        shouldsee=0
    fi
    echo "$x"
    [[ -z "$x" ]] && fail_exit "Transaction not resolved"

    [[ "$x" != *"$SECONDARY_DBNAME"* ]] && fail_exit "$SECONDARY_DBNAME could have committed on original master"
    [[ "$x" != *"$TERTIARY_DBNAME"* ]] && fail_exit "$TERTIARY_DBNAME could have committed on original master"
    [[ "$x" != *"$QUATERNARY_DBNAME"* ]] && fail_exit "$QUATERNARY_DBNAME could have committed on original master"
    [[ "$x" != *"$QUINARY_DBNAME"* ]] && fail_exit "$QUINARY_DBNAME could have committed on original master"

    if [[ "$shouldsee" == 1 ]]; then

        x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1 where a=1")
        [[ "$x" -ne "1" ]] && fail_exit "No record on $DBNAME for successful commit"

        x=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select count(*) from t1")
        [[ "$x" -ne "1" ]] && fail_exit "No record on $SECONDARY_DBNAME for successful commit"

        x=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select count(*) from t1")
        [[ "$x" -ne "1" ]] && fail_exit "No record on $TERTIARY_DBNAME for successful commit"

        x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select count(*) from t1")
        [[ "$x" -ne "1" ]] && fail_exit "No record on $QUATERNARY_DBNAME for successful commit"

        x=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select count(*) from t1")
        [[ "$x" -ne "1" ]] && fail_exit "No record on $QUINARY_DBNAME for successful commit"

    else

        x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1 where a=1")
        [[ "$x" -ne "0" ]] && fail_exit "Found record on $DBNAME for aborted transaction"

        x=$($CDB2SQL_EXE -tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select count(*) from t1")
        [[ "$x" -ne "0" ]] && fail_exit "Found record on $SECONDARY_DBNAME for aborted transaction"

        x=$($CDB2SQL_EXE -tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select count(*) from t1")
        [[ "$x" -ne "0" ]] && fail_exit "Found record on $TERTIARY_DBNAME for aborted transaction"

        x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select count(*) from t1")
        [[ "$x" -ne "0" ]] && fail_exit "Found record on $QUATERNARY_DBNAME for aborted transaction"

        x=$($CDB2SQL_EXE -tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select count(*) from t1")
        [[ "$x" -ne "0" ]] && fail_exit "Found record on $QUINARY_DBNAME for aborted transaction"

    fi

    echo "Deleting all records"
    delete_records_ignore_error
}

function non_durable_commit
{
    toggle_debug_sleep_coordinator_before_commit 1
    toggle_debug_sleep_on_set_read_only 1
    non_durable_commit_int
    toggle_debug_sleep_coordinator_before_commit 0
    toggle_debug_sleep_on_set_read_only 0
}

function non_durable_loop
{
    typeset i=0
    while [[ "$i" -lt "2" ]]; do 
        let i=i+1
        echo "non-durable-loop iteration $i"
        non_durable_commit
        non_durable_prepare
    done
}

function coordinator_whitelist
{
    echo "coordinator_whitelist"

    forbid_coordinator
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
     r=$?
     [[ "$r" == "0" ]] && fail_exit "2pc txn worked against forbidden coordinator $SECONDARY_DBNAME"

    send_message_cluster "allow-coordinator $DBNAME/prod" "$SECONDARY_DBNAME" "$SECONDARY_CDB2_OPTIONS"

    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
     r=$?
     [[ "$r" != "0" ]] && fail_exit "2pc txn failed against allowed coordinator $SECONDARY_DBNAME"

    echo "begin
delete from t1 where 1
delete from $SECONDARY_DBNAME.t1 where 1
insert into $TERTIARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
     r=$?
     [[ "$r" == "0" ]] && fail_exit "2pc txn failed against forbidden coordinator $TERTIARY_DBNAME"

    send_message_cluster "allow-coordinator $DBNAME/prod" "$TERTIARY_DBNAME" "$TERTIARY_CDB2_OPTIONS"

    echo "begin
delete from t1 where 1
delete from $SECONDARY_DBNAME.t1 where 1
insert into $TERTIARY_DBNAME.t1(a) values (1)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
     r=$?
     [[ "$r" != "0" ]] && fail_exit "2pc txn failed against allowed coordinator $TERTIARY_DBNAME"

    echo "Allow $SECONDARY_DBNAME and $DBNAME to act as coordinator"
    send_message_cluster "allow-coordinator $SECONDARY_DBNAME/prod $DBNAME/prod" "$QUATERNARY_DBNAME" "$QUATERNARY_CDB2_OPTIONS"

    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values (1)
delete from $TERTIARY_DBNAME.t1 where 1
insert into $QUATERNARY_DBNAME.t1(a) values (1)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
    r=$?
    [[ "$r" != "0" ]] && fail_exit "2pc txn failed against allowed coordinator $QUATERNARY_DBNAME"

    x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default 'exec procedure sys.cmd.send("show-allowed-coordinators")' 2>&1)

    echo "allowed-coordinators: $x"
    if [[ "$x" != *"$SECONDARY_DBNAME/prod"* ]]; then
        fail_exit "Couldn't find $SECONDARY_DBNAME in allowed-coordinator list"
    fi
    if [[ "$x" != *"$DBNAME/prod"* ]]; then
        fail_exit "Couldn't find $DBNAME in allowed-coordinator list"
    fi

    send_message_cluster "forbid-coordinator $SECONDARY_DBNAME/prod" "$QUATERNARY_DBNAME" "$QUATERNARY_CDB2_OPTIONS"

    x=$($CDB2SQL_EXE -tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default 'exec procedure sys.cmd.send("show-allowed-coordinators")' 2>&1)
    echo "allowed-coordinators: $x"

    echo "allowed-coordinators: $x"
    [[ "$x" == *"$SECONDARY_DBNAME/prod"* ]] && fail_exit "$SECONDARY_DBNAME/prod is still an allowed coordinator for $QUATERNARY_DBNAME"
    if [[ "$x" == *"$SECONDARY_DBNAME/prod"* ]]; then
        fail_exit "Found $SECONDARY_DBNAME in allowed-coordinators list"
    fi
    if [[ "$x" != *"$DBNAME/prod"* ]]; then
        fail_exit "Couldn't find $DBNAME in allowed-coordinator list"
    fi

    allow_coordinator
    delete_records
}

function coordinator_whitelist_loop
{
    echo "coordinator_whitelist_loop"
    j=0
    while [[ $j -lt 10 ]]; do
        coordinator_whitelist
        let j=j+1
    done
}

function exit_coordinator_before_commit
{
    echo "exit_coordinator_before_commit"
    typeset master=$(find_master)
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "put tunable debug_exit_coordinator_before_commit '1'"

    startms=$(timems)
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    endms=$(timems)

    echo "sleeping for 30 seconds for sanity"
    sleep 30

    echo "Verify record is not there"

    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && fail_exit "Uncommitted record in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && fail_exit "Uncommitted record in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && fail_exit "Uncommitted record in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && fail_exit "Uncommitted record in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "0" ]] && fail_exit "Uncommitted record in $DBNAME"

    echo "Restart $DBNAME on $master"
    pushd $DBDIR
    export LOGDIR=$TESTDIR/logs
    REP_ENV_VARS="${DBDIR}/replicant_env_vars"
    if [ $master == `hostname` ] ; then
        PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${master}.pid"
        $COMDB2_EXE ${DBNAME} ${PARAMS} &> $LOGDIR/${DBNAME}.${master}.db.1 &
    else
        PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${master}.pid"
        CMD="cd ${DBDIR}; source ${REP_ENV_VARS} ; $COMDB2_EXE ${DBNAME} ${PARAMS} 2>&1 | tee $TESTDIR/${DBNAME}.${master}.db.1"
        ssh -n -o StrictHostKeyChecking=no -tt $master ${CMD} &> $LOGDIR/${DBNAME}.${master}.db.1 &
        echo $! > ${TMPDIR}/${DBNAME}.${master}.pid
    fi
    popd

    echo "Pause until it comes up"
    r=-1
    while [[ "$r" -ne "0" ]]; do
        $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "select 1"
        r=$?
        sleep 1
    done

    echo "Refreshing all tunables"
    update_all_tunables

    echo "Allowing coordinator on all nodes"
    allow_coordinator

    delete_records_ignore_error
}

function exit_coordinator_after_commit
{
    echo "exit_coordinator_after_commit"
    typeset master=$(find_master)

    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "put tunable debug_exit_coordinator_after_commit '1'"

    startms=$(timems)
    echo "begin
insert into t1(a) values(1)
insert into $SECONDARY_DBNAME.t1(a) values(1)
insert into $TERTIARY_DBNAME.t1(a) values(1)
insert into $QUATERNARY_DBNAME.t1(a) values(1)
insert into $QUINARY_DBNAME.t1(a) values(1)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default - 2>&1
    r=$?
    endms=$(timems)

    echo "sleeping for 30 seconds for sanity"
    sleep 30

    echo "Verify record is there"

    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $DBNAME"

    x=$($CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $SECONDARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $TERTIARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $QUATERNARY_DBNAME"

    x=$($CDB2SQL_EXE --tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select count(*) from t1")
    [[ "$x" != "1" ]] && fail_exit "Record not in $QUINARY_DBNAME"

    echo "Restart $DBNAME on $master"
    pushd $DBDIR
    export LOGDIR=$TESTDIR/logs
    REP_ENV_VARS="${DBDIR}/replicant_env_vars"
    if [ $master == `hostname` ] ; then
        PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${master}.pid"
        $COMDB2_EXE ${DBNAME} ${PARAMS} &> $LOGDIR/${DBNAME}.${master}.db.1 &
    else
        PARAMS="--no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.${master}.pid"
        CMD="cd ${DBDIR}; source ${REP_ENV_VARS} ; $COMDB2_EXE ${DBNAME} ${PARAMS} 2>&1 | tee $TESTDIR/${DBNAME}.${master}.db.1"
        ssh -n -o StrictHostKeyChecking=no -tt $master ${CMD} &> $LOGDIR/${DBNAME}.${master}.db.1 &
        echo $! > ${TMPDIR}/${DBNAME}.${master}.pid
    fi
    popd

    echo "Pause until it comes up"
    r=-1
    while [[ "$r" -ne "0" ]]; do
        $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "select 1"
        r=$?
        sleep 1
    done

    echo "Refreshing all tunables"
    update_all_tunables

    echo "Allowing coordinator on all nodes"
    allow_coordinator

    delete_records_ignore_error
}

function random_verify_coordinator_constraint_violation
{
    toggle_random_verify_errors 1
    toggle_debug_wait_on_verify_off 1
    coordinator_constraint_violation
    toggle_random_verify_errors 0
    toggle_debug_wait_on_verify_off 0
}

function random_verify_participant_constraint_violation
{
    toggle_random_verify_errors 1
    toggle_debug_wait_on_verify_off 1
    participant_constraint_violation
    toggle_random_verify_errors 0
    toggle_debug_wait_on_verify_off 0
}

function test_simple_distributed_deadlocks
{
    typeset cnt=0
    # On my machine i/o becomes SLOW after a while .. seeing 500ms log-flushes .. 
    toggle_verify_retry_max 1
    toggle_debug_coordinator_dispatch_failure 1
    while [[ "$cnt" -lt 10 ]]; do 
        let cnt=cnt+1
        echo "Test distributed-deadlocks simple iteration $cnt"
        distributed_deadlocks_simple
    done
    toggle_verify_retry_max 499
    toggle_debug_coordinator_dispatch_failure 0
}

function insert_secondary_tertiary_dist
{
    typeset val=$1
    typeset startms=$(timems)
    # The txn going to tertiary_dbname will sleep before dispatching
    echo "begin
insert into $SECONDARY_DBNAME.d2(a) values($val)
insert into $TERTIARY_DBNAME.d1(a) values($val)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
    typeset endms=$(timems)
    echo "insert_secondary_tertiary_dist took $(( endms - startms )) ms"
}

function insert_secondary_tertiary_dist_reverse
{
    typeset val=$1
    typeset startms=$(timems)
    echo "begin
insert into $SECONDARY_DBNAME.d1(a) values($val)
insert into $TERTIARY_DBNAME.d2(a) values($val)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $CDB2_OPTIONS $DBNAME default -
    typeset endms=$(timems)
    echo "insert_secondary_tertiary_dist_reverse took $(( endms - startms )) ms"
}

function insert_into_secondary_d1_d2
{
    typeset val=$1
    typeset startms=$(timems)
    echo "begin
insert into d1(a) values($val)
insert into d2(a) values($val)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default -
    typeset endms=$(timems)
    echo "insert_into_secondary_d1_d2 took $(( endms - startms )) ms"
}

function insert_into_tertiary_d1_d2
{
    typeset val=$1
    typeset startms=$(timems)
    echo "begin
insert into d1(a) values($val)
insert into d2(a) values($val)
commit
" | $CDB2SQL_EXE $DEBUGTRACE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default -
    typeset endms=$(timems)
    echo "insert_into_tertiary_d1_d2 took $(( endms - startms )) ms"
}

# Proof that distributed deadlocks are possible without revised deadlock-detection
#
# Participant-A
# dist-txn2 blocks on a lock held by a normal-txn, but that normal-txn is blocked on
# a lock held by dist-txn1 which has successfully prepared.
#
# Participant-B 
# dist-txn1 blocks on a lock held by a normal-txn, but that normal-txn is blocked on
# a lock held by dist-txn2 which has successfully prepared.
#
# The interleaved normal-transaction prevents old code from detecting this. New deadlock
# detection code evaluates all of the dependencies of each lockid- it catches this case
#
# This test uses 'sleep-before-dispatching-any-distxn' in sltdbt.c:
#
# Set sleep-before-dispatch on participant-B
# In background, spawn distributed txn-1 that inserts into participant-B and participant-A
# Sleep 1 to make sure participant-A has prepared
# In background, insert another record to participant-A (which should block)
# Unset 'sleep-before-dispatch' on participant-B
# In background, spawn distributed txn-2 that inserts into participant-B and participant-A
# Because the 'sleep-before-dispatch' is unset, this should be immediately prepared on participant-B
# In background, insert another record to participant-B (which should block)
# Sleep until the original sleep-before-dispatch is exhaused
#
# Bingo! Deadlock .. 

function test_hand_crafted_distributed_deadlocks
{
    echo "test_hand_crafted_distributed_deadlocks"

    echo "Sleep for 10 before dispatching tertiary"
    set_sleep_before_dispatch_tertiary 10

    echo "Dispatch dist-txn-1"
    insert_secondary_tertiary_dist 1 &

    echo "Sleep for 1"
    sleep 1

    echo "Dispatch normal txn to secondary"
    insert_into_secondary_d1_d2 2 &

    echo "Undo set sleep on tertiary"
    set_sleep_before_dispatch_tertiary 0

    echo "Dispatch dist-txn-2"
    insert_secondary_tertiary_dist_reverse 3 &

    echo "Sleep for 1"
    sleep 1

    echo "Dispatch normal txn to tertiary"
    insert_into_tertiary_d1_d2 4 &

    echo "About to wait, if this reproduced deadlock this should never return"
    typeset startms=$(timems)
    wait
    typeset endms=$(timems)
    echo "test_hand_crafted_distributed_deadlocks took $(( endms - startms )) ms"

    delete_records_ignore_error
}

# This doesn't reproduce compound distributed deadlocks
function distributed_deadlocks_compound_try1
{
    # Distributed deadlocks are verify-retried: turn this off to keep insert time low
    # A 'failed dispatch' unearthed a bug- I've tunablized random 'failed dispatches'
    toggle_verify_retry_max 1
    toggle_debug_coordinator_dispatch_failure 1
    distributed_deadlocks_compound_try1_int
    toggle_verify_retry_max 499
    toggle_debug_coordinator_dispatch_failure 0
}

# Trying again .. will limit updates to 2 dbs at a time
function distributed_deadlocks_compound
{
    toggle_verify_retry_max 1
    toggle_debug_coordinator_dispatch_failure 1
    distributed_deadlocks_compound_int
    toggle_verify_retry_max 499
    toggle_debug_coordinator_dispatch_failure 0
}

function update_same_record_work
{
    typeset instance=${1:-0}
    typeset coord=$(( RANDOM % 5 ))
    typeset dbname=""
    typeset opts=""

    case $coord in
        0) 
            dbname=$DBNAME
            opts=$CDB2_OPTIONS
            ;;
        1) 
            dbname=$SECONDARY_DBNAME
            opts=$SECONDARY_CDB2_OPTIONS
            ;;
        2) 
            dbname=$TERTIARY_DBNAME
            opts=$TERTIARY_CDB2_OPTIONS
            ;;
        3) 
            dbname=$QUATERNARY_DBNAME
            opts=$QUATERNARY_CDB2_OPTIONS
            ;;
        4) 
            dbname=$QUINARY_DBNAME
            opts=$QUINARY_CDB2_OPTIONS
            ;;
    esac

    echo "> instance$instance start"
    startms=$(timems)
echo "begin
update $DBNAME.t1 set a = a + 1
update $SECONDARY_DBNAME.t1 set a = a + 1
update $TERTIARY_DBNAME.t1 set a = a + 1
update $QUATERNARY_DBNAME.t1 set a = a + 1
update $QUINARY_DBNAME.t1 set a = a + 1
update $DBNAME.t2 set a = a + 1
update $SECONDARY_DBNAME.t2 set a = a + 1
update $TERTIARY_DBNAME.t2 set a = a + 1
update $QUATERNARY_DBNAME.t2 set a = a + 1
update $QUINARY_DBNAME.t2 set a = a + 1
update $DBNAME.t3 set a = a + 1
update $SECONDARY_DBNAME.t3 set a = a + 1
update $TERTIARY_DBNAME.t3 set a = a + 1
update $QUATERNARY_DBNAME.t3 set a = a + 1
update $QUINARY_DBNAME.t3 set a = a + 1
update $DBNAME.t4 set a = a + 1
update $SECONDARY_DBNAME.t4 set a = a + 1
update $TERTIARY_DBNAME.t4 set a = a + 1
update $QUATERNARY_DBNAME.t4 set a = a + 1
update $QUINARY_DBNAME.t4 set a = a + 1
update $DBNAME.d1 set a = a + 1
update $SECONDARY_DBNAME.d1 set a = a + 1
update $TERTIARY_DBNAME.d1 set a = a + 1
update $QUATERNARY_DBNAME.d1 set a = a + 1
update $QUINARY_DBNAME.d1 set a = a + 1
update $DBNAME.d2 set a = a + 1
update $SECONDARY_DBNAME.d2 set a = a + 1
update $TERTIARY_DBNAME.d2 set a = a + 1
update $QUATERNARY_DBNAME.d2 set a = a + 1
update $QUINARY_DBNAME.d2 set a = a + 1
commit" | $CDB2SQL_EXE $opts $dbname default -
    r=$?
    donems=$(timems)
    echo "> instance$instance done"
    elapsed=$(( donems - startms ))
    echo "> instance $instance single-record update time $elapsed rcode=$r"
    if [[ "$elapsed" -gt "$LONGUPDATETIME" ]]; then
        fail_exit "> instance $instance took very long time to update"
    fi
    if [[ "$r" == "0" ]]; then
        echo "good"
    else
        echo "bad"
    fi
}

function update_same_record_thread
{
    typeset iters=${1:-10000}
    typeset vr=${2:-499}
    typeset instance=${3:-0}
    j=0
    good=0
    bad=0
    startms=$(timems)
    while [[ "$j" -lt "$iters" && ! -f $stopfile ]] ; do
        x=$(update_same_record_work $instance)
        echo "$x"
        if [[ "$x" == *"good"* ]]; then
            let good=good+1
        else
            let bad=bad+1
        fi
        let j=j+1
    done
    donems=$(timems)
    elapsed=$(( donems - startms ))
    echo "= Instance $instance update-same-record thread complete, $good good, $bad bad elapsed-time=$elapsed verify-retrys set to $vr"
}

function check_same
{
    typeset tbl=$1
    primary=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select * from $tbl order by a")
    secondary=$($CDB2SQL_EXE --tabs $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "select * from $tbl order by a")
    tertiary=$($CDB2SQL_EXE --tabs $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "select * from $tbl order by a")
    quaternary=$($CDB2SQL_EXE --tabs $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "select * from $tbl order by a")
    quinary=$($CDB2SQL_EXE --tabs $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "select * from $tbl order by a")

    [[ "$secondary" != "$primary" ]] && fail_exit "Secondary dataset doesnt match"
    [[ "$tertiary" != "$primary" ]] && fail_exit "Tertiary dataset doesnt match"
    [[ "$quaternary" != "$primary" ]] && fail_exit "Quaternary dataset doesnt match"
    [[ "$quinary" != "$primary" ]] && fail_exit "Quinary dataset doesnt match"

    echo "$primary"
}

function update_same_records_int
{
    typeset iters=${1:-10000}
    typeset thds=${2:-10}
    typeset recordcount=${3:-1}
    typeset vr=${4:-499}

    delete_records_ignore_error
    j=0
    while [[ "$j" -lt "$recordcount" && ! -f $stopfile ]]; do
echo "begin
insert into t1(a) values($j)
insert into $SECONDARY_DBNAME.t1(a) values($j)
insert into $TERTIARY_DBNAME.t1(a) values($j)
insert into $QUATERNARY_DBNAME.t1(a) values($j)
insert into $QUINARY_DBNAME.t1(a) values($j)
insert into t2(a) values($j)
insert into $SECONDARY_DBNAME.t2(a) values($j)
insert into $TERTIARY_DBNAME.t2(a) values($j)
insert into $QUATERNARY_DBNAME.t2(a) values($j)
insert into $QUINARY_DBNAME.t2(a) values($j)
insert into t3(a) values($j)
insert into $SECONDARY_DBNAME.t3(a) values($j)
insert into $TERTIARY_DBNAME.t3(a) values($j)
insert into $QUATERNARY_DBNAME.t3(a) values($j)
insert into $QUINARY_DBNAME.t3(a) values($j)
insert into t4(a) values($j)
insert into $SECONDARY_DBNAME.t4(a) values($j)
insert into $TERTIARY_DBNAME.t4(a) values($j)
insert into $QUATERNARY_DBNAME.t4(a) values($j)
insert into $QUINARY_DBNAME.t4(a) values($j)
insert into d1(a) values($j)
insert into $SECONDARY_DBNAME.d1(a) values($j)
insert into $TERTIARY_DBNAME.d1(a) values($j)
insert into $QUATERNARY_DBNAME.d1(a) values($j)
insert into $QUINARY_DBNAME.d1(a) values($j)
insert into d2(a) values($j)
insert into $SECONDARY_DBNAME.d2(a) values($j)
insert into $TERTIARY_DBNAME.d2(a) values($j)
insert into $QUATERNARY_DBNAME.d2(a) values($j)
insert into $QUINARY_DBNAME.d2(a) values($j)
commit" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" == "0" ]] || fail_exit "failed setting up test"
        let j=j+1
    done
    j=0
    while [[ "$j" -lt "$thds" ]]; do
        update_same_record_thread $iters $vr $j &
        let j=j+1
    done
    wait

    t1=$(check_same t1)
    t2=$(check_same t2)
    t3=$(check_same t3)
    t4=$(check_same t4)
    d1=$(check_same d1)
    d2=$(check_same d2)

    [[ "$t1" != "$t2" ]] && fail_exit "t2 dataset doesnt match"
    [[ "$t1" != "$t3" ]] && fail_exit "t3 dataset doesnt match"
    [[ "$t1" != "$t4" ]] && fail_exit "t4 dataset doesnt match"
    [[ "$t1" != "$d1" ]] && fail_exit "d1 dataset doesnt match"
    [[ "$t1" != "$d2" ]] && fail_exit "d2 dataset doesnt match"

    if [[ ! -f $stopfile ]] ; then
        delete_records_ignore_error
    fi
}

function update_same_records
{
    typeset iters=${1:-1000}
    typeset thds=${2:-10}
    typeset recordcount=${3:-1}
    typeset vrmax=${4:-1}
    toggle_verify_retry_max $vrmax
    update_same_records_int $iters $thds $recordcount $vrmax
    toggle_verify_retry_max 499
}

function test_update_same_records
{
    typeset cnt=0
    typeset vr=0
    rm $stopfile >/dev/null 2>&1
    while [[ "$cnt" -lt "8" && ! -f $stopfile ]]; do 
        let cnt=cnt+1
        echo "Test update-same-record iteration $cnt"
        update_same_records 100 10 10 $vr
        if [[ "$vr" == "0" ]]; then
            let vr=1
        else
            let vr=vr*2
        fi
    done
}

# This reproduced 'compound' distributed deadlock
# See description in test_hand_crafted_distributed_deadlocks
function test_compound_distributed_deadlocks
{
    typeset cnt=0
    while [[ "$cnt" -lt 2 ]]; do 
        let cnt=cnt+1
        echo "Test distributed-deadlocks compound iteration $cnt"
        distributed_deadlocks_compound
    done
}

# This never reproduced compound-distributed deadlock
function test_compound_distributed_deadlocks_try1
{
    typeset cnt=0
    while [[ "$cnt" -lt 1 ]]; do 
        let cnt=cnt+1
        echo "Test distributed-deadlocks compound iteration $cnt"
        distributed_deadlocks_compound_try1
    done
}

function test_deadlocks
{
    typeset cnt=0
    while [[ "$cnt" -lt 1 ]]; do 
        let cnt=cnt+1
        echo "Test deadlocks iteration $cnt"
        random_deadlocks
    done
}

function test_verify_retry
{
    typeset cnt=0
    while [[ "$cnt" -lt 10 ]]; do 
        let cnt=cnt+1
        echo "Test verify-errors iteration $cnt"
        random_verify_errors
    done
}

function test_verify_participant_constraint_violation
{
    typeset cnt=0
    while [[ "$cnt" -lt 2 ]]; do 
        let cnt=cnt+1
        echo "Test participant-constraint-violation-verify-errors iteration $cnt"
        random_verify_participant_constraint_violation
    done
}

function test_verify_coordinator_constraint_violation
{
    typeset cnt=0
    while [[ "$cnt" -lt 2 ]]; do 
        let cnt=cnt+1
        echo "Test participant-constraint-violation-verify-errors iteration $cnt"
        random_verify_coordinator_constraint_violation
    done
}

function verify_retry_loop
{
    typeset cnt=0
    while [[ "$cnt" -lt 3 ]]; do 
        let cnt=cnt+1
        echo "verify-retry-loop iteration $cnt"
        test_verify_participant_constraint_violation
        test_verify_coordinator_constraint_violation
    done
}

# This breaks if machine is overloaded- but its not a 2pc error
function simple_test
{
    typeset cnt=0
    while [[ "$cnt" -lt 1 ]]; do 
        let cnt=cnt+1
        echo "Test loop iteration $cnt"
        bulk_test 1
        insert_records_to_normalize
        basic_test 1
    done
}

function insert_2000
{
    echo "insert_2000"
    echo "begin
insert into t1(a) select * from generate_series(1, 2000)
insert into $SECONDARY_DBNAME.t1(a) select * from generate_series(1, 2000)
insert into $TERTIARY_DBNAME.t1(a) select * from generate_series(1, 2000)
insert into $QUATERNARY_DBNAME.t1(a) select * from generate_series(1, 2000)
insert into $QUINARY_DBNAME.t1(a) select * from generate_series(1, 2000)
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
    r=$?
    [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"


    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    if [[ "$x" -ne "2000" ]]; then
        fail_exit "$DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $SECONDARY_DBNAME.t1")
    if [[ "$x" -ne "2000" ]]; then
        fail_exit "$SECONDARY_DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $TERTIARY_DBNAME.t1")
    if [[ "$x" -ne "2000" ]]; then
        fail_exit "$TERTIARY_DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUATERNARY_DBNAME.t1")
    if [[ "$x" -ne "2000" ]]; then
        fail_exit "$QUATERNARY_DBNAME has $x records after delete"
    fi

    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select count(*) from $QUINARY_DBNAME.t1")
    if [[ "$x" -ne "2000" ]]; then
        fail_exit "$QUINARY_DBNAME has $x records after delete"
    fi

    delete_records
}

function insert_2000_loop
{
    typeset j=0
    while [[ $j -lt 10 ]]; do
        let j=j+1
        echo "insert-2000 iteration $j"
        insert_2000
    done
}

function benchmark_delete_all
{
    echo "benchmark_delete_all"

    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "truncate t1"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "truncate t2"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "truncate t3"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "truncate t4"

    $CDB2SQL_EXE $SECONDARY_CDB2_OPTIONS $SECONDARY_DBNAME default "truncate t1"
    $CDB2SQL_EXE $TERTIARY_CDB2_OPTIONS $TERTIARY_DBNAME default "truncate t1"
    $CDB2SQL_EXE $QUATERNARY_CDB2_OPTIONS $QUATERNARY_DBNAME default "truncate t1"
    $CDB2SQL_EXE $QUINARY_CDB2_OPTIONS $QUINARY_DBNAME default "truncate t1"
}

function benchmark_4_tables
{
    typeset count=$1
    typeset iterations=$2
    typeset j=0
    startms=$(timems)
    while [[ $j -lt $iterations ]]; do
        echo "begin
insert into t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into t2(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into t3(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into t4(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"
        let j=j+1
    done
    endms=$(timems)
    echo "benchmark_4_tables records-per-table $count iterations $iterations took $(( endms - startms )) ms"
}

function benchmark_4_participants
{
    typeset count=$1
    typeset iterations=$2
    typeset j=0
    startms=$(timems)
    while [[ $j -lt $iterations ]]; do
        echo "begin
insert into $SECONDARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into $TERTIARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into $QUATERNARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
insert into $QUINARY_DBNAME.t1(a) select * from generate_series($(( ( j * count ) + 1 )), $(( ( j + 1 ) * count )))
commit
" | $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default -
        r=$?
        [[ "$r" == "0" ]] || fail_exit "failed inserting iteration $j"
        let j=j+1
    done
    endms=$(timems)
    echo "benchmark_4_participants records-per-table $count iterations $iterations took $(( endms - startms )) ms"
}

function benchmark_table_internal
{
    typeset iter=100
    benchmark_delete_all
    benchmark_4_tables 1 $iter
    benchmark_4_participants 1 $iter

    benchmark_delete_all
    benchmark_4_tables 10 $iter
    benchmark_4_participants 10 $iter

    benchmark_delete_all
    benchmark_4_tables 100 $iter
    benchmark_4_participants 100 $iter

    benchmark_delete_all
    benchmark_4_tables 1000 $iter
    benchmark_4_participants 1000 $iter

    benchmark_delete_all
    benchmark_4_tables 10000 $iter
    benchmark_4_participants 10000 $iter

    #benchmark_delete_all
    #benchmark_4_tables 100000 $iter
    #benchmark_4_participants 100000 $iter
}

function benchmark_table_comparison_loose
{
    echo "benchmark_table_comparison_loose"
    benchmark_common_tunables
    benchmark_loose_tunables
    benchmark_table_internal
}

function benchmark_table_comparison_austere
{
    echo "benchmark_table_comparison_austere"
    benchmark_common_tunables
    benchmark_austere_tunables
    benchmark_table_internal
}

function announce
{
    typeset text=$1
    echo "$text"
    [[ -z "$FIGLET" ]] || figlet -f banner $text
}

function testcase_preamble
{
    typeset testcase=$1
    announce "Running $testcase"
}

function testcase_finish
{
    typeset testcase=$1
    announce "Finished $testcase"
    if [[ -f "$stopfile" ]]; then
        announce "Failed $testcase"
        cat ${DBNAME}.fail_exit
        while [[ "$keepup_on_failure" == "1" ]]; do
            sleep 1
            cat ${DBNAME}.fail_exit
        done
        exit 1 
    fi
}

function run_test
{
    # Bulk-test
    testcase="bulk_test"
    testcase_preamble $testcase
    bulk_test
    testcase_finish $testcase

    # Last delete was expensive & early-acked, so the first insert will take longer 
    # Write a few records without bound latency- this slowness isn't 2pc related
    testcase="insert_records_to_normalize"
    testcase_preamble $testcase
    insert_records_to_normalize
    testcase_finish $testcase

    # Single-record transactions
    testcase="basic_test"
    testcase_preamble $testcase
    basic_test
    testcase_finish $testcase

    # No coordinator writes
    testcase="no_coordinator_writes"
    testcase_preamble $testcase
    no_coordinator_writes
    testcase_finish $testcase

    testcase="verify_no_distcommit"
    testcase_preamble $testcase
    verify_no_distcommit
    testcase_finish $testcase

    # Writes to comdb2_distributed_transactions
    testcase="allow_write_to_disttxn_table"
    testcase_preamble $testcase
    allow_write_to_disttxn_table
    testcase_finish $testcase

    testcase="forbid_disttxn_write_to_disttxn_table"
    testcase_preamble $testcase
    forbid_disttxn_write_to_disttxn_table
    testcase_finish $testcase

    # Constraint-violations
    testcase="coordinator_constraint_violation"
    testcase_preamble $testcase
    coordinator_constraint_violation
    testcase_finish $testcase

    testcase="participant_constraint_violation"
    testcase_preamble $testcase
    participant_constraint_violation
    testcase_finish $testcase

    # Deadlock test
    testcase="test_deadlocks"
    testcase_preamble $testcase
    test_deadlocks
    testcase_finish $testcase

    # Coordinator whitelist
    testcase="coordinator_whitelist"
    testcase_preamble $testcase
    coordinator_whitelist
    testcase_finish $testcase

    # Durability tests
    testcase="non_durable_commit"
    testcase_preamble $testcase
    non_durable_commit
    testcase_finish $testcase

    testcase="non_durable_prepare"
    testcase_preamble $testcase
    non_durable_prepare
    testcase_finish $testcase

    # Hand-crafted distributed deadlocks (add others later)
    testcase="test_hand_crafted_distributed_deadlocks"
    testcase_preamble $testcase
    test_hand_crafted_distributed_deadlocks
    testcase_finish $testcase

    # Compound distributed deadlocks
    testcase="distributed_deadlocks_compound"
    testcase_preamble $testcase
    test_compound_distributed_deadlocks
    testcase_finish $testcase

    # Verify-retry test
    testcase="test_verify_participant_constraint_violation"
    testcase_preamble $testcase
    test_verify_participant_constraint_violation
    testcase_finish $testcase

    testcase="test_verify_coordinator_constraint_violation"
    testcase_preamble $testcase
    test_verify_coordinator_constraint_violation
    testcase_finish $testcase

    # Participant recovery-tests
    testcase="exit_participant_after_prepare"
    testcase_preamble $testcase
    exit_participant_after_prepare
    testcase_finish $testcase

    testcase="exit_participant_after_prepare_from_table"
    testcase_preamble $testcase
    exit_participant_after_prepare_from_table
    testcase_finish $testcase

    # Coordinator recovery-tests
    testcase="exit_coordinator_before_commit"
    testcase_preamble $testcase
    exit_coordinator_before_commit
    testcase_finish $testcase

    testcase="exit_coordinator_after_commit"
    testcase_preamble $testcase
    exit_coordinator_after_commit
    testcase_finish $testcase
}

function run_some_tests
{
    testcase="no_coordinator_writes"
    testcase_preamble $testcase
    no_coordinator_writes
    testcase_finish $testcase

    testcase="verify_no_distcommit"
    testcase_preamble $testcase
    verify_no_distcommit
    testcase_finish $testcase
}

rm $stopfile >/dev/null 2>&1 
[[ -z "$CLUSTER" ]] && fail_exit "This test requires a 3-node cluster"

setup
#run_some_tests
run_test
stop_all_databases

if [[ -f $stopfile ]]; then
    echo "Testcase failed"
    exit -1
fi

echo "Success"
