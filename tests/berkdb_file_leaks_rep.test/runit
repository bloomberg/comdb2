#!/usr/bin/env bash
bash -n "$0" | exit 1

# This test demonstrates a case where ufid_hash would hold an open
# DB handle to an outdated btree file, after schema change, hence prevent
# the file from being deleted.
#
# 1. send flush
# 2. write to table
# 3. bounce a replicant
#   3.1. replicant will start matching from the LSN in step 1
#   3.2. replicant will run recovery to apply transaction from step 2
#   3.3. ufid-hash will need to open a DB handle on the btree file
# 4. truncate table, this creates new btree file
# 5. delfiles now will create "deleted" file on this replicant;
#    alternatively, if we upgrade master to this replicant and then run delfiles,
#    we'll get "DB_FILEOPEN: Rename or remove while file is open"

source ${TESTSROOTDIR}/tools/cluster_utils.sh

[ -z "${CLUSTER}" ] && { echo "Test requires a cluster"; exit 0; }

dbnm=$1

master=`cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "select host from comdb2_cluster where is_master='Y'"`
replicant=`cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "select comdb2_host()"`
the_other_replicant=`cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "SELECT host FROM comdb2_cluster WHERE host <> '$master' AND host <> '$replicant'"`

cdb2sql ${CDB2_OPTIONS} $dbnm default "CREATE TABLE t1 (i integer, b blob)"
sleep 2 # wait for the checkpoint thread to do its 1st checkpoint
cdb2sql $dbnm --host $master "EXEC PROCEDURE sys.cmd.send('bdb checkpoint')"
sleep 2 # wait for the async checkpoint to finish

cdb2sql ${CDB2_OPTIONS} $dbnm default "TRUNCATE TABLE t1"
cdb2sql $dbnm --host $master "EXEC PROCEDURE sys.cmd.send('bdb checkpoint')"
sleep 2 # wait for the async checkpoint to finish

cdb2sql ${CDB2_OPTIONS} $dbnm default "INSERT INTO t1 VALUES(1, x'CDB2BABE')"
sleep 2

echo "Restarting node $replicant ..."
kill_restart_node $replicant 10 1
cdb2sql $dbnm --host $replicant "SELECT 1"
if [ $? -ne 0 ]; then
    echo 'db not up?' >&2
    exit 1
fi

echo "Restarting the other node $the_other_replicant ..."
kill_restart_node $the_other_replicant 10 1
cdb2sql $dbnm --host $the_other_replicant "SELECT 1"
if [ $? -ne 0 ]; then
    echo 'db not up?' >&2
    exit 1
fi

echo 'Before truncate ...'
cdb2sql $dbnm --host $replicant "EXEC PROCEDURE sys.cmd.send('bdb cachestatall')" | grep -A1 blobs0
cdb2sql $dbnm --host $master "TRUNCATE TABLE t1"
echo 'After truncate ...'
cdb2sql $dbnm --host $replicant "EXEC PROCEDURE sys.cmd.send('bdb cachestatall')" | grep -A1 blobs0

for host in $CLUSTER; do
    echo --- BEGIN WALKBACKS for $host ---
    dbpid=`ssh $host 'pgrep -a comdb2' | grep $dbnm | awk '{print $1}'`
    echo DB pid is $dbpid
    baseaddr=`ssh $host "pmap $dbpid" | grep comdb2$ | head -1 | awk '{printf "0x%s", $1}'`
    cdb2sql ${CDB2_OPTIONS} -s --tabs $dbnm --host $host 'EXEC PROCEDURE sys.cmd.send("bdb dumpopendbs")' | grep XXX.t1 | grep blob
    stacks=`cdb2sql ${CDB2_OPTIONS} -s --tabs $dbnm --host $host 'EXEC PROCEDURE sys.cmd.send("bdb dumpopendbs")' | grep XXX.t1 | grep blob`
    nooffset=$(for n in `echo "$stacks"| awk '{for(i=2; i<=NF; ++i) {print $i}}'`; do printf "0x%x " $(($n-$baseaddr)); done)
    addr2line -fsp -e $COMDB2_EXE $nooffset
    echo --- END WALKBACKS for $host ---
done

cdb2sql -tabs $dbnm --host $master "EXEC PROCEDURE sys.cmd.send('delfiles t1')"

# None of the replicants should have deleted files after master delfiles
for host in $CLUSTER; do
    dbpid=`ssh $host 'pgrep -a comdb2' | grep $dbnm | awk '{print $1}'`
    echo DB pid is $dbpi
    echo '--- BEGIN LSOF (deleted) for $host ---'
    ssh $host "lsof -p $dbpid | grep deleted"
    echo '--- END LSOF (deleted) for $host ---'
    cnt=`ssh $host "lsof -p $dbpid | grep -c deleted"`
    if [ "$cnt" != 0 ]; then
	echo 'Replicant has deleted files! DB handles leaked!' >&2
	exit 1
    fi
done

echo "Success!"
exit 0
