#!/usr/bin/env bash
bash -n "$0" | exit 1

set -e

# Debug variable
debug=0

dbnm=$1

if [ "x$dbnm" == "x" ] ; then
    echo "need a DB name"
    exit 1
fi

# Number of insert_records function calls
nins=0


failexit()
{
    echo "Failed $1"
    exit -1
}

assertcnt ()
{
    target=$1
    cnt=$(cdb2sql --tabs ${CDB2_OPTIONS} $dbnm default "select count(*) from t1")
    if [ $? -ne 0 ] ; then
        echo "assertcnt: select error"
    fi

    #echo "count is now $cnt"
    if [[ $cnt != $target ]] ; then
        failexit "count is now $cnt but should be $target"
    fi
}

echo $CDB2_CONFIG
CNT=10000


echo 'part of a transaction'

echo begin > ins.in
for ((i=1;i<=$CNT;i++)) ; do
    echo "insert into t1 values(guid(), randomblob(16), $i,$i)"
done >> ins.in
echo commit >> ins.in

echo 'same as above but not part of a transaction'

for ((i=1;i<=$CNT;i++)) ; do
    echo "insert into t1 values(guid(), randomblob(16), $i,$((2*i)))"
done >> ins.in

echo 'using cte for kicks and gigles'
echo "INSERT INTO t1 (id,rndm,i,j) WITH i(x) AS ( VALUES(1) UNION ALL SELECT x+1 FROM i where x < $CNT) SELECT guid(), randomblob(16), x,($CNT-x) FROM i" >> ins.in


PARALLEL=20
for ((j=1;j<=$PARALLEL;j++)) ; do
   cdb2sql -f ins.in ${CDB2_OPTIONS} $dbnm default > ins_${j}.out &
done

echo wait for all above background inserts to complete
wait

cdb2sql ${CDB2_OPTIONS} $dbnm 'select * from t1' > content.out
echo 'failure in transactions inserting will mean count will be off'
assertcnt $((CNT*PARALLEL*3))

rm *.out
echo "Success"
