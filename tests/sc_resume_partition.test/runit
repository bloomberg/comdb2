#!/usr/bin/env bash

set -ex
dbnm=$1
tier="local"
CDB2SQL_EXE="cdb2sql"
DBNAME=$dbnm

source ${TESTSROOTDIR}/tools/runit_common.sh
source ${TESTSROOTDIR}/tools/cluster_utils.sh
source util.sh

declare -r CRASH=1
declare -r DOWNGRADE=2

declare -r CREATE=10
declare -r ALTER=11

setup() {
	local -r tbl_name=$1 num_shards=$2 num_records_per_shard=$3 op_for_creating_partitioned_table=$4

	create_table ${tbl_name} ${op_for_creating_table}
	insert_records_into_table ${tbl_name} ${num_shards} ${num_records_per_shard}
}

teardown() {
	local -r tbl_name=$1
	cdb2sql ${CDB2_OPTIONS} ${dbnm} ${tier} "drop table ${tbl_name}"
}

# Tests that the resume of partitioned table merge triggered by a crash or a downgrade completes correctly
test_driver() {
	local -r tbl_name=$1 num_shards=$2 num_records_per_shard=$3 resume_trigger=$4
	local master
	master=`cdb2sql --tabs ${CDB2_OPTIONS} $dbnm ${tier} 'SELECT host FROM comdb2_cluster WHERE is_master="Y"'`

	COMDB2_CONFIG_MIN_RETRIES=0 \
	COMDB2_CONFIG_MAX_RETRIES=0 \
	cdb2sql ${CDB2_OPTIONS} ${dbnm} ${tier} "alter table ${tbl_name} partitioned by none" &
	local -r waitpid=$!
	sleep 5

	#cdb2sql ${CDB2_OPTIONS} ${dbnm} ${tier} "rebuild ${tbl_name}" &

	trigger_resume ${master} ${resume_trigger}

	if wait ${waitpid};
	then
		echo "FAIL: Merge succeeded before master swing. Test is buggy."
		return 1
	fi

	local -r num_records_inserted_per_shard_during_resume=1
	insert_records_into_table ${tbl_name} ${num_shards} ${num_records_inserted_per_shard_during_resume}

	wait_for_outstanding_scs &> /dev/null

	local timepart
	timepart=$(cdb2sql --tabs ${CDB2_OPTIONS} ${dbnm} ${tier} "select * from comdb2_timepartitions where name='${tbl_name}'")
	if [[ -n ${timepart} ]];
	then
		echo "FAIL: Found time partition that should not exist"
		return 1
	fi

	local -r expected_num_records=$(num_shards*num_records_per_shard+num_shards*num_records_inserted_per_shard_during_resume)
	local actual_num_records
	actual_num_records=$(cdb2sql --tabs ${CDB2_OPTIONS} ${dbnm} ${tier} "select count(*) from ${tbl_name}")
	if (( actual_num_records != expected_num_records ));
	then
		echo "FAIL: Unexpected number of records after partition merge"
		return 1
	fi
}

run_test() {
	local -r num_shards=$1 num_records_per_shard=$2 resume_trigger=$3 op_for_creating_partition=$4
	local -r tbl_name="t"

	setup ${tbl_name} ${num_shards} ${num_records_per_shard} ${op_for_creating_partition}

	test_driver ${tbl_name} ${num_shards} ${num_records_per_shard} ${resume_trigger}
	local -r rc=$?
	
	teardown ${tbl_name}

	return ${rc}
}

main() {
	local -r num_shards=5
	for num_records_per_shard in 10000;
	do
		for resume_trigger in ${DOWNGRADE};
		do
			for op_for_creating_partition in ${CREATE};
			do
				echo "------------------------"
				echo "Testing resume of a partitioned table triggered by a ${resume_trigger} "
				echo "Partitioned table was created using ${op_for_creating_partition} and contains ${num_records_per_shard} "
				echo "records in each of ${num_shards} shards"
				run_test ${num_shards} ${num_records_per_shard} ${resume_trigger} ${op_for_creating_partition}
				local rc=$?
				if (( rc == 0 )); then
					echo "Passed test --------------"
				else
					echo "Failed test --------------"
					exit 1
				fi
			done
		done
	done
}

main
