#!/usr/bin/env bash

# ordercounts.sh
#
# Simple script used to post-process an output file generated by the cdb2tcm 
# program.  The contract is that each select statement in a cdb2tcm req file is 
# preceeded by a count statement.  This searches the input file for 'count' 
# directives then reorders (sorts) those records.  This will normalise output of 
# a select statement so that the record set will always be ordered.
#
# We used this instead of "order by" to prevent the database from using an 
# index.

# test output file
file=$1

# temporary working file
tmp=${TMPDIR}/ocnt_tmp.$$

# put my output here
out=${TMPDIR}/ocnt_out.$$

# cnt variable
cnt=-1

# debug flag
debug=0

# zap output file
> $out

# read and reorder input file
while read ln ; do

    # parse this normal line of output
    if (( -1 == cnt )) ; then

        # check if this is a count-line
        if [[ "$ln" = "(count(*)='"* ]]; then

            x=${ln#\(count\(*\)=\'}
            cnt=${x%%\'\)}
            # Hi! if cnt=0, don't wait me more rows, none will come
            if (( cnt == 0 )) ; then
               cnt=-1
            fi
            > $tmp

        fi

        echo "$ln" >> $out

    # we are sorting- transfer this to a tmp-file
    elif (( cnt >= 0 )) ; then

        if (( cnt > 0 )) ; then
            echo "$ln" >> $tmp
            let cnt=cnt-1
        fi

        # if this is the last record, then sort & dump the output 
        if (( 0 == cnt )) ; then

            [[ -s $tmp ]] && sort $tmp >> $out
            cnt=-1
        fi
    fi


done < $file

# if we ended in the middle of an order-counts, sort what's there
if (( cnt > 0 )) ; then
    [[ -s $tmp ]] && sort $tmp >> $out
fi

cat $out
rm -f $out $tmp
