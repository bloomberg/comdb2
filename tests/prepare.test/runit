#!/usr/bin/env bash
bash -n "$0" | exit 1

#export debug=1
[[ $debug == "1" ]] && set -x

. ${TESTSROOTDIR}/tools/write_prompt.sh
. ${TESTSROOTDIR}/tools/ddl.sh
. ${TESTSROOTDIR}/tools/cluster_utils.sh

export stopfile=./stopfile.txt
export tablecount=50

function failexit
{
    touch $stopfile
    echo "Failed: $1"
    exit -1
}

function stop_cluster
{
    for node in $CLUSTER ; do
        $CDB2SQL_EXE $CDB2_OPTIONS --tabs $DBNAME --host $node "exec procedure sys.cmd.send(\"exit\")"
        sleep 1
        kill_by_pidfile ${TMPDIR}/${DBNAME}.${node}.pid
    done
}

function verify_up
{
    typeset func="verify_up"
    write_prompt $func "Running $func"
    typeset node=$1
    typeset count=0
    typeset r=1
    while [[ "$r" -ne "0" && "$count" -lt 30 ]]; do
        $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $node "select 1" >/dev/null 2>&1
        r=$?
        [[ $r != 0 ]] && sleep 1
        let count=count+1
    done
    [[ $r != 0 ]] && failexit "node $node did not recover in time"
}

function findmaster
{
    $CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default 'select host from comdb2_cluster where is_master="Y"'
}

function run_test
{
    typeset func="run_test"
    typeset master=$(findmaster)

    write_prompt $func "Running $func"

    rm $stopfile >/dev/null 2>&1

    write_prompt $func "Creating t1"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "create table t1(a int)"

    write_prompt $func "Inserting records"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 select * from generate_series(1, 1000)"

    write_prompt $func "Tell master to prepare and leak"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "put tunable 'debug_all_prepare_leak' 1"

    write_prompt $func "Insert 1000 more records"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 select * from generate_series(1, 1000)"

    write_prompt $func "Verify that replicant has seen prepared record"
    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select flags from comdb2_prepared")
    [[ "$x" -ne "RECOVERED" ]] && failexit "Error locating prepared record"

    # It's important not to write on master before bouncing:
    # we've told the master to orphan the last transaction and release it's locks on a test-tunable.
    # In a real workload the master would absolutely NEVER release locks without writing a prepare or
    # abort record
    write_prompt $func "Bounce the master $master"
    kill_restart_node $master

    write_prompt $func "Wait for election"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "select 1" > /dev/null 2>&1
    while [[ $? != 0 ]]; do
        sleep 1
        $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "select 1" > /dev/null 2>&1
    done

    master=$(findmaster)

    write_prompt $func "Verify that master has re-acquired locks"
    flags=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME --host $master "select flags from comdb2_prepared")
    [[ -z "$flags" ]] && failexit "Master did not recover the prepared txn"
    [[ "$flags" -ne "RECOVERED|HAVELOCKS" ]] && failexit "Master did not reaquire locks"
    write_prompt $func "Select the locks"
    locks=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME --host $master "select * from comdb2_locks where locktype='PAGE'")
    write_prompt $func "$locks"

    write_prompt $func "Get the dist-txnid"
    dist_txnid=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME --host $master "select dist_txnid from comdb2_prepared")

    #[[ -z "$dist_txnid" ]] && failexit "Master did 

    write_prompt $func "Dist-txnid is $dist_txnid"

    write_prompt $func "Since this is single-stripe a new insert should block"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 select * from generate_series(1, 1000)" &

    insert_pid=$!
    sleep 5

    kill -0 $insert_pid > /dev/null 2>&1
    r=$? ; [[ "$r" -ne "0" ]] && failexit "New insert not blocked on prepared transaction"
    write_prompt $func "New insert is blocked:"
    write_prompt $func "$(ps -ef | egrep $insert_pid)"

    write_prompt $func "A select should return 1000 records"
    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    [[ "$x" != "1000" ]] && failexit "Select returned incorrect number of records, $x vs 1000"

    write_prompt $func "Abort prepared dist-txn:"
    write_prompt $func "send disttxn $dist_txnid abort"
    $CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME --host $master "exec procedure sys.cmd.send('disttxn $dist_txnid abort')"

    sleep 5
    write_prompt $func "New insert should have resolved:"
    kill -0 $insert_pid > /dev/null 2>&1
    r=$? ; [[ "$r" -eq "0" ]] && failexit "New insert still blocked on prepared transaction"

    write_prompt $func "New insert is resolved: $(ps -ef | egrep $insert_pid)"

    write_prompt $func "Verify that t1 has 2000 records"
    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    write_prompt $func "Count is $x records"

    [[ "$x" -ne "2000" ]] && failexit "Found only $x records, should be 2000"

    master=$(findmaster)
    write_prompt $func "Tell master to prepare and leak"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME --host $master "put tunable 'debug_all_prepare_leak' 1"

    write_prompt $func "Insert 1000 more records"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 select * from generate_series(1, 1000)"

    write_prompt $func "Sleep for 5"
    sleep 5

    #write_prompt $func "Bouncing the cluster"
    #bounce_cluster
    write_prompt $func "Wait for cluster to restart"

    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "select 1" > /dev/null 2>&1
    while [[ $? != 0 ]]; do
        sleep 1
        $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "select 1" > /dev/null 2>&1
    done


    master=$(findmaster)

    write_prompt $func "Verify that master has re-acquired locks"
    flags=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME --host $master "select flags from comdb2_prepared")
    [[ -z "$flags" ]] && failexit "Master did not recover the prepared txn"
    [[ "$flags" -ne "RECOVERED|HAVELOCKS" ]] && failexit "Master did not reaquire locks"
    write_prompt $func "Select the locks"
    locks=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME --host $master "select * from comdb2_locks where locktype='PAGE'")
    write_prompt $func "$locks"

    write_prompt $func "Get the dist-txnid"
    dist_txnid=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME --host $master "select dist_txnid from comdb2_prepared")

    #[[ -z "$dist_txnid" ]] && failexit "Master did 

    write_prompt $func "Dist-txnid is $dist_txnid"

    write_prompt $func "Since this is single-stripe a new insert should block"
    $CDB2SQL_EXE $CDB2_OPTIONS $DBNAME default "insert into t1 select * from generate_series(1, 1000)" &

    insert_pid=$!
    sleep 5

    kill -0 $insert_pid > /dev/null 2>&1
    r=$? ; [[ "$r" -ne "0" ]] && failexit "New insert not blocked on prepared transaction"
    write_prompt $func "New insert is blocked:"
    write_prompt $func "$(ps -ef | egrep $insert_pid)"

    write_prompt $func "A select should return 2000 records"
    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    [[ "$x" != "2000" ]] && failexit "Select returned incorrect number of records, $x vs 2000"

    write_prompt $func "Abort prepared dist-txn:"
    write_prompt $func "send disttxn $dist_txnid abort"
    $CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME --host $master "exec procedure sys.cmd.send('disttxn $dist_txnid abort')"

    sleep 5
    write_prompt $func "New insert should have resolved:"
    kill -0 $insert_pid > /dev/null 2>&1
    r=$? ; [[ "$r" -eq "0" ]] && failexit "New insert still blocked on prepared transaction"

    write_prompt $func "New insert is resolved: $(ps -ef | egrep $insert_pid)"

    write_prompt $func "Verify that t1 has 3000 records"
    x=$($CDB2SQL_EXE --tabs $CDB2_OPTIONS $DBNAME default "select count(*) from t1")
    write_prompt $func "Count is $x records"

    [[ "$x" != "3000" ]] && failexit "Select returned incorrect number of records, $x vs 3000"
}

[[ -z "$CLUSTER" ]] && failexit "This test requires a cluster"

run_test
stop_cluster
wait
echo "Success"
