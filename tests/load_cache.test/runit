#!/usr/bin/env bash
bash -n "$0" | exit 1

. ${TESTSROOTDIR}/tools/write_prompt.sh
. ${TESTSROOTDIR}/tools/bounce_database.sh
. ${TESTSROOTDIR}/tools/ddl.sh

export debug=1
export sleeptime=10
export reppid=-1
export failpct=15
export loadrecs=1000000
export COPYCOMDB2_EXE=${BUILDDIR}/db/copycomdb2

[[ $debug == "1" ]] && set -x

function cleanup
{
    [[ $debug == "1" ]] && set -x
    typeset func="cleanup"
    write_prompt $func "Running $func"

    if [[ -n "$CLUSTER" ]]; then
        for node in $CLUSTER; do
            kill -9 $(cat ${TMPDIR}/${DBNAME}.${node}.pid)
        done
    else
        kill -9 $(cat ${TMPDIR}/${DBNAME}.pid)
    fi
}

function failexit
{
    [[ $debug == "1" ]] && set -x
    typeset func="failexit"
    write_prompt $func "Running $func"
    typeset f=$1
    write_prompt $func "$f failed: $2"
    cleanup
    exit -1
}

function bulk_insert_records
{
    [[ $debug == "1" ]] && set -x
    typeset func="bulk_insert_records"
    write_prompt $func "Running $func"
    typeset table=${1:-t1}
    typeset cnt=${2:-100000}
    typeset chunk=${3:-10000}
    j=0
    while [[ $cnt -gt 0 ]]; do
        if [[ $cnt -lt $chunk ]]; then
            amt=$cnt
        else
            amt=$chunk
        fi
        $CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "insert into $table select * from generate_series(1, $amt)" >/dev/null
        let cnt=$(( cnt - amt ))
    done
}

function flush_cluster
{
    [[ $debug == "1" ]] && set -x
    typeset func="flush_cluster"
    write_prompt $func "Running $func"

    if [[ -z "$CLUSTER" ]]; then
        $CDB2SQL_EXE $CDB2_OPTIONS --tabs $DBNAME default "exec procedure sys.cmd.send(\"flush\")"
    else
        for n in $CLUSTER ; do 
            $CDB2SQL_EXE $CDB2_OPTIONS --tabs $DBNAME --host $n "exec procedure sys.cmd.send(\"flush\")"
        done
    fi
}

function setup
{
    [[ $debug == "1" ]] && set -x
    typeset func="setup"
    write_prompt $func "Running $func"
    drop_table
    create_table
}

function load_cache
{
    [[ $debug == "1" ]] && set -x
    typeset func="load_cache"
    write_prompt $func "Running $func"
    typeset file=${1:-cache.txt}
    if [[ -z "$CLUSTER" ]]; then
        $CDB2SQL_EXE $CDB2_OPTIONS --tabs $DBNAME default "exec procedure sys.cmd.send(\"load_cache $file\")"
    else
        for n in $CLUSTER ; do 
            $CDB2SQL_EXE $CDB2_OPTIONS --tabs $DBNAME --host $n "exec procedure sys.cmd.send(\"load_cache $file\")"
        done
    fi
}

function dump_cache
{
    [[ $debug == "1" ]] && set -x
    typeset func="dump_cache"
    write_prompt $func "Running $func"
    typeset file=${1:-cache.txt}
    typeset dbname=${2:-$DBNAME}
    if [[ -z "$CLUSTER" ]]; then
        $CDB2SQL_EXE $CDB2_OPTIONS --tabs $dbname default "exec procedure sys.cmd.send(\"dump_cache $file\")"
    else
        export first=1
        for n in $CLUSTER ; do 
            $CDB2SQL_EXE $CDB2_OPTIONS --tabs $dbname --host $n "exec procedure sys.cmd.send(\"dump_cache $file\")"
            scp $SSH_OPT ${n}:${file} ${file}
            cp ${file} ${file}.${n}
        done
    fi
}

function sort_and_diff_files
{
    [[ $debug == "1" ]] && set -x
    typeset func="diff_files"
    write_prompt $func "Running $func"
    typeset file1=$1
    typeset file2=$2
    typeset linecnt
    typeset faildiff
    typeset cnt
    linecnt=$(wc -l ${file1} | awk '{print $1}')
    [[ -z $linecnt ]] && failexit "Cant read cache file"
    fd=$(echo "${linecnt} * 0.${failpct}" | bc)
    faildiff=${fd%%\.*}
    sort $file1 > ${file1}.sort
    sort $file2 > ${file2}.sort
    cnt=$(diff ${file1}.sort ${file2}.sort 2>&1| wc -l)
    (( $cnt > $faildiff )) && failexit "Sorted cache mis-match"
    echo "$file1 diffcount was $cnt, threshold was $faildiff"
}

function check_results
{
    [[ $debug == "1" ]] && set -x
    typeset func="check_results"
    write_prompt $func "Running $func"
    typeset file1=$1
    typeset file2=$2

    if [[ -z "$CLUSTER" ]]; then
        sort_and_diff_files $file1 $file2
    else 
        for n in $CLUSTER ; do
            sort_and_diff_files ${file1}.$n ${file2}.$n
        done
    fi
}

function copy_test
{
    [[ $debug == "1" ]] && set -x
    typeset func="copy_test"
    write_prompt $func "Running $func"
    typeset compfile=$1
    typeset autocache=$2
    export repname=rep$TESTID
    export repdir=${DBDIR}/$repname
    export replog=$repdir/log.txt
    export reppage="$repdir/reppage.txt"
    export myhost=$(hostname)

    if [[ -z "$CLUSTER" ]]; then
        cl="-y @localhost"
    else
        cl="-y @$(echo $CLUSTER | tr ' ' ',')"
    fi

    if [[ -n "$CLUSTER" ]]; then
        if [[ "$CLUSTER" =~ .*$myhost.* ]]; then
            rmt=""
        else
            clarray=($CLUSTER)
            rmt="${clarray[0]}:"
        fi
    fi

    write_prompt $func "Creating physical rep $repname"
    ${COPYCOMDB2_EXE} -x ${COMDB2_EXE} -H $repname $cl $rmt${DBDIR}/${DBNAME}.lrl $repdir $repdir

    if [[ "$autocache" != "ON" ]] ; then
        echo "autocache on" >> $repdir/${repname}.lrl
        cp $check $repdir/logs/pagelist
    fi

    write_prompt $func "Starting replicant database, replog is $replog"
    ( timeout $TEST_TIMEOUT $COMDB2_EXE $repname -lrl $repdir/${repname}.lrl -pidfile $repdir/${repname}.pid >$replog 2>&1 ) &
    reppid=$!

    waitmach localhost $repname
    sleep $sleeptime
    $CDB2SQL_EXE $CDB2_OPTIONS --tabs $repname --host localhost "exec procedure sys.cmd.send(\"dump_cache $reppage\")"
    kill -9 $(cat $repdir/${repname}.pid)
    sort_and_diff_files $reppage $check
}

function autocache_enabled
{
    [[ $debug == "1" ]] && set -x
    typeset func="autocache_enabled"
    x=$($CDB2SQL_EXE -tabs $CDB2_OPTIONS $DBNAME default "select value from comdb2_tunables where name = 'autocache'")
    echo "$x"
}

function run_test
{
    [[ $debug == "1" ]] && set -x
    typeset func="run_test"
    write_prompt $func "Running $func"
    typeset orig="$DBDIR/cache.txt"
    typeset check="$DBDIR/check_cache.txt"
    typeset autocache=$(autocache_enabled)
    bulk_insert_records t1 $loadrecs
    flush_cluster
    dump_cache $orig
    bounce_database $sleeptime
    sleep $(( sleeptime + 10 ))
    # Should load automatically if autocache is enabled
    if [[ "$autocache" != "ON" ]] ; then
        load_cache $orig
    fi
    sleep $sleeptime
    dump_cache $check
    check_results $orig $check 
    flush_cluster
    copy_test $orig $autocache
}

setup
run_test
cleanup
echo "Success"
