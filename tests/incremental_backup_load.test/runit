#!/bin/bash
# Test functionality for incremental backups with concurrent writeload
#export debug=1
[[ $debug == 1 ]] && set -x

dbname=$1
insertpid=-1
updatepid=-1
deletepid=-1

if [[ -z "$dbname" ]] ; then
  echo dbname missing
  exit 1
fi

function killwriters
{
    if [[ "$insertpid" != "-1" ]]; then
        kill -9 $insertpid
    fi
    if [[ "$updatepid" != "-1" ]]; then
        kill -9 $updatepid
    fi
    if [[ "$deletepid" != "-1" ]]; then
        kill -9 $deletepid
    fi
}

function failexit
{
    [[ $debug == 1 ]] && set -x
    echo "Failed $1"
    killwriters
    exit -1
}

function deleter
{
    while :; do 
        cdb2sql ${CDB2_OPTIONS} $dbname default "delete from load where 1 limit 10"
    done
}

function updater
{
    while :; do 
        cdb2sql ${CDB2_OPTIONS} $dbname default "update load set data=x'2222' where 1 limit 100"
        cdb2sql ${CDB2_OPTIONS} $dbname default "update load set name='yyy' where 1 limit 100"
    done
}

function inserter
{
    insertsql=${TMPDIR}/insert.sql
    echo "BEGIN" > $insertsql
    c=0
    # If these are too big we run the risk of having an open transaction
    # while we are trying to do a checkpoint, which could set the recovertolsn
    # value prior to the output that we're trying to verify
    while [[ $c -lt 100 ]]; do
        echo "INSERT INTO load VALUES ($c, 'xxx', x'1234')" >> $insertsql
        let c=c+1
    done
    echo "COMMIT" >> $insertsql

    while :; do 
        cdb2sql ${CDB2_OPTIONS} -f $insertsql $dbname default
    done
}

function force_checkpoint {
  [[ $debug == 1 ]] && set -x
  sleep 1
  cdb2sql ${CDB2_OPTIONS} $dbname default "exec procedure sys.cmd.send('flush')"
}

function make_base {
  [[ $debug == 1 ]] && set -x
  force_checkpoint
  basename=${TMPDIR}/backups/t1-1_base.tar
  backuplist+=(t1-1_base.tar)
  comdb2ar c -I create -b ${TMPDIR}/increment ${DBDIR}/${dbname}.lrl > $basename
  echo "~~~~~~~~~~"
  echo $basename
  echo "  DONE WITH BASE"
  echo " "
}

function make_backup {
  [[ $debug == 1 ]] && set -x
  force_checkpoint
  fullbackupname=$1
  backupname=${fullbackupname%.*}.tar
  backuplist+=($backupname)
  backuploc=${TMPDIR}/backups/${backupname}

  comdb2ar c -I inc -b ${TMPDIR}/increment ${DBDIR}/${dbname}.lrl > $backuploc
  echo "~~~~~~~~~~"
  echo ${TMPDIR}/backups/${backupname}
  echo "  DONE WITH INCREMENT"
  echo " "
}

function test_restoredb {
  [[ $debug == 1 ]] && set -x
  testname=$1
  restorecmd="cat "
  for i in $(seq 0 $2); do
    restorecmd="$restorecmd ${TMPDIR}/backups/${backuplist[i]} "
  done

  echo $restorecmd
  $restorecmd | comdb2ar x -I restore ${TMPDIR}/restore/ ${TMPDIR}/restore || failexit "Restore Failed"

  echo "~~~~~~~~~~"
  $comdb2task ${dbname}_restore --lrl ${TMPDIR}/restore/${dbname}.lrl -pidfile ${TMPDIR}/${dbname}_restore.pid &
  # wait for db to launch
  count=0
  cdb2sql ${CDB2_OPTIONS} ${dbname}_restore default "select 1" > ./sqloutput 2>&1
  sqloutput=$(cat ./sqloutput)
  while [ "$sqloutput" != "(1=1)" -a $count -le 30 ]; do
      sleep 1
      let count=count+1
      cdb2sql ${CDB2_OPTIONS} ${dbname}_restore default "select 1" > ./sqloutput 2>&1
      sqloutput=$(cat ./sqloutput)
  done

  if [ $count -ge 30 ] ; then
    kill -9 $(cat ${TMPDIR}/${dbname}_restore.pid)
    failexit "DB Startup exceeded"
  fi
  echo " "

  cdb2sql ${CDB2_OPTIONS} -f $1 ${dbname}_restore default > ${testname}.output 2>&1
  cat ${testname}.output
  diff ${testname}.expected ${testname}.output
  if [[ $? -ne 0 ]] ; then
    echo "  ^^^^^^^^^^^^"
    echo "The above testcase (${testname}) has failed!!!"
    echo " "
    echo " "
    kill -9 $(cat ${TMPDIR}/${dbname}_restore.pid)
    exit 1
  fi

  echo "${testname} passed"
  echo " "

  kill -9 $(cat ${TMPDIR}/${dbname}_restore.pid)
  rm -rf ${TMPDIR}/restore/*
}

function resetdb {
  [[ $debug == 1 ]] && set -x
  backuplist=()
  rm -rf ${TMPDIR}/backups ${TMPDIR}/restore ${TMPDIR}/increment
  mkdir -p ${TMPDIR}/backups ${TMPDIR}/restore ${TMPDIR}/increment

  cdb2sql ${CDB2_OPTIONS} $dbname default "DROP TABLE t1"
  force_checkpoint
  make_base
  cdb2sql ${CDB2_OPTIONS} $dbname default "CREATE TABLE t1  { `cat t1.csc2 ` }" || failexit "create failed"
  force_checkpoint
  make_backup t1-2_create_table
}

cdb2sql ${CDB2_OPTIONS} $dbname default "CREATE TABLE load  { `cat load.csc2 ` }" || failexit "create failed"

inserter &
insertpid=$!
sleep 1
updater &
updatepid=$!
sleep 1
deleter &
deletepid=$!

# BASIC FUNCTIONALITY TEST
resetdb
for statement in `ls t1-*.stmt`; do
  cdb2sql ${CDB2_OPTIONS} -f $statement $dbname default
  force_checkpoint
  make_backup $statement
done

echo "~~~~~~~~~~"
echo "  Moving on to restoration"
echo " "

counter=0

for testreq in `ls t1-*.req`; do
  test_restoredb $testreq $counter
  let counter=counter+1
done

# PUSH NEXT TEST FOR RECOVERY WITH LOG HOLES
resetdb
for i in $(seq 1 10); do
  cdb2sql ${CDB2_OPTIONS} $dbname default "exec procedure sys.cmd.send('pushnext')"
  # Need to sleep briefly so that multiple pushnext's aren't processed as the same one
  sleep 2
done
cdb2sql ${CDB2_OPTIONS} -f t1-3_insert.stmt $dbname default
make_backup push_next_inserts
test_restoredb t2.req 2
killwriters

echo "Test Successful"
exit 0
