#!/usr/bin/env bash
bash -n "$0" | exit 1

set -x

assertres ()
{
    if [ $# != 2 ] ; then 
        failexit "number of parameters passed is $# but expecting 2"
    fi
    res=$1
    target=$2
    if [ "$res" != "$target" ] ; then
        failexit "res is $res but should be $target"
    fi
}
failexit()
{
    echo $1
    exit 1
}

function waitfordb() {
    sleep 1
    local count=0
	sel=$(${CDB2SQL_EXE} --tabs ${CDB2_OPTIONS} $1 "select 1" 2>&1)
	while [[ "$sel" != "1" ]] && [[ $count -lt 60 ]] ; do
		sleep 1
	    sel=$(${CDB2SQL_EXE} --tabs ${CDB2_OPTIONS} $1 "select 1" 2>&1)
        let count=count+1
	done
    if [[ "$sel" != "1" ]] ; then 
        failexit 'cant contact db'
    fi
}

mkdir $DBDIR
touch $DBDIR/${DBNAME}.lrl
df $DBDIR | awk '{print $1 }' | grep "tmpfs\|nfs" && echo "setattr directio 0" > $DBDIR/${DBNAME}.lrl 
${COMDB2_EXE} ${DBNAME} --create --dir $DBDIR --lrl $DBDIR/${DBNAME}.lrl &> out
grep "Created database" out || failexit "expected 'Created database'"

echo "name    $DBNAME" >> $DBDIR/${DBNAME}.lrl
echo "dir     $DBDIR" >> $DBDIR/${DBNAME}.lrl
mkdir -p $TESTDIR/var/log/cdb2
mkdir -p $TMPDIR


echo "comdb2_config:default_type=local" >> $CDB2_CONFIG
$DEBUGGER ${COMDB2_EXE} $DBNAME --no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.pid &> $TESTDIR/logs/${DBNAME}.db &

waitfordb $DBNAME

cdb2sql --tabs ${CDB2_OPTIONS} $DBNAME default "select comdb2_hostname()"

cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql events detailed on')"

res=`cdb2sql --tabs ${CDB2_OPTIONS} $DBNAME default "select 1"`
assertres $res 1

res=`cdb2sql --tabs ${CDB2_OPTIONS} $DBNAME default "select 2"`
assertres $res 2

res=`cdb2sql --tabs ${CDB2_OPTIONS} $DBNAME default "select 2"`
assertres $res 2

res=`cdb2sql --tabs ${CDB2_OPTIONS} $DBNAME default "select 1"`
assertres $res 1


res=`cdb2sql --tabs ${CDB2_OPTIONS} $DBNAME default "nonsense" 2>&1`
exp="[nonsense] failed with rc -3 near \"nonsense\": syntax error"
assertres "\"$res\"" "\"$exp\""

res=`cdb2sql --tabs ${CDB2_OPTIONS} $DBNAME default "select * from nonexistent" 2>&1`
assertres "\"$res\"" \""[select * from nonexistent] failed with rc -3 no such table: nonexistent\""

COMDB2_UNITTEST=0 CLEANUPDBDIR=0 $TESTSROOTDIR/unsetup 1 > $TESTDIR/logs/${DBNAME}.unsetup

ls -ltr $TESTDIR/var/log/cdb2/ | grep events
logfl=`find $TESTDIR/var/log/cdb2/ -printf "%T@ %p\n" | grep "/$DBNAME" | grep events | sort -n | cut -f2 -d' ' | tail -1`
logflunziped=${logfl}.unzipped
if [ "x$logfl" == "x" ] ; then
    failexit "event logfl can not be found"
fi

wc $logfl
zcat $logfl > $logflunziped

getmembers()
{
    echo $1 | sed -e 's/[{}]/''/g' | awk -v k="text" '{n=split($0,a,","); for (i=1; i<=n; i++) print a[i]}' | grep "fingerprint\|error" | sed 's/[^:]*: //; s/^"//; s/"$//; s/\\"/"/g'
}

SAVIFS=$IFS
echo check all .*sql entries for fingerprint
echo '4f16a8ec9db90f803e406659938b2602' > exp.txt
IFS=$'\n'
for line in `grep 'sql","sql": "select 1"' $logflunziped ` ; do
    getmembers $line > out.txt
    #echo $line | python -c "import sys, json; txt=json.load(sys.stdin); print txt['fingerprint']" >> dbg.txt
    if ! diff out.txt exp.txt ; then
        failexit 'output is different from expected'
    fi 
done


echo check all .*sql entries for fingerprint
echo '4f16a8ec9db90f803e406659938b2602' > exp.txt
IFS=$'\n'
for line in `grep 'sql","sql": "select 2"' $logflunziped ` ; do
    getmembers $line > out.txt
    #echo $line | python -c "import sys, json; txt=json.load(sys.stdin); print txt['fingerprint']" >> dbg.txt
    if ! diff out.txt exp.txt ; then
        failexit 'output is different from expected'
    fi 
done

echo check all .*sql entries for fingerprint
echo '00000000000000000000000000000000' > exp.txt
grep 'sql","sql": "nonsense"' $logflunziped | while read line ;
do
    getmembers $line > out.txt
    #echo $line | python -c "import sys, json; txt=json.load(sys.stdin); print txt['error_code']; print txt['error']; print txt['fingerprint']" >> dbg.txt
    if ! diff out.txt exp.txt ; then
        failexit 'output is different from expected'
    fi
done

echo check the sql parameter now
echo '1
near "nonsense": syntax error
00000000000000000000000000000000' > exp.txt
line=`grep '"sql","sql": "nonsense"' $logflunziped`
getmembers $line > out.txt
#grep '"sql","sql": "nonsense"' $logflunziped | python -c "import sys, json; txt=json.load(sys.stdin); print txt['error_code']; print txt['error']; print txt['fingerprint']" >> dbg.txt
if ! diff out.txt exp.txt ; then
    failexit 'output is different from expected'
fi

echo check all .*sql entries for fingerprint
echo '00000000000000000000000000000000' > exp.txt
grep 'sql","sql": "select \* from nonexistent"' $logflunziped | while read line ; 
do
    getmembers $line > out.txt
    #echo $line | python -c "import sys, json; txt=json.load(sys.stdin); print txt['error_code']; print txt['error']; print txt['fingerprint']" >> dbg.txt
    if ! diff out.txt exp.txt ; then
        failexit 'output is different from expected'
    fi
done

echo check the sql parameter now
echo '1
no such table: nonexistent
00000000000000000000000000000000' > exp.txt
line=`grep '"sql","sql": "select \* from nonexistent"' $logflunziped`
getmembers $line > out.txt
#grep '"sql","sql": "select \* from nonexistent"' $logflunziped | python -c "import sys, json; txt=json.load(sys.stdin); print txt['error_code']; print txt['error']; print txt['fingerprint']" >> dbg.txt
if ! diff out.txt exp.txt ; then
    failexit 'output is different from expected'
fi


mv $TESTDIR/logs/${DBNAME}.db $TESTDIR/logs/${DBNAME}.db.2

NKEEP=5
IFS=$SAVIFS

echo "start db again, make sure that we keep only $NKEEP event log files of size 1 MB"
$DEBUGGER ${COMDB2_EXE} $DBNAME --no-global-lrl --lrl $DBDIR/${DBNAME}.lrl --pidfile ${TMPDIR}/${DBNAME}.pid &> $TESTDIR/logs/${DBNAME}.db &

waitfordb $DBNAME

cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql events detailed on')"
cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql events keep $NKEEP')"
cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql events rollat 1')" # in MB

cdb2sql ${CDB2_OPTIONS} $DBNAME default "create table t1(i int, s cstring(4001))"
blb=`cdb2sql --tabs ${CDB2_OPTIONS} $DBNAME default "select hex(randomblob(2000))"`

NUM=2000
for ((i=1;i<=$NUM;++i)); do echo "insert into t1 values($i, '$blb')"; done > in.sql 
cdb2sql ${CDB2_OPTIONS} $DBNAME default -f in.sql

cdb2sql ${CDB2_OPTIONS} $DBNAME default "insert into t1 values(10001, 'abc')"

sleep 3
# need to flush to get correct stmts in logfile
cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql events flush')"

find $TESTDIR/var/log/cdb2/ | grep "/$DBNAME" | grep '.events.' > logfls.txt
echo logfls
cat logfls.txt

logflcnt=$(wc -l logfls.txt | cut -f1 -d' ')

echo make sure we have $NKEEP as per the lrl option
assertres $logflcnt $NKEEP

echo "make sure string 'insert into t1 values(10001, 'abc')' is in the last 2 eventlog files:"
cat logfls.txt | xargs ls -1t | head -2 > lastfls.txt
echo lastfls 
cat lastfls.txt

res=$(cat lastfls.txt | xargs zgrep 'insert into t1 values(10001, '"'abc'"')' | grep -c '"type": "sql"')
assertres $res 1

echo "Test having no limit for logfiles (turning off rolling)"
cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql events rollat 0')"
cdb2sql ${CDB2_OPTIONS} $DBNAME default -f in.sql

find $TESTDIR/var/log/cdb2/ | grep "/$DBNAME" | grep '.events.' > logfls2.txt
if ! diff logfls.txt logfls2.txt ; then
    failexit "Should not have rolled: logfls.txt vs. logfls2.txt"
fi


echo "test setting custom file for event logging"
myevfl=$TESTDIR/var/log/cdb2/$DBNAME.myfile.events
cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql events file $myevfl')"
cdb2sql ${CDB2_OPTIONS} $DBNAME default "select 2"
cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql events dir $TESTDIR/var/log')"
cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql events roll')"
cdb2sql ${CDB2_OPTIONS} $DBNAME default "select 3"
d=`cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send('reql stat')"  | grep Eventlog | sed "s/[^:]*:\(.*\)')/\1/g" | xargs dirname`

COMDB2_UNITTEST=0 CLEANUPDBDIR=0 $TESTSROOTDIR/unsetup 1 > $TESTDIR/logs/${DBNAME}.unsetup

if [ ! -f $myevfl ] ; then
    failexit "$myevfl was not created"
fi
cnt=`zgrep "select 2" $myevfl  | grep -c '"type": "sql"'`
# assert setting the event log file
assertres $cnt 1

# assert setting the event log dir works
assertres $d $TESTDIR/var/log

exit 0
