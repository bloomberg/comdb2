/*
   Copyright 2200 Bloomberg Finance L.P.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */

#include "sql.h"
#include "dohsql.h"

struct fdb_push_connector {
    char *remotedb; /* name of the remote db; class matches stored fdb */
    enum mach_class class; /* what stage this db lives on */
    int class_override; /* class was explicit in the remdb name */
    int local;      /* is this a local db */
    int ncols;
    int rowlen;  /* current row len returned from remote */
    void *row;   /* current row returned from remote */
    Mem *unprow; /* generated by unpacking the row */
};

static void _master_clnt_set(struct sqlclntstate *clnt);

/**
 * Remote query push support
 * Save in clnt information that this is a standalone select that
 * refers to a remote table
 *
 */
int fdb_push_run(Parse *pParse, dohsql_node_t *node)
{
    GET_CLNT;
    fdb_push_connector_t *push = NULL;
    struct Db *pDb;

    if (!gbl_fdb_push_remote)
        return -1;

    if (clnt->intrans)
        return -1;

    push = calloc(1, sizeof(fdb_push_connector_t));
    if (!push) {
        logmsg(LOGMSG_ERROR, "Failed to allocate fdb_push\n");
        return -1;
    }
    pDb = &pParse->db->aDb[node->remotedb];
    push->remotedb = strdup(pDb->zDbSName);
    if (!push->remotedb) {
        logmsg(LOGMSG_ERROR, "Failed to allocate remotedb name\n");
        free(push);
        return -1;
    }
    push->class =  pDb->class;
    push->local = pDb->local;
    push->class_override = pDb->class_override;

    push->ncols = node->ncols;

    _master_clnt_set(clnt);

    clnt->fdb_push = push;

    return 0;
}

/**
 * Free remote push support
 */
void fdb_push_free(fdb_push_connector_t **pp)
{
    fdb_push_connector_t *p = *pp;
    if (p) {
        free(p->remotedb);
        if (p->unprow) {
            sqlite3UnpackedResultFree(&p->unprow, p->ncols);
        }
        *pp = NULL;
    }
}

/* override sqlite engine */
static int fdb_push_column_count(struct sqlclntstate *clnt, sqlite3_stmt *_)
{
    return clnt->fdb_push->ncols;
}

/* Typecasting may reallocate zMalloc. So do it while holding master_mem_mtx. */
#define FUNC_COLUMN_TYPE(ret, type, err_ret)                                   \
    static ret fdb_push_column_##type(struct sqlclntstate *clnt,               \
                                      sqlite3_stmt *stmt, int iCol)            \
    {                                                                          \
        fdb_push_connector_t *p = clnt->fdb_push;                              \
        ret rv;                                                                \
        p->unprow = sqlite3UnpackedResult(stmt, p->ncols, p->row, p->rowlen);  \
        if (!p->unprow)                                                        \
            return err_ret;                                                    \
        if (iCol < 0 || iCol >= p->ncols)                                      \
            return err_ret;                                                    \
        rv = sqlite3_value_##type(&p->unprow[iCol]);                           \
        return rv;                                                             \
    }

FUNC_COLUMN_TYPE(int, type, 0)
FUNC_COLUMN_TYPE(sqlite_int64, int64, 0)
FUNC_COLUMN_TYPE(double, double, 0)
FUNC_COLUMN_TYPE(int, bytes, 0)
FUNC_COLUMN_TYPE(const unsigned char *, text, NULL)
FUNC_COLUMN_TYPE(const void *, blob, NULL)
FUNC_COLUMN_TYPE(const dttz_t *, datetime, NULL)

static const intv_t *fdb_push_column_interval(struct sqlclntstate *clnt,
                                              sqlite3_stmt *stmt, int iCol,
                                              int type)
{
    fdb_push_connector_t *p = clnt->fdb_push;
    const intv_t *rv;
    p->unprow = sqlite3UnpackedResult(stmt, p->ncols, p->row, p->rowlen);
    if (!p->unprow)
        return NULL;
    if (iCol < 0 || iCol >= p->ncols)
        return NULL;

    rv = sqlite3_value_interval(&p->unprow[iCol], type);
    return rv;
}

static char *_get_tzname(struct sqlclntstate *clnt, sqlite3_stmt *_)
{
    return clnt->tzname;
}

static void _master_clnt_set(struct sqlclntstate *clnt)
{
    clnt->backup = clnt->plugin;

    clnt->plugin.column_count = fdb_push_column_count;
    clnt->plugin.column_type = fdb_push_column_type;
    clnt->plugin.column_int64 = fdb_push_column_int64;
    clnt->plugin.column_double = fdb_push_column_double;
    clnt->plugin.column_text = fdb_push_column_text;
    clnt->plugin.column_bytes = fdb_push_column_bytes;
    clnt->plugin.column_blob = fdb_push_column_blob;
    clnt->plugin.column_datetime = fdb_push_column_datetime;
    clnt->plugin.column_interval = fdb_push_column_interval;
    clnt->plugin.tzname = _get_tzname;
}

static int _get_remote_cost(struct sqlclntstate *clnt, cdb2_hndl_tp *hndl);

int handle_fdb_push(struct sqlclntstate *clnt, struct errstat *err)
{
    fdb_push_connector_t *push = clnt->fdb_push;
    cdb2_hndl_tp *hndl = NULL;
    uint64_t row_id = 0;
    int first_row = 1;
    int rc, irc;

    char *conf = getenv("CDB2_CONFIG");
    if (conf)
        cdb2_set_comdb2db_config(conf);

    if (push->local)
        rc = cdb2_open(&hndl, push->remotedb, "local", CDB2_SQL_ROWS);
    else if (push->class_override) {
        const char *cls_ovrr = mach_class_class2name(push->class);
        rc = cdb2_open(&hndl, push->remotedb, cls_ovrr, CDB2_SQL_ROWS);
    } else /* default */
        rc = cdb2_open(&hndl, push->remotedb, "default", CDB2_SQL_ROWS);
    if (rc) {
        errstat_set_rcstrf(err, rc, "Failed to open db %s local", push->remotedb);
        return -1;
    }

    rc = forward_set_commands(clnt, hndl, err);
    if (rc) {
        return -1;
    }

    rc = cdb2_run_statement(hndl, clnt->sql);
    if (rc) {
        errstat_set_rcstrf(err, rc, "Failed to run query", clnt->sql);
        goto closing;
    }

    int ncols = cdb2_numcolumns(hndl);

    rc = cdb2_next_record(hndl);
    errstat_set_rcstrf(err, rc, "next_record failed");
    while (rc == CDB2_OK) {
        push->row = cdb2_column_value(hndl, 0);
        push->rowlen = cdb2_column_size(hndl, 0);

        if (first_row) {
            /* send column info */
            first_row = 0;
            irc = write_response(clnt, RESPONSE_COLUMNS_FDB_PUSH, hndl, ncols);
            if (irc) {
                errstat_set_rcstrf(err, rc = -1, "Failed to send columns");
                goto closing;
            }
        }

        /* send row */
        row_id++;
        irc = send_row(clnt, NULL, row_id, 0, err);
        if (irc) {
            logmsg(LOGMSG_ERROR, "Failed to send row id %llu",
                   (long long unsigned int)row_id);
            goto closing;
        }

        irc = comdb2_sql_tick();
        if (irc) {
            errstat_set_rcstrf(err, rc = -1, "Sql tick failed");
            goto closing;
        }

        /* next row */
        rc = cdb2_next_record(hndl);
    }
    if (rc != CDB2_OK_DONE) {
        /* send error */
        errstat_set_rcstrf(err, rc = -1, "Query push failed");
        write_response(clnt, RESPONSE_ERROR, err->errstr, 0);
        goto closing;
    }

    /* send last row */
    if (first_row) {
        irc = write_response(clnt, RESPONSE_ROW_LAST_DUMMY, NULL, 0);
    } else {
        irc = write_response(clnt, RESPONSE_ROW_LAST, NULL, 0);
    }
    if (irc) {
        errstat_set_rcstrf(err, rc = -1, "Failed to send last row rc %d", irc);
        goto closing;
    }

    if (!irc && rc == CDB2_OK_DONE && clnt->get_cost) {
        rc = _get_remote_cost(clnt, hndl);
        if (rc) {
            logmsg(LOGMSG_ERROR, "Failed to save remote cost rc %d\n", rc);
            goto closing;
        }
    }

closing:
    cdb2_close(hndl);

    clnt_plugin_reset(clnt);

    return rc;
}

static int _get_remote_cost(struct sqlclntstate *clnt, cdb2_hndl_tp *hndl)
{
    int rc;

    if (clnt->prev_cost_string) {
        free(clnt->prev_cost_string);
        clnt->prev_cost_string = NULL;
    }

    /* NOTE: the data is coming as sqlite rows */
    rc = cdb2_run_statement(hndl, "SeLeCT comdb2_prevquerycost() as Cost");

    if (rc != CDB2_OK) {
        logmsg(LOGMSG_ERROR, "Failed to retrieve cost for \"%s\"\n", clnt->sql);
        return -1;
    }

    int ncols = cdb2_numcolumns(hndl);
    if (ncols != 1) {
        logmsg(LOGMSG_ERROR,
               "Incorrect number of columns for cost for \"%s\"\n", clnt->sql);
        return -1;
    }

    rc = cdb2_next_record(hndl);
    if (rc != CDB2_OK) {
        logmsg(LOGMSG_ERROR, "Failed to retrieve cost row for \"%s\"\n",
               clnt->sql);
        return -1;
    }

    clnt->fdb_push->row = cdb2_column_value(hndl, 0);
    clnt->fdb_push->rowlen = cdb2_column_size(hndl, 0);
    const char *remcost = (const char *)fdb_push_column_text(clnt, NULL, 0);
    if (remcost) {
        clnt->prev_cost_string = strdup(remcost);
    }
    rc = cdb2_next_record(hndl);
    if (rc != CDB2_OK_DONE) {
        logmsg(LOGMSG_ERROR, "Did get more then one row for cost for \"%s\"\n",
               clnt->sql);
        return -1;
    }

    return 0;
}
