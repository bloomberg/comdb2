/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains SQLite's grammar for SQL.  Process this file
** using the lemon parser generator to generate C code that runs
** the parser.  Lemon will also generate a header file containing
** numeric codes for all of the tokens.
*/

// All token codes are small integers with #defines that begin with "TK_"
%token_prefix TK_

// The type of the data attached to each token is Token.  This is also the
// default type for non-terminals.
//
%token_type {Token}
%default_type {Token}

// An extra argument to the constructor for the parser, which is available
// to all actions.
%extra_context {Parse *pParse}

// This code runs whenever there is a syntax error
//
%syntax_error {
  UNUSED_PARAMETER(yymajor);  /* Silence some compiler warnings */
  if( TOKEN.z[0] ){
    sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &TOKEN);
  }else{
    sqlite3ErrorMsg(pParse, "incomplete input");
  }
}
%stack_overflow {
  sqlite3ErrorMsg(pParse, "parser stack overflow");
}

// The name of the generated procedure that implements the parser
// is as follows:
%name sqlite3Parser

// The following text is included near the beginning of the C source
// code file that implements the parser.
//
%include {
#include "sqliteInt.h"

#if defined(SQLITE_BUILDING_FOR_COMDB2)
#include "comdb2Int.h"  /* ALL CUSTOM HEADERS ARE INCLUDED FROM HERE) */

#define TRAN_ERROR      "BEGIN, COMMIT, and ROLLBACK statements cannot be "   \
                        "prepared or executed directly against SQL engine "   \
                        "instances (e.g. via Lua stored procedures, etc). "   \
                        "Instead, a custom set of Lua commands must be used," \
                        "e.g. db:begin.  Other than Lua, these statements "   \
                        "are normally handled directly by code within the "   \
                        "subsystem used to prepare SQL queries for worker "   \
                        "threads."
#endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */

/*
** Disable all error recovery processing in the parser push-down
** automaton.
*/
#define YYNOERRORRECOVERY 1

/*
** Make yytestcase() the same as testcase()
*/
#define yytestcase(X) testcase(X)

/*
** Indicate that sqlite3ParserFree() will never be called with a null
** pointer.
*/
#define YYPARSEFREENEVERNULL 1

/*
** In the amalgamation, the parse.c file generated by lemon and the
** tokenize.c file are concatenated.  In that case, sqlite3RunParser()
** has access to the the size of the yyParser object and so the parser
** engine can be allocated from stack.  In that case, only the
** sqlite3ParserInit() and sqlite3ParserFinalize() routines are invoked
** and the sqlite3ParserAlloc() and sqlite3ParserFree() routines can be
** omitted.
*/
#ifdef SQLITE_AMALGAMATION
# define sqlite3Parser_ENGINEALWAYSONSTACK 1
#endif

/*
** Alternative datatype for the argument to the malloc() routine passed
** into sqlite3ParserAlloc().  The default is size_t.
*/
#define YYMALLOCARGTYPE  u64

/*
** An instance of the following structure describes the event of a
** TRIGGER.  "a" is the event type, one of TK_UPDATE, TK_INSERT,
** TK_DELETE, or TK_INSTEAD.  If the event is of the form
**
**      UPDATE ON (a,b,c)
**
** Then the "b" IdList records the list "a,b,c".
*/
struct TrigEvent { int a; IdList * b; };

struct FrameBound     { int eType; Expr *pExpr; };

/*
** Disable lookaside memory allocation for objects that might be
** shared across database connections.
*/
static void disableLookaside(Parse *pParse){
  pParse->disableLookaside++;
  pParse->db->lookaside.bDisable++;
}

#if defined(SQLITE_BUILDING_FOR_COMDB2)

/* Add flag for ANALYZE EXPERT */
static void setExpert(Parse *pParse){
  pParse->db->isExpert = 1;
}
#endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */
} // end %include

// Input is a single SQL command
input ::= cmdlist.
cmdlist ::= cmdlist ecmd.
cmdlist ::= ecmd.
ecmd ::= SEMI.
ecmd ::= cmdx SEMI.
%ifndef SQLITE_OMIT_EXPLAIN
ecmd ::= explain cmdx.
explain ::= EXPLAIN.              { pParse->explain = 1; }
explain ::= EXPLAIN QUERY PLAN.   { pParse->explain = 2; }
%ifdef SQLITE_BUILDING_FOR_COMDB2
explain ::= EXPLAIN DISTRIBUTION. { pParse->explain = 3; }
%endif SQLITE_BUILDING_FOR_COMDB2
%endif  SQLITE_OMIT_EXPLAIN
cmdx ::= cmd.           { sqlite3FinishCoding(pParse); }


///////////////////// Begin and end transactions. ////////////////////////////
//

%ifdef SQLITE_BUILDING_FOR_COMDB2
cmd ::= BEGIN transtype(Y) trans_opt.  {sqlite3ErrorMsg(pParse, TRAN_ERROR, Y);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
cmd ::= BEGIN transtype(Y) trans_opt.  {sqlite3BeginTransaction(pParse, Y);}
%endif !SQLITE_BUILDING_FOR_COMDB2
trans_opt ::= .
trans_opt ::= TRANSACTION.
trans_opt ::= TRANSACTION nm.
%type transtype {int}
transtype(A) ::= .             {A = TK_DEFERRED;}
transtype(A) ::= DEFERRED(X).  {A = @X; /*A-overwrites-X*/}
transtype(A) ::= IMMEDIATE(X). {A = @X; /*A-overwrites-X*/}
transtype(A) ::= EXCLUSIVE(X). {A = @X; /*A-overwrites-X*/}
%ifdef SQLITE_BUILDING_FOR_COMDB2
cmd ::= COMMIT|END(X) trans_opt.   {sqlite3ErrorMsg(pParse, TRAN_ERROR, @X);}
cmd ::= ROLLBACK(X) trans_opt.     {sqlite3ErrorMsg(pParse, TRAN_ERROR, @X);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
cmd ::= COMMIT|END(X) trans_opt.   {sqlite3EndTransaction(pParse,@X);}
cmd ::= ROLLBACK(X) trans_opt.     {sqlite3EndTransaction(pParse,@X);}
%endif !SQLITE_BUILDING_FOR_COMDB2

savepoint_opt ::= SAVEPOINT.
savepoint_opt ::= .
cmd ::= SAVEPOINT nm(X). {
#if defined(SQLITE_BUILDING_FOR_COMDB2)
  sqlite3ErrorMsg(pParse, TRAN_ERROR, &X);
#else /* defined(SQLITE_BUILDING_FOR_COMDB2) */
  sqlite3Savepoint(pParse, SAVEPOINT_BEGIN, &X);
#endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */
}
cmd ::= RELEASE savepoint_opt nm(X). {
#if defined(SQLITE_BUILDING_FOR_COMDB2)
  sqlite3ErrorMsg(pParse, TRAN_ERROR, &X);
#else /* defined(SQLITE_BUILDING_FOR_COMDB2) */
  sqlite3Savepoint(pParse, SAVEPOINT_RELEASE, &X);
#endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */
}
cmd ::= ROLLBACK trans_opt TO savepoint_opt nm(X). {
#if defined(SQLITE_BUILDING_FOR_COMDB2)
  sqlite3ErrorMsg(pParse, TRAN_ERROR, &X);
#else /* defined(SQLITE_BUILDING_FOR_COMDB2) */
  sqlite3Savepoint(pParse, SAVEPOINT_ROLLBACK, &X);
#endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */
}

///////////////////// The CREATE TABLE statement ////////////////////////////

cmd ::= create_table create_table_args.

%ifdef SQLITE_BUILDING_FOR_COMDB2
create_table ::= dryrun createkw temp(T) TABLE ifnotexists(E) nm(Y) dbnm(Z). {
   comdb2CreateTableStart(pParse,&Y,&Z,T,0,0,E);
}
%endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */
%ifndef SQLITE_BUILDING_FOR_COMDB2
create_table ::= createkw temp(T) TABLE ifnotexists(E) nm(Y) dbnm(Z). {
   sqlite3StartTable(pParse,&Y,&Z,T,0,0,E);
}
%endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */

%ifdef SQLITE_BUILDING_FOR_COMDB2
cmd ::= comdb2_create_table_csc2.
comdb2_create_table_csc2 ::= dryrun createkw temp(T) TABLE ifnotexists(E) nm(Y) dbnm(Z) comdb2opt(O) NOSQL(C). {
  comdb2CreateTableCSC2(pParse,&Y,&Z,O,&C,T,E);
}
%endif SQLITE_BUILDING_FOR_COMDB2
createkw(A) ::= CREATE(A).  {disableLookaside(pParse);}

%type ifnotexists {int}
ifnotexists(A) ::= .              {A = 0;}
ifnotexists(A) ::= IF NOT EXISTS. {A = 1;}
%type temp {int}
%ifndef SQLITE_OMIT_TEMPDB
temp(A) ::= TEMP.  {A = 1;}
%endif  SQLITE_OMIT_TEMPDB
temp(A) ::= .      {A = 0;}

%ifdef SQLITE_BUILDING_FOR_COMDB2
create_table_args ::= LP columnlist conslist_opt(X) RP(E) comdb2opt(O) table_options(F) partitioned merge. {
  comdb2CreateTableEnd(pParse,&X,&E,F,O);
}
partitioned ::= . 
partitioned ::= partitioned_by.
partitioned_by ::= PARTITIONED BY partition_options.
partition_options ::= TIME PERIOD STRING(P) RETENTION INTEGER(R) START STRING(S). {
  comdb2CreateTimePartition(pParse, &P, &R, &S);
}
partition_options ::= NONE. {
    comdb2SaveMergeTable(pParse, NULL, NULL, 1);
}
partition_options ::= MANUAL RETENTION INTEGER(R) START INTEGER(S). {
    comdb2CreateManualPartition(pParse, &R, &S);
}
partition_options ::= MANUAL RETENTION INTEGER(R). {
    comdb2CreateManualPartition(pParse, &R, 0);
}
merge ::= .
merge ::= merge_with.
merge_with ::= MERGE nm(Y) dbnm(Z). {
  comdb2SaveMergeTable(pParse, &Y, &Z, 0);
}
merge_with_alter ::= MERGE nm(Y) dbnm(Z). {
  comdb2SaveMergeTable(pParse, &Y, &Z, 1);
}

%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
create_table_args ::= LP columnlist conslist_opt(X) RP(E) table_options(F). {
  sqlite3EndTable(pParse,&X,&E,F,0);
}
%endif !SQLITE_BUILDING_FOR_COMDB2

%ifndef SQLITE_BUILDING_FOR_COMDB2
create_table_args ::= AS select(S). {
  sqlite3EndTable(pParse,0,0,0,S);
  sqlite3SelectDelete(pParse->db, S);
}
%endif !SQLITE_BUILDING_FOR_COMDB2
%ifdef SQLITE_BUILDING_FOR_COMDB2
create_table_args ::= LIKE_KW nm(Y) dbnm(Z). {
  comdb2CreateTableLikeEnd(pParse,&Y,&Z);
}
%endif SQLITE_BUILDING_FOR_COMDB2

%type table_options {int}
table_options(A) ::= .    {A = 0;}
%ifndef SQLITE_BUILDING_FOR_COMDB2
table_options(A) ::= WITHOUT nm(X). {
  if( X.n==5 && sqlite3_strnicmp(X.z,"rowid",5)==0 ){
    A = TF_WithoutRowid | TF_NoVisibleRowid;
  }else{
    A = 0;
    sqlite3ErrorMsg(pParse, "unknown table option: %.*s", X.n, X.z);
  }
}
%endif !SQLITE_BUILDING_FOR_COMDB2

columnlist ::= columnlist COMMA columnname carglist.
columnlist ::= columnname carglist.
%ifdef SQLITE_BUILDING_FOR_COMDB2
columnname(A) ::= nm(A) typetoken(Y). {comdb2AddColumn(pParse,&A,&Y);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
columnname(A) ::= nm(A) typetoken(Y). {sqlite3AddColumn(pParse,&A,&Y);}
%endif !SQLITE_BUILDING_FOR_COMDB2

// Declare some tokens early in order to influence their values, to 
// improve performance and reduce the executable size.  The goal here is
// to get the "jump" operations in ISNULL through ESCAPE to have numeric
// values that are early enough so that all jump operations are clustered
// at the beginning.
//
%token ABORT ACTION AFTER ANALYZE ASC ATTACH BEFORE BEGIN BY CASCADE CAST.
%token CONFLICT DATABASE DEFERRED DESC DETACH EACH END EXCLUSIVE EXPLAIN FAIL.
%token OR AND NOT IS MATCH LIKE_KW BETWEEN IN ISNULL NOTNULL NE EQ.
%token GT LE LT GE ESCAPE.

// The following directive causes tokens ABORT, AFTER, ASC, etc. to
// fallback to ID if they will not parse as their original value.
// This obviates the need for the "id" nonterminal.
//
%fallback ID
  ABORT ACTION AFTER ANALYZE ASC ATTACH BEFORE BEGIN BY CASCADE CAST COLUMNKW
  CONFLICT DATABASE DEFERRED DESC DETACH DO
  EACH END EXCLUSIVE EXPLAIN FAIL FOR
  IGNORE IMMEDIATE INITIALLY INSTEAD LIKE_KW MATCH NO PLAN
  QUERY KEY OF OFFSET PRAGMA RAISE RECURSIVE RELEASE REPLACE RESTRICT ROW ROWS
  ROLLBACK SAVEPOINT SEQUENCE TEMP TRIGGER VACUUM VIEW VIRTUAL WITH WITHOUT
%ifdef SQLITE_OMIT_COMPOUND_SELECT
  EXCEPT INTERSECT UNION
%endif SQLITE_OMIT_COMPOUND_SELECT
%ifndef SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_OMIT_WINDOWFUNC
  CURRENT FOLLOWING PARTITION PRECEDING RANGE UNBOUNDED
%endif SQLITE_OMIT_WINDOWFUNC
%endif !SQLITE_BUILDING_FOR_COMDB2
%ifdef SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_OMIT_WINDOWFUNC
  CURRENT FOLLOWING PARTITION PRECEDING RANGE UNBOUNDED
  EXCLUDE GROUPS OTHERS TIES
%endif SQLITE_OMIT_WINDOWFUNC
%ifdef SQLITE_OMIT_WINDOWFUNC
  RANGE
%endif SQLITE_OMIT_WINDOWFUNC
%endif SQLITE_BUILDING_FOR_COMDB2
  REINDEX RENAME CTIME_KW IF
%ifdef SQLITE_BUILDING_FOR_COMDB2
  ADD AGGREGATE ALIAS ANALYZEEXPERT ANALYZESQLITE AUTHENTICATION
  BLOBFIELD BULKIMPORT
  CHECK COMMITSLEEP CONSUMER CONVERTSLEEP COUNTER COVERAGE CRLE
  DATA DATABLOB DATACOPY DBPAD DEFERRABLE DETERMINISTIC DISABLE 
  DISTRIBUTION DRYRUN ENABLE EXEC EXECUTE FORCE FUNCTION GENID48 GET 
  GRANT INCLUDE INCREMENT IPU ISC KW LUA LZ4 MANUAL MERGE NONE
  ODH OFF OP OPTION OPTIONS
  PAGEORDER PARTITIONED PASSWORD PAUSE PERIOD PENDING PROCEDURE PUT
  REBUILD READ READONLY REC RESERVED RESUME RETENTION REVOKE RLE ROWLOCKS
  SCALAR SCHEMACHANGE SKIPSCAN START SUMMARIZE
  THREADS THRESHOLD TIME TRUNCATE TUNABLE TYPE
  VERSION WRITE DDL USERSCHEMA ZLIB
%endif SQLITE_BUILDING_FOR_COMDB2
  .
%wildcard ANY.

// Define operator precedence early so that this is the first occurrence
// of the operator tokens in the grammer.  Keeping the operators together
// causes them to be assigned integer values that are close together,
// which keeps parser tables smaller.
//
// The token values assigned to these symbols is determined by the order
// in which lemon first sees them.  It must be the case that ISNULL/NOTNULL,
// NE/EQ, GT/LE, and GE/LT are separated by only a single value.  See
// the sqlite3ExprIfFalse() routine for additional information on this
// constraint.
//
%left OR.
%left AND.
%right NOT.
%left IS MATCH LIKE_KW BETWEEN IN ISNULL NOTNULL NE EQ.
%left GT LE LT GE.
%right ESCAPE.
%left BITAND BITOR LSHIFT RSHIFT.
%left PLUS MINUS.
%left STAR SLASH REM.
%left CONCAT.
%left COLLATE.
%right BITNOT.
%nonassoc ON.

// An IDENTIFIER can be a generic identifier, or one of several
// keywords.  Any non-standard keyword can also be an identifier.
//
%token_class id  ID|INDEXED.


// And "ids" is an identifer-or-string.
//
%token_class ids  ID|STRING.

// The name of a column or table can be any of the following:
//
%type nm {Token}
nm(A) ::= id(A).
nm(A) ::= STRING(A).
nm(A) ::= JOIN_KW(A).

// A typetoken is really zero or more tokens that form a type name such
// as can be found after the column name in a CREATE TABLE statement.
// Multiple tokens are concatenated to form the value of the typetoken.
//
%type typetoken {Token}
typetoken(A) ::= .   {A.n = 0; A.z = 0;}
typetoken(A) ::= typename(A).
typetoken(A) ::= typename(A) LP signed RP(Y). {
  A.n = (int)(&Y.z[Y.n] - A.z);
}
%ifndef SQLITE_BUILDING_FOR_COMDB2
typetoken(A) ::= typename(A) LP signed COMMA signed RP(Y). {
  A.n = (int)(&Y.z[Y.n] - A.z);
}
%endif !SQLITE_BUILDING_FOR_COMDB2
%type typename {Token}
typename(A) ::= ids(A).
typename(A) ::= typename(A) ids(Y). {A.n=Y.n+(int)(Y.z-A.z);}
signed ::= plus_num.
signed ::= minus_num.

// The scanpt non-terminal takes a value which is a pointer to the
// input text just past the last token that has been shifted into
// the parser.  By surrounding some phrase in the grammar with two
// scanpt non-terminals, we can capture the input text for that phrase.
// For example:
//
//      something ::= .... scanpt(A) phrase scanpt(Z).
//
// The text that is parsed as "phrase" is a string starting at A
// and containing (int)(Z-A) characters.  There might be some extra
// whitespace on either end of the text, but that can be removed in
// post-processing, if needed.
//
%type scanpt {const char*}
scanpt(A) ::= . {
  assert( yyLookahead!=YYNOCODE );
  A = yyLookaheadToken.z;
}

// "carglist" is a list of additional constraints that come after the
// column name and column type in a CREATE TABLE statement.
//
carglist ::= carglist ccons.
carglist ::= .
ccons ::= CONSTRAINT nm(X).           {pParse->constraintName = X;}
ccons ::= DEFAULT scanpt(A) term(X) scanpt(Z).
%ifdef SQLITE_BUILDING_FOR_COMDB2
                            {comdb2AddDefaultValue(pParse,X,A,Z);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
                            {sqlite3AddDefaultValue(pParse,X,A,Z);}
%endif !SQLITE_BUILDING_FOR_COMDB2
ccons ::= DEFAULT LP(A) expr(X) RP(Z).
%ifdef SQLITE_BUILDING_FOR_COMDB2
// include LP and RP
                            {comdb2AddDefaultValue(pParse,X,A.z,Z.z+1);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
                            {sqlite3AddDefaultValue(pParse,X,A.z+1,Z.z);}
%endif !SQLITE_BUILDING_FOR_COMDB2
ccons ::= DEFAULT PLUS(A) term(X) scanpt(Z).
%ifdef SQLITE_BUILDING_FOR_COMDB2
                            {comdb2AddDefaultValue(pParse,X,A.z,Z);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
                            {sqlite3AddDefaultValue(pParse,X,A.z,Z);}
%endif !SQLITE_BUILDING_FOR_COMDB2
ccons ::= DEFAULT MINUS(A) term(X) scanpt(Z).      {
  Expr *p = sqlite3PExpr(pParse, TK_UMINUS, X, 0);
#if defined(SQLITE_BUILDING_FOR_COMDB2)
  comdb2AddDefaultValue(pParse,p,A.z,Z);
#else /* defined(SQLITE_BUILDING_FOR_COMDB2) */
  sqlite3AddDefaultValue(pParse,p,A.z,Z);
#endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */
}
ccons ::= DEFAULT scanpt id(X).       {
  Expr *p = tokenExpr(pParse, TK_STRING, X);
  if( p ){
    sqlite3ExprIdToTrueFalse(p);
    testcase( p->op==TK_TRUEFALSE && sqlite3ExprTruthValue(p) );
  }
#if defined(SQLITE_BUILDING_FOR_COMDB2)
  comdb2AddDefaultValue(pParse,p,X.z,X.z+X.n);
#else /* defined(SQLITE_BUILDING_FOR_COMDB2) */
    sqlite3AddDefaultValue(pParse,p,X.z,X.z+X.n);
#endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */
}

// In addition to the type name, we also care about the primary key and
// UNIQUE constraints.
//
%ifdef SQLITE_BUILDING_FOR_COMDB2
ccons ::= AUTOINCR.              {comdb2SetAutoIncrement(pParse);}
ccons ::= NULL onconf.           {comdb2AddNull(pParse);}
ccons ::= NOT NULL onconf(R).    {comdb2AddNotNull(pParse, R);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
ccons ::= NULL onconf.
ccons ::= NOT NULL onconf(R).    {sqlite3AddNotNull(pParse, R);}
%endif !SQLITE_BUILDING_FOR_COMDB2
ccons ::= PRIMARY KEY sortorder(Z) onconf(R) autoinc(I).
%ifdef SQLITE_BUILDING_FOR_COMDB2
                                 {comdb2AddPrimaryKey(pParse,0,R,I,Z);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
                                 {sqlite3AddPrimaryKey(pParse,0,R,I,Z);}
%endif !SQLITE_BUILDING_FOR_COMDB2
%ifdef SQLITE_BUILDING_FOR_COMDB2
ccons ::= UNIQUE onconf(R).      {
    comdb2AddIndex(pParse, 0, 0, R, 0, 0, 0, SQLITE_SO_ASC,
                   SQLITE_IDXTYPE_UNIQUE, 0, 0);
}
ccons ::= REFERENCES nm(T) LP eidlist(TA) RP refargs(R).
                                 {comdb2CreateForeignKey(pParse,0,&T,TA,R);}
ccons ::= INDEX onconf(R).       {
    comdb2AddIndex(pParse, 0, 0, R, 0, 0, 0, SQLITE_SO_ASC,
                   SQLITE_IDXTYPE_DUPKEY, 0, 0);
}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
ccons ::= UNIQUE onconf(R).      {sqlite3CreateIndex(pParse,0,0,0,0,R,0,0,0,0,
                                   SQLITE_IDXTYPE_UNIQUE);}
ccons ::= CHECK LP expr(X) RP.   {sqlite3AddCheckConstraint(pParse,X);}
ccons ::= REFERENCES nm(T) eidlist_opt(TA) refargs(R).
                                 {sqlite3CreateForeignKey(pParse,0,&T,TA,R);}
%endif !SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
ccons ::= defer_subclause(D).    {sqlite3DeferForeignKey(pParse,D);}
%endif !SQLITE_BUILDING_FOR_COMDB2
ccons ::= COLLATE ids(C).        {sqlite3AddCollateType(pParse, &C);}
%ifdef SQLITE_BUILDING_FOR_COMDB2
ccons ::= OPTION DBPAD EQ INTEGER(X). {
    int tmp;
    if (!readIntFromToken(&X, &tmp))
        tmp = 0;
    comdb2AddDbpad(pParse, tmp);
}
%endif SQLITE_BUILDING_FOR_COMDB2

// The optional AUTOINCREMENT keyword
%type autoinc {int}
autoinc(X) ::= .          {X = 0;}
%ifndef SQLITE_BUILDING_FOR_COMDB2
autoinc(X) ::= AUTOINCR.  {X = 1;}
%endif !SQLITE_BUILDING_FOR_COMDB2

// The next group of rules parses the arguments to a REFERENCES clause
// that determine if the referential integrity checking is deferred or
// or immediate and which determine what action to take if a ref-integ
// check fails.
//
%type refargs {int}
refargs(A) ::= .                  { A = OE_None*0x0101; /* EV: R-19803-45884 */}
refargs(A) ::= refargs(A) refarg(Y). { A = (A & ~Y.mask) | Y.value; }
%type refarg {struct {int value; int mask;}}
refarg(A) ::= MATCH nm.              { A.value = 0;     A.mask = 0x000000; }
refarg(A) ::= ON INSERT refact.      { A.value = 0;     A.mask = 0x000000; }
refarg(A) ::= ON DELETE refact(X).   { A.value = X;     A.mask = 0x0000ff; }
refarg(A) ::= ON UPDATE refact(X).   { A.value = X<<8;  A.mask = 0x00ff00; }
%type refact {int}
refact(A) ::= SET NULL.              { A = OE_SetNull;  /* EV: R-33326-45252 */}
refact(A) ::= SET DEFAULT.           { A = OE_SetDflt;  /* EV: R-33326-45252 */}
refact(A) ::= CASCADE.               { A = OE_Cascade;  /* EV: R-33326-45252 */}
refact(A) ::= RESTRICT.              { A = OE_Restrict; /* EV: R-33326-45252 */}
refact(A) ::= NO ACTION.             { A = OE_None;     /* EV: R-33326-45252 */}
%ifndef SQLITE_BUILDING_FOR_COMDB2
%type defer_subclause {int}
defer_subclause(A) ::= NOT DEFERRABLE init_deferred_pred_opt.     {A = 0;}
defer_subclause(A) ::= DEFERRABLE init_deferred_pred_opt(X).      {A = X;}
%type init_deferred_pred_opt {int}
init_deferred_pred_opt(A) ::= .                       {A = 0;}
init_deferred_pred_opt(A) ::= INITIALLY DEFERRED.     {A = 1;}
init_deferred_pred_opt(A) ::= INITIALLY IMMEDIATE.    {A = 0;}
%endif !SQLITE_BUILDING_FOR_COMDB2

conslist_opt(A) ::= .                         {A.n = 0; A.z = 0;}
conslist_opt(A) ::= COMMA(A) conslist.
conslist ::= conslist tconscomma tcons.
conslist ::= tcons.
tconscomma ::= COMMA.            {pParse->constraintName.n = 0;}
tconscomma ::= .
%ifndef SQLITE_BUILDING_FOR_COMDB2
tcons ::= CONSTRAINT nm(X).      {pParse->constraintName = X;}
tcons ::= PRIMARY KEY LP sortlist(X) autoinc(I) RP onconf(R).
                                 {sqlite3AddPrimaryKey(pParse,X,R,I,0);}
tcons ::= UNIQUE LP sortlist(X) RP onconf(R).
                                 {sqlite3CreateIndex(pParse,0,0,0,X,R,0,0,0,0,
                                       SQLITE_IDXTYPE_UNIQUE);}
%endif !SQLITE_BUILDING_FOR_COMDB2
%ifdef SQLITE_BUILDING_FOR_COMDB2
%type nm_opt {Token}
nm_opt(A) ::= .      {A.z=0; A.n=0;}
nm_opt(A) ::= nm(X). {A = X;}

%type with_opt {int}
with_opt(A) ::= OPTION DATACOPY. {A = 1;}
with_opt(A) ::= . {A = 0;}
tcons ::= CONSTRAINT nm(X).      {pParse->constraintName = X;}
tcons ::= PRIMARY KEY LP sortlist(X) autoinc(I) RP onconf(R). {
  comdb2AddPrimaryKey(pParse, X, R, I, 0);
}
tcons ::= UNIQUE nm_opt(I) LP sortlist(X) RP onconf(R) with_opt(O) scanpt(BW) where_opt(W) scanpt(AW). {
  comdb2AddIndex(pParse, &I, X, R, W, BW, AW, SQLITE_SO_ASC, SQLITE_IDXTYPE_UNIQUE, O, 0);
}
tcons ::= INDEX nm_opt(I) LP sortlist(X) RP with_opt(O) scanpt(BW) where_opt(W) scanpt(AW). {
  comdb2AddIndex(pParse, &I, X, 0, W, BW, AW, SQLITE_SO_ASC, SQLITE_IDXTYPE_DUPKEY, O, 0);
}
// datacopy with include syntax
tcons ::= UNIQUE nm_opt(I) LP sortlist(X) RP onconf(R) INCLUDE with_opt2(O) with_inc(P) scanpt(BW) where_opt(W) scanpt(AW). {
  comdb2AddIndex(pParse, &I, X, R, W, BW, AW, SQLITE_SO_ASC, SQLITE_IDXTYPE_UNIQUE, O, P);
}
tcons ::= INDEX nm_opt(I) LP sortlist(X) RP INCLUDE with_opt2(O) with_inc(P) scanpt(BW) where_opt(W) scanpt(AW). {
  comdb2AddIndex(pParse, &I, X, 0, W, BW, AW, SQLITE_SO_ASC, SQLITE_IDXTYPE_DUPKEY, O, P);
}
tcons ::= FOREIGN KEY LP eidlist(FA) RP
          REFERENCES nm(T) LP eidlist(TA) RP refargs(R) defer_subclause_opt(D). {
    comdb2CreateForeignKey(pParse, FA, &T, TA, R);
    comdb2DeferForeignKey(pParse, D);
}
tcons ::= CHECK LP scanpt(BW) expr(E) scanpt(AW) RP.
                                 {comdb2AddCheckConstraint(pParse,E,BW,AW);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
tcons ::= CHECK LP expr(E) RP onconf.
                                 {sqlite3AddCheckConstraint(pParse,E);}
tcons ::= FOREIGN KEY LP eidlist(FA) RP
          REFERENCES nm(T) eidlist_opt(TA) refargs(R) defer_subclause_opt(D). {
    sqlite3CreateForeignKey(pParse, FA, &T, TA, R);
    sqlite3DeferForeignKey(pParse, D);
}
%endif !SQLITE_BUILDING_FOR_COMDB2

%type defer_subclause_opt {int}
defer_subclause_opt(A) ::= .                    {A = 0;}
%ifndef SQLITE_BUILDING_FOR_COMDB2
defer_subclause_opt(A) ::= defer_subclause(A).
%endif !SQLITE_BUILDING_FOR_COMDB2

// The following is a non-standard extension that allows us to declare the
// default behavior when there is a constraint conflict.
//
%type onconf {int}
%type orconf {int}
%type resolvetype {int}
onconf(A) ::= .                              {A = OE_Default;}
onconf(A) ::= ON CONFLICT resolvetype(X).    {A = X;}
orconf(A) ::= .                              {A = OE_Default;}
orconf(A) ::= OR resolvetype(X).             {A = X;}
%ifndef SQLITE_BUILDING_FOR_COMDB2
resolvetype(A) ::= raisetype(A).
%endif !SQLITE_BUILDING_FOR_COMDB2
resolvetype(A) ::= IGNORE.                   {A = OE_Ignore;}
resolvetype(A) ::= REPLACE.                  {A = OE_Replace;}

////////////////////////// The DROP TABLE /////////////////////////////////////
//
cmd ::= drop_table.
drop_table ::= dryrun DROP TABLE ifexists(E) fullname(X). {
  sqlite3DropTable(pParse, X, 0, E);
}

%type ifexists {int}
ifexists(A) ::= IF EXISTS.   {A = 1;}
ifexists(A) ::= .            {A = 0;}

///////////////////// The CREATE VIEW statement /////////////////////////////
//
%ifndef SQLITE_OMIT_VIEW
cmd ::= dryrun createkw(X) temp(T) VIEW ifnotexists(E) nm(Y) dbnm(Z) eidlist_opt(C)
          AS select(S). {
  sqlite3CreateView(pParse, &X, &Y, &Z, C, S, T, E);
}
cmd ::= dryrun DROP VIEW ifexists(E) fullname(X). {
  sqlite3DropTable(pParse, X, 1, E);
}
%endif  SQLITE_OMIT_VIEW

//////////////////////// The SELECT statement /////////////////////////////////
//
cmd ::= select(X).  {
  SelectDest dest = {SRT_Output, 0, 0, 0, 0, 0};
  sqlite3Select(pParse, X, &dest);
  sqlite3SelectDelete(pParse->db, X);
}

%type select {Select*}
%destructor select {sqlite3SelectDelete(pParse->db, $$);}
%type selectnowith {Select*}
%destructor selectnowith {sqlite3SelectDelete(pParse->db, $$);}
%type oneselect {Select*}
%destructor oneselect {sqlite3SelectDelete(pParse->db, $$);}

%include {
  /*
  ** For a compound SELECT statement, make sure p->pPrior->pNext==p for
  ** all elements in the list.  And make sure list length does not exceed
  ** SQLITE_LIMIT_COMPOUND_SELECT.
  */
  static void parserDoubleLinkSelect(Parse *pParse, Select *p){
    if( p->pPrior ){
      Select *pNext = 0, *pLoop;
      int mxSelect, cnt = 0;
      for(pLoop=p; pLoop; pNext=pLoop, pLoop=pLoop->pPrior, cnt++){
        pLoop->pNext = pNext;
        pLoop->selFlags |= SF_Compound;
      }
      if( (p->selFlags & SF_MultiValue)==0 && 
        (mxSelect = pParse->db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT])>0 &&
        cnt>mxSelect
      ){
        sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
      }
    }
  }
}

%ifndef SQLITE_OMIT_CTE
select(A) ::= WITH wqlist(W) selectnowith(X). {
  Select *p = X;
  if( p ){
    p->pWith = W;
    parserDoubleLinkSelect(pParse, p);
  }else{
    sqlite3WithDelete(pParse->db, W);
  }
  A = p;
}
select(A) ::= WITH RECURSIVE wqlist(W) selectnowith(X). {
  Select *p = X;
  if( p ){
    p->pWith = W;
    parserDoubleLinkSelect(pParse, p);
  }else{
    sqlite3WithDelete(pParse->db, W);
  }
  A = p;
}
%endif /* SQLITE_OMIT_CTE */
select(A) ::= selectnowith(X). {
  Select *p = X;
  if( p ){
    parserDoubleLinkSelect(pParse, p);
  }
  A = p; /*A-overwrites-X*/
}

selectnowith(A) ::= oneselect(A).
%ifndef SQLITE_OMIT_COMPOUND_SELECT
selectnowith(A) ::= selectnowith(A) multiselect_op(Y) oneselect(Z).  {
  Select *pRhs = Z;
  Select *pLhs = A;
  if( pRhs && pRhs->pPrior ){
    SrcList *pFrom;
    Token x;
    x.n = 0;
    parserDoubleLinkSelect(pParse, pRhs);
    pFrom = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&x,pRhs,0,0);
    pRhs = sqlite3SelectNew(pParse,0,pFrom,0,0,0,0,0,0);
  }
  if( pRhs ){
    pRhs->op = (u8)Y;
    pRhs->pPrior = pLhs;
    if( ALWAYS(pLhs) ) pLhs->selFlags &= ~SF_MultiValue;
    pRhs->selFlags &= ~SF_MultiValue;
    if( Y!=TK_ALL ) pParse->hasCompound = 1;
  }else{
    sqlite3SelectDelete(pParse->db, pLhs);
  }
  A = pRhs;
}
%type multiselect_op {int}
multiselect_op(A) ::= UNION(OP).             {A = @OP; /*A-overwrites-OP*/}
multiselect_op(A) ::= UNION ALL.             {A = TK_ALL;}
multiselect_op(A) ::= EXCEPT|INTERSECT(OP).  {A = @OP; /*A-overwrites-OP*/}
%endif SQLITE_OMIT_COMPOUND_SELECT

oneselect(A) ::= SELECT distinct(D) selcollist(W) from(X) where_opt(Y)
                 groupby_opt(P) having_opt(Q) 
                 orderby_opt(Z) limit_opt(L). {
  A = sqlite3SelectNew(pParse,W,X,Y,P,Q,Z,D,L);
}
%ifndef SQLITE_OMIT_WINDOWFUNC
oneselect(A) ::= SELECT distinct(D) selcollist(W) from(X) where_opt(Y)
                 groupby_opt(P) having_opt(Q) window_clause(R)
                 orderby_opt(Z) limit_opt(L). {
  A = sqlite3SelectNew(pParse,W,X,Y,P,Q,Z,D,L);
  if( A ){
    A->pWinDefn = R;
  }else{
    sqlite3WindowListDelete(pParse->db, R);
  }
}
%endif


oneselect(A) ::= values(A).

%type values {Select*}
%destructor values {sqlite3SelectDelete(pParse->db, $$);}
values(A) ::= VALUES LP nexprlist(X) RP. {
  A = sqlite3SelectNew(pParse,X,0,0,0,0,0,SF_Values,0);
}
values(A) ::= values(A) COMMA LP nexprlist(Y) RP. {
  Select *pRight, *pLeft = A;
  pRight = sqlite3SelectNew(pParse,Y,0,0,0,0,0,SF_Values|SF_MultiValue,0);
  if( ALWAYS(pLeft) ) pLeft->selFlags &= ~SF_MultiValue;
  if( pRight ){
    pRight->op = TK_ALL;
    pRight->pPrior = pLeft;
    A = pRight;
  }else{
    A = pLeft;
  }
}

%ifdef SQLITE_BUILDING_FOR_COMDB2
/* add the SELECTV instruction */
oneselect(A) ::= SELECTV distinct(D) selcollist(W) from(X) where_opt(Y)
                 groupby_opt(P) having_opt(Q) orderby_opt(Z) limit_opt(L). {
  A = sqlite3SelectNew(pParse,W,X,Y,P,Q,Z,D,L);
  if( A ){
    A->recording = 1;
  }
}
%ifndef SQLITE_OMIT_WINDOWFUNC
oneselect(A) ::= SELECTV distinct(D) selcollist(W) from(X) where_opt(Y)
                 groupby_opt(P) having_opt(Q) window_clause(R)
                 orderby_opt(Z) limit_opt(L). {
  A = sqlite3SelectNew(pParse,W,X,Y,P,Q,Z,D,L);
  if( A ){
    A->recording = 1;
    A->pWinDefn = R;
  }else{
    sqlite3WindowListDelete(pParse->db, R);
  }
}
%endif
%endif SQLITE_BUILDING_FOR_COMDB2

// The "distinct" nonterminal is true (1) if the DISTINCT keyword is
// present and false (0) if it is not.
//
%type distinct {int}
distinct(A) ::= DISTINCT.   {A = SF_Distinct;}
distinct(A) ::= ALL.        {A = SF_All;}
distinct(A) ::= .           {A = 0;}

// selcollist is a list of expressions that are to become the return
// values of the SELECT statement.  The "*" in statements like
// "SELECT * FROM ..." is encoded as a special expression with an
// opcode of TK_ASTERISK.
//
%type selcollist {ExprList*}
%destructor selcollist {sqlite3ExprListDelete(pParse->db, $$);}
%type sclp {ExprList*}
%destructor sclp {sqlite3ExprListDelete(pParse->db, $$);}
sclp(A) ::= selcollist(A) COMMA.
sclp(A) ::= .                                {A = 0;}
selcollist(A) ::= sclp(A) scanpt(B) expr(X) scanpt(Z) as(Y).     {
   A = sqlite3ExprListAppend(pParse, A, X);
   if( Y.n>0 ) sqlite3ExprListSetName(pParse, A, &Y, 1);
   sqlite3ExprListSetSpan(pParse,A,B,Z);
}
selcollist(A) ::= sclp(A) scanpt STAR. {
  Expr *p = sqlite3Expr(pParse->db, TK_ASTERISK, 0);
  A = sqlite3ExprListAppend(pParse, A, p);
}
selcollist(A) ::= sclp(A) scanpt nm(X) DOT STAR. {
  Expr *pRight = sqlite3PExpr(pParse, TK_ASTERISK, 0, 0);
  Expr *pLeft = sqlite3ExprAlloc(pParse->db, TK_ID, &X, 1);
  Expr *pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);
  A = sqlite3ExprListAppend(pParse,A, pDot);
}

// An option "AS <id>" phrase that can follow one of the expressions that
// define the result set, or one of the tables in the FROM clause.
//
%type as {Token}
as(X) ::= AS nm(Y).    {X = Y;}
as(X) ::= ids(X).
as(X) ::= .            {X.n = 0; X.z = 0;}


%type seltablist {SrcList*}
%destructor seltablist {sqlite3SrcListDelete(pParse->db, $$);}
%type stl_prefix {SrcList*}
%destructor stl_prefix {sqlite3SrcListDelete(pParse->db, $$);}
%type from {SrcList*}
%destructor from {sqlite3SrcListDelete(pParse->db, $$);}

// A complete FROM clause.
//
from(A) ::= .                {A = sqlite3DbMallocZero(pParse->db, sizeof(*A));}
from(A) ::= FROM seltablist(X). {
  A = X;
  sqlite3SrcListShiftJoinType(A);
}

// "seltablist" is a "Select Table List" - the content of the FROM clause
// in a SELECT statement.  "stl_prefix" is a prefix of this list.
//
stl_prefix(A) ::= seltablist(A) joinop(Y).    {
   if( ALWAYS(A && A->nSrc>0) ) A->a[A->nSrc-1].fg.jointype = (u8)Y;
}
stl_prefix(A) ::= .                           {A = 0;}
seltablist(A) ::= stl_prefix(A) nm(Y) dbnm(D) as(Z) indexed_opt(I)
                  on_opt(N) using_opt(U). {
  A = sqlite3SrcListAppendFromTerm(pParse,A,&Y,&D,&Z,0,N,U);
  sqlite3SrcListIndexedBy(pParse, A, &I);
}
seltablist(A) ::= stl_prefix(A) nm(Y) dbnm(D) LP exprlist(E) RP as(Z)
                  on_opt(N) using_opt(U). {
  A = sqlite3SrcListAppendFromTerm(pParse,A,&Y,&D,&Z,0,N,U);
  sqlite3SrcListFuncArgs(pParse, A, E);
}
%ifndef SQLITE_OMIT_SUBQUERY
  seltablist(A) ::= stl_prefix(A) LP select(S) RP
                    as(Z) on_opt(N) using_opt(U). {
    A = sqlite3SrcListAppendFromTerm(pParse,A,0,0,&Z,S,N,U);
  }
  seltablist(A) ::= stl_prefix(A) LP seltablist(F) RP
                    as(Z) on_opt(N) using_opt(U). {
    if( A==0 && Z.n==0 && N==0 && U==0 ){
      A = F;
    }else if( F->nSrc==1 ){
      A = sqlite3SrcListAppendFromTerm(pParse,A,0,0,&Z,0,N,U);
      if( A ){
        struct SrcList_item *pNew = &A->a[A->nSrc-1];
        struct SrcList_item *pOld = F->a;
        pNew->zName = pOld->zName;
        pNew->zDatabase = pOld->zDatabase;
        pNew->pSelect = pOld->pSelect;
        if( pOld->fg.isTabFunc ){
          pNew->u1.pFuncArg = pOld->u1.pFuncArg;
          pOld->u1.pFuncArg = 0;
          pOld->fg.isTabFunc = 0;
          pNew->fg.isTabFunc = 1;
        }
        pOld->zName = pOld->zDatabase = 0;
        pOld->pSelect = 0;
      }
      sqlite3SrcListDelete(pParse->db, F);
    }else{
      Select *pSubquery;
      sqlite3SrcListShiftJoinType(F);
      pSubquery = sqlite3SelectNew(pParse,0,F,0,0,0,0,SF_NestedFrom,0);
      A = sqlite3SrcListAppendFromTerm(pParse,A,0,0,&Z,pSubquery,N,U);
    }
  }
%endif  SQLITE_OMIT_SUBQUERY

%type dbnm {Token}
dbnm(A) ::= .          {A.z=0; A.n=0;}
dbnm(A) ::= DOT nm(X). {A = X;}

%type fullname {SrcList*}
%destructor fullname {sqlite3SrcListDelete(pParse->db, $$);}
fullname(A) ::= nm(X).  {
  A = sqlite3SrcListAppend(pParse,0,&X,0);
#if !defined(SQLITE_BUILDING_FOR_COMDB2)
  if( IN_RENAME_OBJECT && A ) sqlite3RenameTokenMap(pParse, A->a[0].zName, &X);
#endif /* !defined(SQLITE_BUILDING_FOR_COMDB2) */
}
fullname(A) ::= nm(X) DOT nm(Y). {
  A = sqlite3SrcListAppend(pParse,0,&X,&Y);
#if !defined(SQLITE_BUILDING_FOR_COMDB2)
  if( IN_RENAME_OBJECT && A ) sqlite3RenameTokenMap(pParse, A->a[0].zName, &Y);
#endif /* !defined(SQLITE_BUILDING_FOR_COMDB2) */
}

%type xfullname {SrcList*}
%destructor xfullname {sqlite3SrcListDelete(pParse->db, $$);}
xfullname(A) ::= nm(X).  
   {A = sqlite3SrcListAppend(pParse,0,&X,0); /*A-overwrites-X*/}
xfullname(A) ::= nm(X) DOT nm(Y).  
   {A = sqlite3SrcListAppend(pParse,0,&X,&Y); /*A-overwrites-X*/}
xfullname(A) ::= nm(X) DOT nm(Y) AS nm(Z).  {
   A = sqlite3SrcListAppend(pParse,0,&X,&Y); /*A-overwrites-X*/
   if( A ) A->a[0].zAlias = sqlite3NameFromToken(pParse->db, &Z);
}
xfullname(A) ::= nm(X) AS nm(Z). {  
   A = sqlite3SrcListAppend(pParse,0,&X,0); /*A-overwrites-X*/
   if( A ) A->a[0].zAlias = sqlite3NameFromToken(pParse->db, &Z);
}

%type joinop {int}
joinop(X) ::= COMMA|JOIN.              { X = JT_INNER; }
joinop(X) ::= JOIN_KW(A) JOIN.
                  {X = sqlite3JoinType(pParse,&A,0,0);  /*X-overwrites-A*/}
joinop(X) ::= JOIN_KW(A) nm(B) JOIN.
                  {X = sqlite3JoinType(pParse,&A,&B,0); /*X-overwrites-A*/}
joinop(X) ::= JOIN_KW(A) nm(B) nm(C) JOIN.
                  {X = sqlite3JoinType(pParse,&A,&B,&C);/*X-overwrites-A*/}

// There is a parsing abiguity in an upsert statement that uses a
// SELECT on the RHS of a the INSERT:
//
//      INSERT INTO tab SELECT * FROM aaa JOIN bbb ON CONFLICT ...
//                                        here ----^^
//
// When the ON token is encountered, the parser does not know if it is
// the beginning of an ON CONFLICT clause, or the beginning of an ON
// clause associated with the JOIN.  The conflict is resolved in favor
// of the JOIN.  If an ON CONFLICT clause is intended, insert a dummy
// WHERE clause in between, like this:
//
//      INSERT INTO tab SELECT * FROM aaa JOIN bbb WHERE true ON CONFLICT ...
//
// The [AND] and [OR] precedence marks in the rules for on_opt cause the
// ON in this context to always be interpreted as belonging to the JOIN.
//
%type on_opt {Expr*}
%destructor on_opt {sqlite3ExprDelete(pParse->db, $$);}
on_opt(N) ::= ON expr(E).  {N = E;}
on_opt(N) ::= .     [OR]   {N = 0;}

// Note that this block abuses the Token type just a little. If there is
// no "INDEXED BY" clause, the returned token is empty (z==0 && n==0). If
// there is an INDEXED BY clause, then the token is populated as per normal,
// with z pointing to the token data and n containing the number of bytes
// in the token.
//
// If there is a "NOT INDEXED" clause, then (z==0 && n==1), which is 
// normally illegal. The sqlite3SrcListIndexedBy() function 
// recognizes and interprets this as a special case.
//
%type indexed_opt {Token}
indexed_opt(A) ::= .                 {A.z=0; A.n=0;}
%ifndef SQLITE_BUILDING_FOR_COMDB2
indexed_opt(A) ::= INDEXED BY nm(X). {A = X;}
indexed_opt(A) ::= NOT INDEXED.      {A.z=0; A.n=1;}
%endif !SQLITE_BUILDING_FOR_COMDB2

%type using_opt {IdList*}
%destructor using_opt {sqlite3IdListDelete(pParse->db, $$);}
using_opt(U) ::= USING LP idlist(L) RP.  {U = L;}
using_opt(U) ::= .                        {U = 0;}


%type orderby_opt {ExprList*}
%destructor orderby_opt {sqlite3ExprListDelete(pParse->db, $$);}

// the sortlist non-terminal stores a list of expression where each
// expression is optionally followed by ASC or DESC to indicate the
// sort order.
//
%type sortlist {ExprList*}
%destructor sortlist {sqlite3ExprListDelete(pParse->db, $$);}

orderby_opt(A) ::= .                          {A = 0;}
orderby_opt(A) ::= ORDER BY sortlist(X).      {A = X;}
sortlist(A) ::= sortlist(A) COMMA expr(Y) sortorder(Z). {
  A = sqlite3ExprListAppend(pParse,A,Y);
  sqlite3ExprListSetSortOrder(A,Z);
}
sortlist(A) ::= expr(Y) sortorder(Z). {
  A = sqlite3ExprListAppend(pParse,0,Y); /*A-overwrites-Y*/
  sqlite3ExprListSetSortOrder(A,Z);
}

%type sortorder {int}

sortorder(A) ::= ASC.           {A = SQLITE_SO_ASC;}
sortorder(A) ::= DESC.          {A = SQLITE_SO_DESC;}
sortorder(A) ::= .              {A = SQLITE_SO_UNDEFINED;}

%type groupby_opt {ExprList*}
%destructor groupby_opt {sqlite3ExprListDelete(pParse->db, $$);}
groupby_opt(A) ::= .                      {A = 0;}
groupby_opt(A) ::= GROUP BY nexprlist(X). {A = X;}

%type having_opt {Expr*}
%destructor having_opt {sqlite3ExprDelete(pParse->db, $$);}
having_opt(A) ::= .                {A = 0;}
having_opt(A) ::= HAVING expr(X).  {A = X;}

%type limit_opt {Expr*}

// The destructor for limit_opt will never fire in the current grammar.
// The limit_opt non-terminal only occurs at the end of a single production
// rule for SELECT statements.  As soon as the rule that create the 
// limit_opt non-terminal reduces, the SELECT statement rule will also
// reduce.  So there is never a limit_opt non-terminal on the stack 
// except as a transient.  So there is never anything to destroy.
//
//%destructor limit_opt {sqlite3ExprDelete(pParse->db, $$);}
limit_opt(A) ::= .       {A = 0;}
limit_opt(A) ::= LIMIT expr(X).
                         {A = sqlite3PExpr(pParse,TK_LIMIT,X,0);}
limit_opt(A) ::= LIMIT expr(X) OFFSET expr(Y). 
                         {A = sqlite3PExpr(pParse,TK_LIMIT,X,Y);}
limit_opt(A) ::= LIMIT expr(X) COMMA expr(Y). 
                         {A = sqlite3PExpr(pParse,TK_LIMIT,Y,X);}

/////////////////////////// The DELETE statement /////////////////////////////
//
%ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
cmd ::= with DELETE FROM xfullname(X) indexed_opt(I) where_opt(W) 
        orderby_opt(O) limit_opt(L). {
  sqlite3SrcListIndexedBy(pParse, X, &I);
#ifndef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
  sqlite3ExprListDelete(pParse->db, O); O = 0;
  sqlite3ExprDelete(pParse->db, L); L = 0;
#endif
  sqlite3DeleteFrom(pParse,X,W,O,L);
}
%endif
%ifndef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
cmd ::= with DELETE FROM xfullname(X) indexed_opt(I) where_opt(W). {
  sqlite3SrcListIndexedBy(pParse, X, &I);
  sqlite3DeleteFrom(pParse,X,W,0,0);
}
%endif

%type where_opt {Expr*}
%destructor where_opt {sqlite3ExprDelete(pParse->db, $$);}

where_opt(A) ::= .                    {A = 0;}
where_opt(A) ::= WHERE expr(X).       {A = X;}

////////////////////////// The UPDATE command ////////////////////////////////
//
%ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
%ifndef SQLITE_BUILDING_FOR_COMDB2
cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y)
%endif !SQLITE_BUILDING_FOR_COMDB2
%ifdef SQLITE_BUILDING_FOR_COMDB2
cmd ::= with UPDATE xfullname(X) indexed_opt(I) SET setlist(Y)
%endif SQLITE_BUILDING_FOR_COMDB2
        where_opt(W) orderby_opt(O) limit_opt(L).  {
  sqlite3SrcListIndexedBy(pParse, X, &I);
  sqlite3ExprListCheckLength(pParse,Y,"set list"); 
%ifndef SQLITE_BUILDING_FOR_COMDB2
  sqlite3Update(pParse,X,Y,W,R,O,L,0);
%endif !SQLITE_BUILDING_FOR_COMDB2
%ifdef SQLITE_BUILDING_FOR_COMDB2
  sqlite3Update(pParse,X,Y,W,0,O,L,0);
%endif SQLITE_BUILDING_FOR_COMDB2

}
%endif
%ifndef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
%ifndef SQLITE_BUILDING_FOR_COMDB2
cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y)
%endif !SQLITE_BUILDING_FOR_COMDB2
%ifdef SQLITE_BUILDING_FOR_COMDB2
cmd ::= with UPDATE xfullname(X) indexed_opt(I) SET setlist(Y)
%endif SQLITE_BUILDING_FOR_COMDB2
        where_opt(W).  {
  sqlite3SrcListIndexedBy(pParse, X, &I);
  sqlite3ExprListCheckLength(pParse,Y,"set list"); 
%ifndef SQLITE_BUILDING_FOR_COMDB2
  sqlite3Update(pParse,X,Y,W,R,0,0,0);
%endif !SQLITE_BUILDING_FOR_COMDB2
%ifdef SQLITE_BUILDING_FOR_COMDB2
  sqlite3Update(pParse,X,Y,W,0,0,0,0);
%endif SQLITE_BUILDING_FOR_COMDB2

}
%endif

%type setlist {ExprList*}
%destructor setlist {sqlite3ExprListDelete(pParse->db, $$);}

setlist(A) ::= setlist(A) COMMA nm(X) EQ expr(Y). {
  A = sqlite3ExprListAppend(pParse, A, Y);
  sqlite3ExprListSetName(pParse, A, &X, 1);
}
setlist(A) ::= setlist(A) COMMA LP idlist(X) RP EQ expr(Y). {
  A = sqlite3ExprListAppendVector(pParse, A, X, Y);
}
setlist(A) ::= nm(X) EQ expr(Y). {
  A = sqlite3ExprListAppend(pParse, 0, Y);
  sqlite3ExprListSetName(pParse, A, &X, 1);
}
setlist(A) ::= LP idlist(X) RP EQ expr(Y). {
  A = sqlite3ExprListAppendVector(pParse, 0, X, Y);
}

////////////////////////// The INSERT command /////////////////////////////////
//
cmd ::= with insert_cmd(R) INTO xfullname(X) idlist_opt(F) select(S)
        upsert(U). {
  sqlite3Insert(pParse, X, S, F, R, U);
}
cmd ::= with insert_cmd(R) INTO xfullname(X) idlist_opt(F) DEFAULT VALUES.
{
  sqlite3Insert(pParse, X, 0, F, R, 0);
}

%type upsert {Upsert*}

// Because upsert only occurs at the tip end of the INSERT rule for cmd,
// there is never a case where the value of the upsert pointer will not
// be destroyed by the cmd action.  So comment-out the destructor to
// avoid unreachable code.
//%destructor upsert {sqlite3UpsertDelete(pParse->db,$$);}
upsert(A) ::= . { A = 0; }
upsert(A) ::= ON CONFLICT LP sortlist(T) RP where_opt(TW)
              DO UPDATE SET setlist(Z) where_opt(W).
              { A = sqlite3UpsertNew(pParse->db,T,TW,Z,W);}
upsert(A) ::= ON CONFLICT LP sortlist(T) RP where_opt(TW) DO NOTHING.
              { A = sqlite3UpsertNew(pParse->db,T,TW,0,0); }
upsert(A) ::= ON CONFLICT DO NOTHING.
              { A = sqlite3UpsertNew(pParse->db,0,0,0,0); }

%type insert_cmd {int}
insert_cmd(A) ::= INSERT orconf(R).   {A = R;}
insert_cmd(A) ::= REPLACE.            {A = OE_Replace;}

%type idlist_opt {IdList*}
%destructor idlist_opt {sqlite3IdListDelete(pParse->db, $$);}
%type idlist {IdList*}
%destructor idlist {sqlite3IdListDelete(pParse->db, $$);}

idlist_opt(A) ::= .                       {A = 0;}
idlist_opt(A) ::= LP idlist(X) RP.    {A = X;}
idlist(A) ::= idlist(A) COMMA nm(Y).
    {A = sqlite3IdListAppend(pParse,A,&Y);}
idlist(A) ::= nm(Y).
    {A = sqlite3IdListAppend(pParse,0,&Y); /*A-overwrites-Y*/}

/////////////////////////// Expression Processing /////////////////////////////
//

%type expr {Expr*}
%destructor expr {sqlite3ExprDelete(pParse->db, $$);}
%type term {Expr*}
%destructor term {sqlite3ExprDelete(pParse->db, $$);}

%include {

  /* Construct a new Expr object from a single identifier.  Use the
  ** new Expr to populate pOut.  Set the span of pOut to be the identifier
  ** that created the expression.
  */
  static Expr *tokenExpr(Parse *pParse, int op, Token t){
    Expr *p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr)+t.n+1);
    if( p ){
      /* memset(p, 0, sizeof(Expr)); */
      p->op = (u8)op;
      p->affinity = 0;
      p->flags = EP_Leaf;
      p->iAgg = -1;
      p->pLeft = p->pRight = 0;
      p->x.pList = 0;
      p->pAggInfo = 0;
      p->y.pTab = 0;
      p->op2 = 0;
      p->iTable = 0;
      p->iColumn = 0;
      p->u.zToken = (char*)&p[1];
      memcpy(p->u.zToken, t.z, t.n);
      p->u.zToken[t.n] = 0;
      if( sqlite3Isquote(p->u.zToken[0]) ){
        sqlite3DequoteExpr(p);
      }
#if SQLITE_MAX_EXPR_DEPTH>0
      p->nHeight = 1;
#endif  
#if !defined(SQLITE_BUILDING_FOR_COMDB2)
      if( IN_RENAME_OBJECT ){
        return (Expr*)sqlite3RenameTokenMap(pParse, (void*)p, &t);
      }
#endif /* !defined(SQLITE_BUILDING_FOR_COMDB2) */
    }
    return p;
  }

}

expr(A) ::= term(A).
expr(A) ::= LP expr(X) RP. {A = X;}
expr(A) ::= id(X).          {A=tokenExpr(pParse,TK_ID,X); /*A-overwrites-X*/}
expr(A) ::= JOIN_KW(X).     {A=tokenExpr(pParse,TK_ID,X); /*A-overwrites-X*/}
expr(A) ::= nm(X) DOT nm(Y). {
  Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &X, 1);
  Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &Y, 1);
#if !defined(SQLITE_BUILDING_FOR_COMDB2)
  if( IN_RENAME_OBJECT ){
    sqlite3RenameTokenMap(pParse, (void*)temp2, &Y);
    sqlite3RenameTokenMap(pParse, (void*)temp1, &X);
  }
#endif /* !defined(SQLITE_BUILDING_FOR_COMDB2) */
  A = sqlite3PExpr(pParse, TK_DOT, temp1, temp2);
}
expr(A) ::= nm(X) DOT nm(Y) DOT nm(Z). {
  Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &X, 1);
  Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &Y, 1);
  Expr *temp3 = sqlite3ExprAlloc(pParse->db, TK_ID, &Z, 1);
  Expr *temp4 = sqlite3PExpr(pParse, TK_DOT, temp2, temp3);
#if !defined(SQLITE_BUILDING_FOR_COMDB2)
  if( IN_RENAME_OBJECT ){
    sqlite3RenameTokenMap(pParse, (void*)temp3, &Z);
    sqlite3RenameTokenMap(pParse, (void*)temp2, &Y);
  }
#endif /* !defined(SQLITE_BUILDING_FOR_COMDB2) */
  A = sqlite3PExpr(pParse, TK_DOT, temp1, temp4);
}
term(A) ::= NULL|FLOAT|BLOB(X). {A=tokenExpr(pParse,@X,X); /*A-overwrites-X*/}
term(A) ::= STRING(X).          {A=tokenExpr(pParse,@X,X); /*A-overwrites-X*/}
term(A) ::= INTEGER(X). {
  A = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &X, 1);
}
expr(A) ::= VARIABLE(X).     {
  if( !(X.z[0]=='#' && sqlite3Isdigit(X.z[1])) ){
    u32 n = X.n;
    A = tokenExpr(pParse, TK_VARIABLE, X);
    sqlite3ExprAssignVarNumber(pParse, A, n);
  }else{
    /* When doing a nested parse, one can include terms in an expression
    ** that look like this:   #1 #2 ...  These terms refer to registers
    ** in the virtual machine.  #N is the N-th register. */
    Token t = X; /*A-overwrites-X*/
    assert( t.n>=2 );
    if( pParse->nested==0 ){
      sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &t);
      A = 0;
    }else{
      A = sqlite3PExpr(pParse, TK_REGISTER, 0, 0);
      if( A ) sqlite3GetInt32(&t.z[1], &A->iTable);
    }
  }
}
expr(A) ::= expr(A) COLLATE ids(C). {
  A = sqlite3ExprAddCollateToken(pParse, A, &C, 1);
}

%ifdef SQLITE_BUILDING_FOR_COMDB2
expr(A) ::= expr(A) COLLATE DATACOPY. {
  if (pParse->db->init.busy == 0) {
      sqlite3ErrorMsg(pParse, "Support for 'COLLATE DATACOPY' syntax "
                      "has been removed; use INCLUDE ALL.");
      pParse->rc = SQLITE_ERROR;
  } else {
      Token t = {"DATACOPY", 8};
      A = sqlite3ExprAddCollateToken(pParse, A, &t, 1);
  }
}
%endif SQLITE_BUILDING_FOR_COMDB2

%ifndef SQLITE_OMIT_CAST
expr(A) ::= CAST LP expr(E) AS typetoken(T) RP. {
  A = sqlite3ExprAlloc(pParse->db, TK_CAST, &T, 1);
  sqlite3ExprAttachSubtrees(pParse->db, A, E, 0);
}
%endif  SQLITE_OMIT_CAST


expr(A) ::= id(X) LP distinct(D) exprlist(Y) RP. {
  A = sqlite3ExprFunction(pParse, Y, &X, D);
}
expr(A) ::= id(X) LP STAR RP. {
  A = sqlite3ExprFunction(pParse, 0, &X, 0);
}

%ifndef SQLITE_OMIT_WINDOWFUNC
expr(A) ::= id(X) LP distinct(D) exprlist(Y) RP over_clause(Z). {
  A = sqlite3ExprFunction(pParse, Y, &X, D);
  sqlite3WindowAttach(pParse, A, Z);
}
expr(A) ::= id(X) LP STAR RP over_clause(Z). {
  A = sqlite3ExprFunction(pParse, 0, &X, 0);
  sqlite3WindowAttach(pParse, A, Z);
}
%endif

term(A) ::= CTIME_KW(OP). {
  A = sqlite3ExprFunction(pParse, 0, &OP, 0);
}

expr(A) ::= LP nexprlist(X) COMMA expr(Y) RP. {
  ExprList *pList = sqlite3ExprListAppend(pParse, X, Y);
  A = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);
  if( A ){
    A->x.pList = pList;
  }else{
    sqlite3ExprListDelete(pParse->db, pList);
  }
}

expr(A) ::= expr(A) AND(OP) expr(Y).    {A=sqlite3PExpr(pParse,@OP,A,Y);}
expr(A) ::= expr(A) OR(OP) expr(Y).     {A=sqlite3PExpr(pParse,@OP,A,Y);}
expr(A) ::= expr(A) LT|GT|GE|LE(OP) expr(Y).
                                        {A=sqlite3PExpr(pParse,@OP,A,Y);}
expr(A) ::= expr(A) EQ|NE(OP) expr(Y).  {A=sqlite3PExpr(pParse,@OP,A,Y);}
expr(A) ::= expr(A) BITAND|BITOR|LSHIFT|RSHIFT(OP) expr(Y).
                                        {A=sqlite3PExpr(pParse,@OP,A,Y);}
expr(A) ::= expr(A) PLUS|MINUS(OP) expr(Y).
                                        {A=sqlite3PExpr(pParse,@OP,A,Y);}
expr(A) ::= expr(A) STAR|SLASH|REM(OP) expr(Y).
                                        {A=sqlite3PExpr(pParse,@OP,A,Y);}
expr(A) ::= expr(A) CONCAT(OP) expr(Y). {A=sqlite3PExpr(pParse,@OP,A,Y);}
%type likeop {Token}
likeop(A) ::= LIKE_KW|MATCH(A).
likeop(A) ::= NOT LIKE_KW|MATCH(X). {A=X; A.n|=0x80000000; /*A-overwrite-X*/}
expr(A) ::= expr(A) likeop(OP) expr(Y).  [LIKE_KW]  {
  ExprList *pList;
  int bNot = OP.n & 0x80000000;
  OP.n &= 0x7fffffff;
  pList = sqlite3ExprListAppend(pParse,0, Y);
  pList = sqlite3ExprListAppend(pParse,pList, A);
  A = sqlite3ExprFunction(pParse, pList, &OP, 0);
  if( bNot ) A = sqlite3PExpr(pParse, TK_NOT, A, 0);
  if( A ) A->flags |= EP_InfixFunc;
}
expr(A) ::= expr(A) likeop(OP) expr(Y) ESCAPE expr(E).  [LIKE_KW]  {
  ExprList *pList;
  int bNot = OP.n & 0x80000000;
  OP.n &= 0x7fffffff;
  pList = sqlite3ExprListAppend(pParse,0, Y);
  pList = sqlite3ExprListAppend(pParse,pList, A);
  pList = sqlite3ExprListAppend(pParse,pList, E);
  A = sqlite3ExprFunction(pParse, pList, &OP, 0);
  if( bNot ) A = sqlite3PExpr(pParse, TK_NOT, A, 0);
  if( A ) A->flags |= EP_InfixFunc;
}

expr(A) ::= expr(A) ISNULL|NOTNULL(E).   {A = sqlite3PExpr(pParse,@E,A,0);}
expr(A) ::= expr(A) NOT NULL.    {A = sqlite3PExpr(pParse,TK_NOTNULL,A,0);}

%include {
  /* A routine to convert a binary TK_IS or TK_ISNOT expression into a
  ** unary TK_ISNULL or TK_NOTNULL expression. */
  static void binaryToUnaryIfNull(Parse *pParse, Expr *pY, Expr *pA, int op){
    sqlite3 *db = pParse->db;
    if( pA && pY && pY->op==TK_NULL && !IN_RENAME_OBJECT ){
      pA->op = (u8)op;
      sqlite3ExprDelete(db, pA->pRight);
      pA->pRight = 0;
    }
  }
}

//    expr1 IS expr2
//    expr1 IS NOT expr2
//
// If expr2 is NULL then code as TK_ISNULL or TK_NOTNULL.  If expr2
// is any other expression, code as TK_IS or TK_ISNOT.
// 
expr(A) ::= expr(A) IS expr(Y).     {
  A = sqlite3PExpr(pParse,TK_IS,A,Y);
  binaryToUnaryIfNull(pParse, Y, A, TK_ISNULL);
}
expr(A) ::= expr(A) IS NOT expr(Y). {
  A = sqlite3PExpr(pParse,TK_ISNOT,A,Y);
  binaryToUnaryIfNull(pParse, Y, A, TK_NOTNULL);
}

expr(A) ::= NOT(B) expr(X).  
              {A = sqlite3PExpr(pParse, @B, X, 0);/*A-overwrites-B*/}
expr(A) ::= BITNOT(B) expr(X).
              {A = sqlite3PExpr(pParse, @B, X, 0);/*A-overwrites-B*/}
expr(A) ::= PLUS|MINUS(B) expr(X). [BITNOT] {
  A = sqlite3PExpr(pParse, @B==TK_PLUS ? TK_UPLUS : TK_UMINUS, X, 0);
  /*A-overwrites-B*/
}

%type between_op {int}
between_op(A) ::= BETWEEN.     {A = 0;}
between_op(A) ::= NOT BETWEEN. {A = 1;}
expr(A) ::= expr(A) between_op(N) expr(X) AND expr(Y). [BETWEEN] {
  ExprList *pList = sqlite3ExprListAppend(pParse,0, X);
  pList = sqlite3ExprListAppend(pParse,pList, Y);
  A = sqlite3PExpr(pParse, TK_BETWEEN, A, 0);
  if( A ){
    A->x.pList = pList;
  }else{
    sqlite3ExprListDelete(pParse->db, pList);
  } 
  if( N ) A = sqlite3PExpr(pParse, TK_NOT, A, 0);
}
%ifndef SQLITE_OMIT_SUBQUERY
  %type in_op {int}
  in_op(A) ::= IN.      {A = 0;}
  in_op(A) ::= NOT IN.  {A = 1;}
  expr(A) ::= expr(A) in_op(N) LP exprlist(Y) RP. [IN] {
    if( Y==0 ){
      /* Expressions of the form
      **
      **      expr1 IN ()
      **      expr1 NOT IN ()
      **
      ** simplify to constants 0 (false) and 1 (true), respectively,
      ** regardless of the value of expr1.
      */
      if( IN_RENAME_OBJECT==0 ){
        sqlite3ExprDelete(pParse->db, A);
        A = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[N],1);
      }
    }else if( Y->nExpr==1 ){
      /* Expressions of the form:
      **
      **      expr1 IN (?1)
      **      expr1 NOT IN (?2)
      **
      ** with exactly one value on the RHS can be simplified to something
      ** like this:
      **
      **      expr1 == ?1
      **      expr1 <> ?2
      **
      ** But, the RHS of the == or <> is marked with the EP_Generic flag
      ** so that it may not contribute to the computation of comparison
      ** affinity or the collating sequence to use for comparison.  Otherwise,
      ** the semantics would be subtly different from IN or NOT IN.
      */
      Expr *pRHS = Y->a[0].pExpr;
      Y->a[0].pExpr = 0;
      sqlite3ExprListDelete(pParse->db, Y);
      /* pRHS cannot be NULL because a malloc error would have been detected
      ** before now and control would have never reached this point */
      if( ALWAYS(pRHS) ){
        pRHS->flags &= ~EP_Collate;
        pRHS->flags |= EP_Generic;
      }
      A = sqlite3PExpr(pParse, N ? TK_NE : TK_EQ, A, pRHS);
    }else{
      A = sqlite3PExpr(pParse, TK_IN, A, 0);
      if( A ){
        A->x.pList = Y;
        sqlite3ExprSetHeightAndFlags(pParse, A);
      }else{
        sqlite3ExprListDelete(pParse->db, Y);
      }
      if( N ) A = sqlite3PExpr(pParse, TK_NOT, A, 0);
    }
  }
  expr(A) ::= LP select(X) RP. {
    A = sqlite3PExpr(pParse, TK_SELECT, 0, 0);
    sqlite3PExprAddSelect(pParse, A, X);
  }
  expr(A) ::= expr(A) in_op(N) LP select(Y) RP.  [IN] {
    A = sqlite3PExpr(pParse, TK_IN, A, 0);
    sqlite3PExprAddSelect(pParse, A, Y);
    if( N ) A = sqlite3PExpr(pParse, TK_NOT, A, 0);
  }
  expr(A) ::= expr(A) in_op(N) nm(Y) dbnm(Z) paren_exprlist(E). [IN] {
    SrcList *pSrc = sqlite3SrcListAppend(pParse, 0,&Y,&Z);
    Select *pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0);
    if( E )  sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, E);
    A = sqlite3PExpr(pParse, TK_IN, A, 0);
    sqlite3PExprAddSelect(pParse, A, pSelect);
    if( N ) A = sqlite3PExpr(pParse, TK_NOT, A, 0);
  }
  expr(A) ::= EXISTS LP select(Y) RP. {
    Expr *p;
    p = A = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);
    sqlite3PExprAddSelect(pParse, p, Y);
  }
%endif SQLITE_OMIT_SUBQUERY

/* CASE expressions */
expr(A) ::= CASE case_operand(X) case_exprlist(Y) case_else(Z) END. {
  A = sqlite3PExpr(pParse, TK_CASE, X, 0);
  if( A ){
    A->x.pList = Z ? sqlite3ExprListAppend(pParse,Y,Z) : Y;
    sqlite3ExprSetHeightAndFlags(pParse, A);
  }else{
    sqlite3ExprListDelete(pParse->db, Y);
    sqlite3ExprDelete(pParse->db, Z);
  }
}
%type case_exprlist {ExprList*}
%destructor case_exprlist {sqlite3ExprListDelete(pParse->db, $$);}
case_exprlist(A) ::= case_exprlist(A) WHEN expr(Y) THEN expr(Z). {
  A = sqlite3ExprListAppend(pParse,A, Y);
  A = sqlite3ExprListAppend(pParse,A, Z);
}
case_exprlist(A) ::= WHEN expr(Y) THEN expr(Z). {
  A = sqlite3ExprListAppend(pParse,0, Y);
  A = sqlite3ExprListAppend(pParse,A, Z);
}
%type case_else {Expr*}
%destructor case_else {sqlite3ExprDelete(pParse->db, $$);}
case_else(A) ::=  ELSE expr(X).         {A = X;}
case_else(A) ::=  .                     {A = 0;} 
%type case_operand {Expr*}
%destructor case_operand {sqlite3ExprDelete(pParse->db, $$);}
case_operand(A) ::= expr(X).            {A = X; /*A-overwrites-X*/} 
case_operand(A) ::= .                   {A = 0;} 

%type exprlist {ExprList*}
%destructor exprlist {sqlite3ExprListDelete(pParse->db, $$);}
%type nexprlist {ExprList*}
%destructor nexprlist {sqlite3ExprListDelete(pParse->db, $$);}

exprlist(A) ::= nexprlist(A).
exprlist(A) ::= .                            {A = 0;}
nexprlist(A) ::= nexprlist(A) COMMA expr(Y).
    {A = sqlite3ExprListAppend(pParse,A,Y);}
nexprlist(A) ::= expr(Y).
    {A = sqlite3ExprListAppend(pParse,0,Y); /*A-overwrites-Y*/}

%ifndef SQLITE_OMIT_SUBQUERY
/* A paren_exprlist is an optional expression list contained inside
** of parenthesis */
%type paren_exprlist {ExprList*}
%destructor paren_exprlist {sqlite3ExprListDelete(pParse->db, $$);}
paren_exprlist(A) ::= .   {A = 0;}
paren_exprlist(A) ::= LP exprlist(X) RP.  {A = X;}
%endif SQLITE_OMIT_SUBQUERY


///////////////////////////// The CREATE INDEX command ///////////////////////
//
%ifdef SQLITE_BUILDING_FOR_COMDB2
%type pdl {ExprList*}
%destructor pdl {sqlite3ExprListDelete(pParse->db, $$);}
pdl(A) ::= pdl(A) COMMA nm(Y). {
  A = sqlite3ExprListAppend(pParse,A,tokenExpr(pParse,TK_ID,Y));
}
pdl(A) ::= nm(Y). {
  A = sqlite3ExprListAppend(pParse,0,tokenExpr(pParse,TK_ID,Y)); /*A-overwrites-Y*/
}
%type with_inc {ExprList*}
%destructor with_inc {sqlite3ExprListDelete(pParse->db, $$);}
with_inc(A) ::= LP pdl(P) RP. {A = P;}
with_inc(A) ::= . {A = 0;}
%type with_opt2 {int}
with_opt2(A) ::= ALL. {A = 1;}
with_opt2(A) ::= . {A = 2;} // partial datacopy
cmd ::= dryrun createkw(S) temp(T) uniqueflag(U) INDEX ifnotexists(NE) nm(X) dbnm(D)
        ON nm(Y) LP sortlist(Z) RP with_opt(O) scanpt(BW) where_opt(W) scanpt(AW). {
  comdb2CreateIndex(pParse, &X, &D,
                    sqlite3SrcListAppend(pParse,0,&Y,0), Z, U,
                     &S, W, BW, AW, SQLITE_SO_ASC, NE, SQLITE_IDXTYPE_APPDEF,
                     O, 0, T);
}
// datacopy with include syntax
cmd ::= dryrun createkw(S) temp(T) uniqueflag(U) INDEX ifnotexists(NE) nm(X) dbnm(D)
        ON nm(Y) LP sortlist(Z) RP INCLUDE with_opt2(O) with_inc(P) scanpt(BW) where_opt(W) scanpt(AW). {
  comdb2CreateIndex(pParse, &X, &D,
                    sqlite3SrcListAppend(pParse,0,&Y,0), Z, U,
                     &S, W, BW, AW, SQLITE_SO_ASC, NE, SQLITE_IDXTYPE_APPDEF,
                     O, P, T);
}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
cmd ::= dryrun createkw(S) uniqueflag(U) INDEX ifnotexists(NE) nm(X) dbnm(D)
        ON nm(Y) LP sortlist(Z) RP where_opt(W). {
  sqlite3CreateIndex(pParse, &X, &D, 
                     sqlite3SrcListAppend(pParse,0,&Y,0), Z, U,
                      &S, W, SQLITE_SO_ASC, NE, SQLITE_IDXTYPE_APPDEF);
#if !defined(SQLITE_BUILDING_FOR_COMDB2)
  if( IN_RENAME_OBJECT && pParse->pNewIndex ){
    sqlite3RenameTokenMap(pParse, pParse->pNewIndex->zName, &Y);
  }
#endif /* !defined(SQLITE_BUILDING_FOR_COMDB2) */
}
%endif !SQLITE_BUILDING_FOR_COMDB2

%type uniqueflag {int}
uniqueflag(A) ::= UNIQUE.  {A = OE_Abort;}
uniqueflag(A) ::= .        {A = OE_None;}


// The eidlist non-terminal (Expression Id List) generates an ExprList
// from a list of identifiers.  The identifier names are in ExprList.a[].zName.
// This list is stored in an ExprList rather than an IdList so that it
// can be easily sent to sqlite3ColumnsExprList().
//
// eidlist is grouped with CREATE INDEX because it used to be the non-terminal
// used for the arguments to an index.  That is just an historical accident.
//
// IMPORTANT COMPATIBILITY NOTE:  Some prior versions of SQLite accepted
// COLLATE clauses and ASC or DESC keywords on ID lists in inappropriate
// places - places that might have been stored in the sqlite_master schema.
// Those extra features were ignored.  But because they might be in some
// (busted) old databases, we need to continue parsing them when loading
// historical schemas.
//
%type eidlist {ExprList*}
%destructor eidlist {sqlite3ExprListDelete(pParse->db, $$);}
%type eidlist_opt {ExprList*}
%destructor eidlist_opt {sqlite3ExprListDelete(pParse->db, $$);}

%include {
  /* Add a single new term to an ExprList that is used to store a
  ** list of identifiers.  Report an error if the ID list contains
  ** a COLLATE clause or an ASC or DESC keyword, except ignore the
  ** error while parsing a legacy schema.
  */
  static ExprList *parserAddExprIdListTerm(
    Parse *pParse,
    ExprList *pPrior,
    Token *pIdToken,
    int hasCollate,
    int sortOrder
  ){
    ExprList *p = sqlite3ExprListAppend(pParse, pPrior, 0);
    if( (hasCollate || sortOrder!=SQLITE_SO_UNDEFINED)
        && pParse->db->init.busy==0
    ){
      sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"",
                         pIdToken->n, pIdToken->z);
    }
    sqlite3ExprListSetName(pParse, p, pIdToken, 1);
#if defined(SQLITE_BUILDING_FOR_COMDB2)
    sqlite3ExprListSetSortOrder(p, sortOrder);
#endif /* defined(SQLITE_BUILDING_FOR_COMDB2) */
    return p;
  }
} // end %include

eidlist_opt(A) ::= .                         {A = 0;}
eidlist_opt(A) ::= LP eidlist(X) RP.         {A = X;}
eidlist(A) ::= eidlist(A) COMMA nm(Y) collate(C) sortorder(Z).  {
  A = parserAddExprIdListTerm(pParse, A, &Y, C, Z);
}
eidlist(A) ::= nm(Y) collate(C) sortorder(Z). {
  A = parserAddExprIdListTerm(pParse, 0, &Y, C, Z); /*A-overwrites-Y*/
}

%type collate {int}
collate(C) ::= .              {C = 0;}
%ifndef SQLITE_BUILDING_FOR_COMDB2
collate(C) ::= COLLATE ids.   {C = 1;}
%endif !SQLITE_BUILDING_FOR_COMDB2


///////////////////////////// The DROP INDEX command /////////////////////////
//
%ifdef SQLITE_BUILDING_FOR_COMDB2
cmd ::= dryrun DROP INDEX ifexists(E) nm(X).          {comdb2DropIndex(pParse, &X, 0, E);}
cmd ::= dryrun DROP INDEX ifexists(E) nm(X) ON nm(Y). {comdb2DropIndex(pParse, &X, &Y, E);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
cmd ::= dryrun DROP INDEX ifexists(E) fullname(X).   {sqlite3DropIndex(pParse, X, E);}
%endif !SQLITE_BUILDING_FOR_COMDB2

///////////////////////////// The VACUUM command /////////////////////////////
//
%ifndef SQLITE_OMIT_VACUUM
%ifndef SQLITE_OMIT_ATTACH
%type vinto {Expr*}
%destructor vinto {sqlite3ExprDelete(pParse->db, $$);}
cmd ::= VACUUM vinto(Y).                {sqlite3Vacuum(pParse,0,Y);}
cmd ::= VACUUM nm(X) vinto(Y).          {sqlite3Vacuum(pParse,&X,Y);}
vinto(A) ::= INTO expr(X).              {A = X;}
vinto(A) ::= .                          {A = 0;}
%endif  SQLITE_OMIT_ATTACH
%endif  SQLITE_OMIT_VACUUM

///////////////////////////// The PRAGMA command /////////////////////////////
//
%ifndef SQLITE_OMIT_PRAGMA
cmd ::= PRAGMA nm(X) dbnm(Z).                {sqlite3Pragma(pParse,&X,&Z,0,0);}
cmd ::= PRAGMA nm(X) dbnm(Z) EQ nmnum(Y).    {sqlite3Pragma(pParse,&X,&Z,&Y,0);}
cmd ::= PRAGMA nm(X) dbnm(Z) LP nmnum(Y) RP. {sqlite3Pragma(pParse,&X,&Z,&Y,0);}
cmd ::= PRAGMA nm(X) dbnm(Z) EQ minus_num(Y). 
                                             {sqlite3Pragma(pParse,&X,&Z,&Y,1);}
cmd ::= PRAGMA nm(X) dbnm(Z) LP minus_num(Y) RP.
                                             {sqlite3Pragma(pParse,&X,&Z,&Y,1);}

nmnum(A) ::= plus_num(A).
nmnum(A) ::= nm(A).
nmnum(A) ::= ON(A).
nmnum(A) ::= DELETE(A).
nmnum(A) ::= DEFAULT(A).
%endif SQLITE_OMIT_PRAGMA
%token_class number INTEGER|FLOAT.
plus_num(A) ::= PLUS number(X).       {A = X;}
plus_num(A) ::= number(A).
minus_num(A) ::= MINUS number(X).     {A = X;}
//////////////////////////// The CREATE TRIGGER command /////////////////////

%ifndef SQLITE_OMIT_TRIGGER

cmd ::= dryrun createkw trigger_decl(A) BEGIN trigger_cmd_list(S) END(Z). {
  Token all;
  all.z = A.z;
  all.n = (int)(Z.z - A.z) + Z.n;
  sqlite3FinishTrigger(pParse, S, &all);
}

trigger_decl(A) ::= temp(T) TRIGGER ifnotexists(NOERR) nm(B) dbnm(Z) 
                    trigger_time(C) trigger_event(D)
                    ON fullname(E) foreach_clause when_clause(G). {
  sqlite3BeginTrigger(pParse, &B, &Z, C, D.a, D.b, E, G, T, NOERR);
  A = (Z.n==0?B:Z); /*A-overwrites-T*/
}

%type trigger_time {int}
trigger_time(A) ::= BEFORE|AFTER(X).  { A = @X; /*A-overwrites-X*/ }
trigger_time(A) ::= INSTEAD OF.  { A = TK_INSTEAD;}
trigger_time(A) ::= .            { A = TK_BEFORE; }

%type trigger_event {struct TrigEvent}
%destructor trigger_event {sqlite3IdListDelete(pParse->db, $$.b);}
trigger_event(A) ::= DELETE|INSERT(X).   {A.a = @X; /*A-overwrites-X*/ A.b = 0;}
trigger_event(A) ::= UPDATE(X).          {A.a = @X; /*A-overwrites-X*/ A.b = 0;}
trigger_event(A) ::= UPDATE OF idlist(X).{A.a = TK_UPDATE; A.b = X;}

foreach_clause ::= .
foreach_clause ::= FOR EACH ROW.

%type when_clause {Expr*}
%destructor when_clause {sqlite3ExprDelete(pParse->db, $$);}
when_clause(A) ::= .             { A = 0; }
when_clause(A) ::= WHEN expr(X). { A = X; }

%type trigger_cmd_list {TriggerStep*}
%destructor trigger_cmd_list {sqlite3DeleteTriggerStep(pParse->db, $$);}
trigger_cmd_list(A) ::= trigger_cmd_list(A) trigger_cmd(X) SEMI. {
  assert( A!=0 );
  A->pLast->pNext = X;
  A->pLast = X;
}
trigger_cmd_list(A) ::= trigger_cmd(A) SEMI. { 
  assert( A!=0 );
  A->pLast = A;
}

// Disallow qualified table names on INSERT, UPDATE, and DELETE statements
// within a trigger.  The table to INSERT, UPDATE, or DELETE is always in 
// the same database as the table that the trigger fires on.
//
%type trnm {Token}
trnm(A) ::= nm(A).
trnm(A) ::= nm DOT nm(X). {
  A = X;
  sqlite3ErrorMsg(pParse, 
        "qualified table names are not allowed on INSERT, UPDATE, and DELETE "
        "statements within triggers");
}

// Disallow the INDEX BY and NOT INDEXED clauses on UPDATE and DELETE
// statements within triggers.  We make a specific error message for this
// since it is an exception to the default grammar rules.
//
tridxby ::= .
tridxby ::= INDEXED BY nm. {
  sqlite3ErrorMsg(pParse,
        "the INDEXED BY clause is not allowed on UPDATE or DELETE statements "
        "within triggers");
}
tridxby ::= NOT INDEXED. {
  sqlite3ErrorMsg(pParse,
        "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "
        "within triggers");
}



%type trigger_cmd {TriggerStep*}
%destructor trigger_cmd {sqlite3DeleteTriggerStep(pParse->db, $$);}
// UPDATE 
trigger_cmd(A) ::=
   UPDATE(B) orconf(R) trnm(X) tridxby SET setlist(Y) where_opt(Z) scanpt(E).  
   {A = sqlite3TriggerUpdateStep(pParse, &X, Y, Z, R, B.z, E);}

// INSERT
trigger_cmd(A) ::= scanpt(B) insert_cmd(R) INTO
                      trnm(X) idlist_opt(F) select(S) upsert(U) scanpt(Z). {
   A = sqlite3TriggerInsertStep(pParse,&X,F,S,R,U,B,Z);/*A-overwrites-R*/
}
// DELETE
trigger_cmd(A) ::= DELETE(B) FROM trnm(X) tridxby where_opt(Y) scanpt(E).
   {A = sqlite3TriggerDeleteStep(pParse, &X, Y, B.z, E);}

// SELECT
trigger_cmd(A) ::= scanpt(B) select(X) scanpt(E).
   {A = sqlite3TriggerSelectStep(pParse->db, X, B, E); /*A-overwrites-X*/}

// The special RAISE expression that may occur in trigger programs
expr(A) ::= RAISE LP IGNORE RP.  {
  A = sqlite3PExpr(pParse, TK_RAISE, 0, 0); 
  if( A ){
    A->affinity = OE_Ignore;
  }
}
expr(A) ::= RAISE LP raisetype(T) COMMA nm(Z) RP.  {
  A = sqlite3ExprAlloc(pParse->db, TK_RAISE, &Z, 1); 
  if( A ) {
    A->affinity = (char)T;
  }
}
%endif  !SQLITE_OMIT_TRIGGER

%type raisetype {int}
raisetype(A) ::= ROLLBACK.  {A = OE_Rollback;}
raisetype(A) ::= ABORT.     {A = OE_Abort;}
raisetype(A) ::= FAIL.      {A = OE_Fail;}


////////////////////////  DROP TRIGGER statement //////////////////////////////
%ifndef SQLITE_OMIT_TRIGGER
cmd ::= dryrun DROP TRIGGER ifexists(NOERR) fullname(X). {
  sqlite3DropTrigger(pParse,X,NOERR);
}
%endif  !SQLITE_OMIT_TRIGGER

%ifdef SQLITE_BUILDING_FOR_COMDB2
dryrun ::= DRYRUN.  { pParse->isDryrun = 1; }
dryrun ::= .        { pParse->isDryrun = 0; }
%endif SQLITE_BUILDING_FOR_COMDB2
//////////////////////// ATTACH DATABASE file AS name /////////////////////////
%ifndef SQLITE_OMIT_ATTACH
cmd ::= ATTACH database_kw_opt expr(F) AS expr(D) key_opt(K). {
  sqlite3Attach(pParse, F, D, K);
}
cmd ::= DETACH database_kw_opt expr(D). {
  sqlite3Detach(pParse, D);
}

%type key_opt {Expr*}
%destructor key_opt {sqlite3ExprDelete(pParse->db, $$);}
key_opt(A) ::= .                     { A = 0; }
key_opt(A) ::= KEY expr(X).          { A = X; }

database_kw_opt ::= DATABASE.
database_kw_opt ::= .
%endif SQLITE_OMIT_ATTACH

////////////////////////// REINDEX collation //////////////////////////////////
%ifndef SQLITE_OMIT_REINDEX
cmd ::= REINDEX.                {sqlite3Reindex(pParse, 0, 0);}
cmd ::= REINDEX nm(X) dbnm(Y).  {sqlite3Reindex(pParse, &X, &Y);}
%endif  SQLITE_OMIT_REINDEX

/////////////////////////////////// ANALYZE ///////////////////////////////////
%ifndef SQLITE_OMIT_ANALYZE
%ifdef SQLITE_BUILDING_FOR_COMDB2
cmd ::= ANALYZESQLITE.                {sqlite3Analyze(pParse, 0, 0);}
cmd ::= ANALYZESQLITE nm(X) dbnm(Y).  {sqlite3Analyze(pParse, &X, &Y);}
cmd ::= ANALYZEEXPERT.                {setExpert(pParse); sqlite3Analyze(pParse, 0, 0);}
cmd ::= ANALYZEEXPERT nm(X) dbnm(Y).  {setExpert(pParse); sqlite3Analyze(pParse, &X, &Y);}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
cmd ::= ANALYZE.                {sqlite3Analyze(pParse, 0, 0);}
cmd ::= ANALYZE nm(X) dbnm(Y).  {sqlite3Analyze(pParse, &X, &Y);}
%endif !SQLITE_BUILDING_FOR_COMDB2
%endif

//////////////////////// ALTER TABLE table ... ////////////////////////////////
%ifndef SQLITE_OMIT_ALTERTABLE
%ifdef SQLITE_BUILDING_FOR_COMDB2

constraint_opt ::= .                 { pParse->constraintName.n = 0; }
constraint_opt ::= CONSTRAINT nm(X). { pParse->constraintName = X; }

alter_comma ::= COMMA. {pParse->constraintName.n = 0;}

tconspk ::= PRIMARY KEY LP sortlist(X) autoinc(I) RP onconf(R). {
  comdb2AddPrimaryKey(pParse, X, R, I, 0);
}

tconsfk ::= constraint_opt FOREIGN KEY LP eidlist(FA) RP REFERENCES nm(T)
            LP eidlist(TA) RP refargs(R) defer_subclause_opt(D). {
  comdb2CreateForeignKey(pParse, FA, &T, TA, R);
  comdb2DeferForeignKey(pParse, D);
}

tconscheck ::= constraint_opt CHECK LP scanpt(BW) expr(E) scanpt(AW) RP. {
  comdb2AddCheckConstraint(pParse,E,BW,AW);
}

cmd ::= alter_table_csc2.
cmd ::= alter_table alter_table_action_list. {comdb2AlterTableEnd(pParse);}

alter_table ::= dryrun ALTER TABLE nm(Y) dbnm(Z) . {
  comdb2AlterTableStart(pParse,&Y,&Z);
}

alter_table_csc2 ::= dryrun ALTER TABLE nm(Y) dbnm(Z) comdb2opt(O)
                     NOSQL(C). {
  comdb2AlterTableCSC2(pParse,&Y,&Z,O,&C);
}

alter_table_add_column ::= ADD kwcolumn_opt columnname carglist.
alter_table_drop_column ::= DROP kwcolumn_opt nm(Y). {
  comdb2DropColumn(pParse, &Y);
}

set_data_opt ::= .
set_data_opt ::= SET DATA.

alter_table_alter_column_start ::= ALTER kwcolumn_opt nm(Y). {
  comdb2AlterColumnStart(pParse, &Y);
}

alter_table_alter_column_cmd ::= set_data_opt TYPE typetoken(Y). {
  comdb2AlterColumnType(pParse,&Y);
}
alter_table_alter_column_cmd ::= SET DEFAULT scanpt(A) term(X) scanpt(Z). {
  comdb2AlterColumnSetDefault(pParse,X,A,Z);
}
alter_table_alter_column_cmd ::= DROP DEFAULT. {
  comdb2AlterColumnDropDefault(pParse);
}
alter_table_alter_column_cmd ::= DROP AUTOINCR. {
  comdb2AlterColumnDropAutoIncrement(pParse);
}
alter_table_alter_column_cmd ::= SET NOT NULL. {
  comdb2AlterColumnSetNotNull(pParse);
}
alter_table_alter_column_cmd ::= DROP NOT NULL. {
  comdb2AlterColumnDropNotNull(pParse);
}
alter_table_alter_column ::= alter_table_alter_column_start
                             alter_table_alter_column_cmd. {
  comdb2AlterColumnEnd(pParse);
}

alter_table_add_pk ::= ADD tconspk.
alter_table_drop_pk ::= DROP PRIMARY KEY. {
  comdb2DropPrimaryKey(pParse);
}

alter_table_add_fk ::= ADD tconsfk.
alter_table_drop_fk ::= DROP FOREIGN KEY nm(Y). {
  comdb2DropForeignKey(pParse, &Y);
}
alter_table_add_check_cons ::= ADD tconscheck.
alter_table_drop_cons ::= DROP CONSTRAINT nm(Y). {
  comdb2DropConstraint(pParse, &Y);
}

alter_table_add_index ::= ADD uniqueflag(U) INDEX nm(I) LP sortlist(X) RP
                          with_opt(O) where_opt(W). {
  comdb2AddIndex(pParse, &I, X, 0, W, 0, 0, SQLITE_SO_ASC, (U == OE_Abort) ?
                 SQLITE_IDXTYPE_UNIQUE : SQLITE_IDXTYPE_DUPKEY, O, 0);
}
// datacopy with include syntax
alter_table_add_index ::= ADD uniqueflag(U) INDEX nm(I) LP sortlist(X) RP
                          INCLUDE with_opt2(O) with_inc(P) where_opt(W). {
  comdb2AddIndex(pParse, &I, X, 0, W, 0, 0, SQLITE_SO_ASC, (U == OE_Abort) ?
                 SQLITE_IDXTYPE_UNIQUE : SQLITE_IDXTYPE_DUPKEY, O, P);
}
alter_table_drop_index ::= DROP INDEX nm(I). {
  comdb2AlterDropIndex(pParse, &I);
}
alter_table_commit_pending ::= SET COMMIT PENDING. {
  comdb2AlterCommitPending(pParse);
}

alter_table_partitioned ::= partitioned_by.
alter_table_merge ::= merge_with_alter.

// Even though they make the syntax a bit ugly, the parentheses were
// added to overcome a parer conflict.
alter_table_alter_options ::= ALTER OPTIONS LP comdb2optlist(O) RP. {
  comdb2AlterTableOptions(pParse,O);
}

alter_table_action ::= alter_table_add_column.
alter_table_action ::= alter_table_drop_column.
alter_table_action ::= alter_table_alter_column.
alter_table_action ::= alter_table_add_pk.
alter_table_action ::= alter_table_drop_pk.
alter_table_action ::= alter_table_add_fk.
alter_table_action ::= alter_table_drop_fk.
alter_table_action ::= alter_table_add_check_cons.
alter_table_action ::= alter_table_drop_cons.
alter_table_action ::= alter_table_add_index.
alter_table_action ::= alter_table_drop_index.
alter_table_action ::= alter_table_commit_pending.
alter_table_action ::= alter_table_partitioned.
alter_table_action ::= alter_table_merge.
alter_table_action ::= alter_table_alter_options.

alter_table_action_list ::= DO NOTHING.
alter_table_action_list ::= alter_table_action.
alter_table_action_list ::= alter_table_action_list alter_comma alter_table_action.

cmd ::= dryrun ALTER TABLE nm(X) RENAME TO nm(Y). {
  comdb2WriteTransaction(pParse);
  sqlite3AlterRenameTable(pParse,&X,&Y);
}
%endif SQLITE_BUILDING_FOR_COMDB2
%ifndef SQLITE_BUILDING_FOR_COMDB2
cmd ::= ALTER TABLE fullname(X) RENAME TO nm(Z). {
  sqlite3AlterRenameTable(pParse,X,&Z);
}
cmd ::= ALTER TABLE add_column_fullname
        ADD kwcolumn_opt columnname(Y) carglist. {
  Y.n = (int)(pParse->sLastToken.z-Y.z) + pParse->sLastToken.n;
  sqlite3AlterFinishAddColumn(pParse, &Y);
}
add_column_fullname ::= fullname(X). {
  disableLookaside(pParse);
  sqlite3AlterBeginAddColumn(pParse, X);
}
cmd ::= ALTER TABLE fullname(X) RENAME kwcolumn_opt nm(Y) TO nm(Z). {
  sqlite3AlterRenameColumn(pParse, X, &Y, &Z);
}
%endif !SQLITE_BUILDING_FOR_COMDB2

kwcolumn_opt ::= .
kwcolumn_opt ::= COLUMNKW.

%endif  SQLITE_OMIT_ALTERTABLE

//////////////////////// CREATE VIRTUAL TABLE ... /////////////////////////////
%ifndef SQLITE_OMIT_VIRTUALTABLE
cmd ::= create_vtab.                       {sqlite3VtabFinishParse(pParse,0);}
cmd ::= create_vtab LP vtabarglist RP(X).  {sqlite3VtabFinishParse(pParse,&X);}
create_vtab ::= dryrun createkw VIRTUAL TABLE ifnotexists(E)
                nm(X) dbnm(Y) USING nm(Z). {
    sqlite3VtabBeginParse(pParse, &X, &Y, &Z, E);
}
vtabarglist ::= vtabarg.
vtabarglist ::= vtabarglist COMMA vtabarg.
vtabarg ::= .                       {sqlite3VtabArgInit(pParse);}
vtabarg ::= vtabarg vtabargtoken.
vtabargtoken ::= ANY(X).            {sqlite3VtabArgExtend(pParse,&X);}
vtabargtoken ::= lp anylist RP(X).  {sqlite3VtabArgExtend(pParse,&X);}
lp ::= LP(X).                       {sqlite3VtabArgExtend(pParse,&X);}
anylist ::= .
anylist ::= anylist LP anylist RP.
anylist ::= anylist ANY.
%endif  SQLITE_OMIT_VIRTUALTABLE


//////////////////////// COMMON TABLE EXPRESSIONS ////////////////////////////
%type wqlist {With*}
%destructor wqlist {sqlite3WithDelete(pParse->db, $$);}

with ::= .
%ifndef SQLITE_OMIT_CTE
with ::= WITH wqlist(W).              { sqlite3WithPush(pParse, W, 1); }
with ::= WITH RECURSIVE wqlist(W).    { sqlite3WithPush(pParse, W, 1); }

wqlist(A) ::= nm(X) eidlist_opt(Y) AS LP select(Z) RP. {
  A = sqlite3WithAdd(pParse, 0, &X, Y, Z); /*A-overwrites-X*/
}
wqlist(A) ::= wqlist(A) COMMA nm(X) eidlist_opt(Y) AS LP select(Z) RP. {
  A = sqlite3WithAdd(pParse, A, &X, Y, Z);
}
%endif  SQLITE_OMIT_CTE

////////////////////////// COMDB2 SYNTAX EXTENSIONS ///////////////////////////
// These rules are used to support the syntax extensions provided by COMDB2.
%ifdef SQLITE_BUILDING_FOR_COMDB2
//////////////////////////////// EXEC / EXECUTE ///////////////////////////////
cmd ::= EXEC sproccmd.
cmd ::= EXECUTE sproccmd.

exec_proc_arg ::= NULL|FLOAT|BLOB|STRING|INTEGER.
exec_proc_arg_list ::= exec_proc_arg.
exec_proc_arg_list ::= exec_proc_arg_list COMMA exec_proc_arg.

sproccmd ::= PROCEDURE ids LP exec_proc_arg_list RP.

////////////////////////////////// GET / PUT //////////////////////////////////
cmd ::= GET getcmd.

getcmd ::= ALIAS nm(U). {
    comdb2getAlias(pParse, &U);
}

getcmd ::= KW. {
    comdb2getkw(pParse, KW_ALL);
}

getcmd ::= RESERVED KW. {
    comdb2getkw(pParse, KW_RES);
}

getcmd ::= NOT RESERVED KW. {
    comdb2getkw(pParse, KW_FB);
}

getcmd ::= ANALYZE COVERAGE nm(Y) dbnm(Z). {
    comdb2getAnalyzeCoverage(pParse,&Y,&Z);
}

getcmd ::= ANALYZE THRESHOLD nm(Y) dbnm(Z). {
    comdb2getAnalyzeThreshold(pParse,&Y,&Z);
}

///////////////////////////////////// PUT /////////////////////////////////////

cmd ::= PUT putcmd. {
    comdb2WriteTransaction(pParse);
}

putcmd ::= ANALYZE COVERAGE nm(Y) dbnm(Z) INTEGER(F). {
    int tmp;
    if (!readIntFromToken(&F, &tmp))
        tmp = 0;

    comdb2analyzeCoverage(pParse,&Y,&Z,tmp);
}

putcmd ::= GENID48 ENABLE. {
    comdb2enableGenid48(pParse, 1);
}

putcmd ::= GENID48 DISABLE. {
    comdb2enableGenid48(pParse, 0);
}

putcmd ::= ROWLOCKS ENABLE. {
    comdb2enableRowlocks(pParse, 1);
}

putcmd ::= ROWLOCKS DISABLE. {
    comdb2enableRowlocks(pParse, 0);
}

putcmd ::= ANALYZE THRESHOLD nm(Y) dbnm(Z) INTEGER(F). {
    int tmp;
    if (!readIntFromToken(&F, &tmp))
        tmp = 0;
    comdb2analyzeThreshold(pParse,&Y,&Z, tmp);
}

putcmd ::= SKIPSCAN ENABLE nm(Y) dbnm(Z). {
    comdb2setSkipscan(pParse,&Y, &Z, 1);
}

putcmd ::= SKIPSCAN DISABLE nm(Y) dbnm(Z). {
    comdb2setSkipscan(pParse,&Y, &Z, 0);
}

putcmd ::= DEFAULT PROCEDURE nm(N) INTEGER(V). {
    comdb2DefaultProcedure(pParse,&N,&V,0);
}

putcmd ::= DEFAULT PROCEDURE nm(N) STRING(V). {
    comdb2DefaultProcedure(pParse,&N,&V,1);
}

putcmd ::= ALIAS nm(Y) nm(U). {
    comdb2setAlias(pParse,&Y,&U);
}

putcmd ::= PASSWORD OFF FOR nm(N). {
    comdb2deletePassword(pParse, &N);
}

putcmd ::= PASSWORD STRING(P) FOR nm(N). {
    comdb2setPassword(pParse, &P, &N);
}

putcmd ::= AUTHENTICATION ON. {
    comdb2enableAuth(pParse, 1);
}

putcmd ::= AUTHENTICATION OFF. {
    comdb2enableAuth(pParse, 0);
}

putcmd ::= TIME PARTITION nm(Y) dbnm(Z) RETENTION  INTEGER(R). {
    int tmp;
    if (!readIntFromToken(&R, &tmp))
        tmp = 0;
    comdb2timepartRetention(pParse, &Y, &Z, tmp);
}

putcmd ::= COUNTER nm(Y) dbnm(Z) INCREMENT. {
    comdb2CounterIncr(pParse, &Y, &Z);
}

putcmd ::= COUNTER nm(Y) dbnm(Z) SET INTEGER(R). {
    int tmp;
    if (!readIntFromToken(&R, &tmp))
        tmp = INT_MAX;
    comdb2CounterSet(pParse, &Y, &Z, tmp);
}

putcmd ::= SCHEMACHANGE COMMITSLEEP INTEGER(F). {
    int tmp;
    if (!readIntFromToken(&F, &tmp))
        tmp = 0;
    comdb2schemachangeCommitsleep(pParse, tmp);
}

putcmd ::= SCHEMACHANGE CONVERTSLEEP INTEGER(F). {
    int tmp;
    if (!readIntFromToken(&F, &tmp))
        tmp = 0;
    comdb2schemachangeConvertsleep(pParse, tmp);
}

tunable_value ::= INTEGER.
tunable_value(V) ::= MINUS number(N). {
    Token t;
    char *z = sqlite3DbMallocRawNN(pParse->db, N.n+1);
    t.z = z;
    t.n = N.n+1;
    memcpy(z+1, N.z, N.n);
    z[0] = '-';
    V = t;
}
tunable_value ::= STRING.

opteq ::= .
opteq ::= EQ .
putcmd ::= TUNABLE nm(N) dbnm(M) opteq tunable_value(V). {
    comdb2putTunable(pParse, &N, &M, &V);
}

/////////////////////////////////// REBUILD ///////////////////////////////////

cmd ::= rebuild.

rebuild ::= dryrun REBUILD nm(T) dbnm(X) comdb2opt(O). { /* REBUILD FULL CANNOT BE USED
                                        BECAUSE OF SQLITE SYNTAX */
    comdb2RebuildFull(pParse,&T,&X,O);
}

rebuild ::= dryrun REBUILD INDEX nm(T) dbnm(Y) nm(X) comdb2opt(O). {
    comdb2RebuildIndex(pParse, &T,&Y,&X,O);
}

rebuild ::= dryrun REBUILD DATA nm(T) dbnm(X) comdb2opt(O). {
    comdb2RebuildData(pParse, &T, &X, O);
}

rebuild ::= dryrun REBUILD DATABLOB nm(N) dbnm(X) comdb2opt(O). {
    comdb2RebuildDataBlob(pParse,&N, &X, O);
}

//////////////////////////// SCHEMA CHANGE CONTROL ////////////////////////////

cmd ::= scctrl.

%type scaction {int}
scaction(A) ::= PAUSE. { A = SC_ACTION_PAUSE; }
scaction(A) ::= RESUME. { A = SC_ACTION_RESUME; }
scaction(A) ::= COMMIT. { A = SC_ACTION_COMMIT; }
scaction(A) ::= ABORT. { A = SC_ACTION_ABORT; }

scctrl ::= SCHEMACHANGE scaction(A) nm(T) dbnm(X). {
    comdb2SchemachangeControl(pParse,A,&T,&X);
}

/////////////////////////////////// GRANT /////////////////////////////////////

%type sql_permission {int}
sql_permission(A) ::= READ. { A = AUTH_READ; }
sql_permission(A) ::= WRITE.{ A = AUTH_WRITE;}
sql_permission(A) ::= DDL.  { A = AUTH_OP;}

%type op_permission{int}
op_permission(A) ::= OP.   { A = AUTH_OP;   }

%type userschema{int}
userschema(A) ::= USERSCHEMA. {A = AUTH_USERSCHEMA;}

cmd ::= GRANT sql_permission(P) ON nm(T) dbnm(Y) TO nm(U). {
    comdb2WriteTransaction(pParse);
    comdb2grant(pParse, 0, P, &T,&Y,&U);
}

cmd ::= GRANT op_permission(P) TO nm(U). {
    comdb2WriteTransaction(pParse);
    comdb2grant(pParse, 0, P, NULL,NULL,&U);
}

cmd ::= GRANT userschema(P) nm(U1) TO nm(U2). {
    comdb2WriteTransaction(pParse);
    comdb2grant(pParse, 0, P, &U1,NULL,&U2);
}

/////////////////////////////////// REVOKE ////////////////////////////////////

cmd ::= REVOKE sql_permission(P) ON nm(T) dbnm(Y) TO|FROM nm(U). {
    comdb2WriteTransaction(pParse);
    comdb2grant(pParse, 1, P, &T,&Y,&U);
}

cmd ::= REVOKE op_permission(P) TO|FROM nm(U). {
    comdb2WriteTransaction(pParse);
    comdb2grant(pParse, 1, P, NULL,NULL,&U);
}

cmd ::= REVOKE userschema(P) nm(U1) TO|FROM nm(U2). {
    comdb2WriteTransaction(pParse);
    comdb2grant(pParse, 1, P, &U1,NULL,&U2);
}

/////////////////////////////// TRUNCATE TABLE ////////////////////////////////

table_opt ::= .
table_opt ::= TABLE.

cmd ::= dryrun TRUNCATE table_opt nm(T) dbnm(Y). {
    comdb2Truncate(pParse, &T, &Y);
}

cmd ::= BULKIMPORT nm(A) DOT nm(B) nm(C) DOT nm(D). {
    comdb2bulkimport(pParse, &A, &B, &C, &D);
}

////////////////////////////// CREATE PARTITION ///////////////////////////////

cmd ::= dryrun createkw RANGE PARTITION ON nm(A) WHERE columnname(B) IN LP exprlist(C) RP. {
    comdb2CreateRangePartition(pParse, &A, &B, C);
}

cmd ::= dryrun createkw partition_type PARTITION ON nm(A) AS nm(P) PERIOD STRING(D) RETENTION INTEGER(R) START STRING(S). {
    comdb2WriteTransaction(pParse);
    comdb2CreatePartition(pParse, &A, &P, &D, &R, &S);
}

partition_type ::= .
partition_type ::= TIME.

/////////////////////////////// DROP PARTITION ////////////////////////////////

cmd ::= dryrun DROP TIME PARTITION nm(N). {
    comdb2WriteTransaction(pParse);
    comdb2DropPartition(pParse, &N);
}

/////////////////////////////////// ANALYZE ///////////////////////////////////

cmd ::= ANALYZE nm(N) dbnm(Y) analyzepercentage(P) analyzeopt(X). {
    comdb2analyze(pParse, X, &N, &Y, P);
}

cmd ::= ANALYZE ALL analyzepercentage(P) analyzeopt(X). {
    comdb2analyze(pParse, X, NULL, NULL, P);
}

cmd ::= ANALYZE analyzepercentage(P) analyzeopt(X). {
    comdb2analyze(pParse, X, NULL, NULL, P);
}

%type analyzepercentage {int}
analyzepercentage(A) ::= . {A = 0;}
analyzepercentage(A) ::= INTEGER(X). {
    if (!readIntFromToken(&X, &(A)))
        A = 0;

}

%type analyzeopt {int}
analyzeopt(A) ::= . { A = 0;}
analyzeopt(A) ::= OPTIONS analyzeoptlst(X). {A=X;}

%type analyzeoptlst {int}
analyzeoptlst(A) ::= analyze_thds(L) COMMA analyze_sumthds(R). {A = L + R;}
analyzeoptlst(A) ::= analyze_sumthds(L) COMMA analyze_thds(R). {A = L + R;}
analyzeoptlst(A) ::= analyze_thds(X). {A = X;}
analyzeoptlst(A) ::= analyze_sumthds(X). {A = X;}

%type analyze_thds {int}
analyze_thds(A) ::= THREADS INTEGER(X). {
    int tmp;
    A = 0;
    if (!readIntFromToken(&X, &(tmp)))
        SET_ANALYZE_THREAD(A,0);

    SET_ANALYZE_THREAD(A,tmp);
}

%type analyze_sumthds {int}
analyze_sumthds(A) ::= SUMMARIZE INTEGER(X). {
    int tmp;
    A = 0;
    if (!readIntFromToken(&X, &(tmp)))
        SET_ANALYZE_SUMTHREAD(A, 0);
    SET_ANALYZE_SUMTHREAD(A,tmp);
}

//////////////////////////////// REBUILD TABLE ////////////////////////////////

%type comdb2opt {int}
comdb2opt(A) ::= . {A = 0;}
comdb2opt(A) ::= OPTIONS comdb2optlist(X). {A = X;}
%type comdb2optlist {int}
comdb2optlist(A) ::= comdb2optlist(X) COMMA comdb2optfield(O). {
    A = X | O;
}
comdb2optlist(A) ::= comdb2optfield(O). {
    A = O;
}
%type comdb2optfield {int}
comdb2optfield(A) ::= odh(O). {A = O;}
comdb2optfield(A) ::= ipu(I). {A = I;}
comdb2optfield(A) ::= isc(S). {A = S;}
comdb2optfield(A) ::= FORCE. {A = FORCE_SC;}
comdb2optfield(A) ::= PAGEORDER. {A = PAGE_ORDER;}
comdb2optfield(A) ::= READONLY. {A = READ_ONLY;}
comdb2optfield(A) ::= compress_blob(C). {A = C;}
comdb2optfield(A) ::= compress_rec(C). {A = C;}

%type odh {int}
odh(A) ::= ODH OFF. {A = ODH_OFF;}
odh(A) ::= ODH ON.  {A = ODH_ON;}

%type ipu {int}
ipu(A) ::= IPU OFF. {A = IPU_OFF;}
ipu(A) ::= IPU ON.  {A = IPU_ON;}

%type isc {int}
isc(A) ::= ISC OFF. {A = ISC_OFF;}
isc(A) ::= ISC ON.  {A = ISC_ON;}

%type compress_blob {int}
compress_blob(A) ::= BLOBFIELD blob_compress_type(T). { A = T;}

%type blob_compress_type {int}
blob_compress_type(A) ::= NONE. {A = BLOB_NONE;}
blob_compress_type(A) ::= RLE. {A = BLOB_RLE;}
//blob_compress_type(A) ::= CRLE. {A = BLOB_CRLE;}
blob_compress_type(A) ::= ZLIB. {A = BLOB_ZLIB;}
blob_compress_type(A) ::= LZ4. {A = BLOB_LZ4;}

%type compress_rec {int}
compress_rec(A) ::= REC rle_compress_type(T). {A = T;}

%type rle_compress_type {int}
rle_compress_type(A) ::= NONE. {A = REC_NONE;}
rle_compress_type(A) ::= RLE. {A = REC_RLE;}
rle_compress_type(A) ::= CRLE. {A = REC_CRLE;}
rle_compress_type(A) ::= ZLIB. {A = REC_ZLIB;}
rle_compress_type(A) ::= LZ4. {A = REC_LZ4;}

////////////////////////////// CREATE PROCEDURE ///////////////////////////////

cmd ::= dryrun CREATE PROCEDURE nm(N) NOSQL(X). {
    comdb2CreateProcedure(pParse, &N, NULL, &X);
}
cmd ::= dryrun CREATE PROCEDURE nm(N) VERSION STRING(V) NOSQL(X). {
    comdb2CreateProcedure(pParse, &N, &V, &X);
}

/////////////////////////////// DROP PROCEDURE ////////////////////////////////

cmd ::= dryrun DROP PROCEDURE nm(N) INTEGER(V). {
    comdb2DropProcedure(pParse, &N, &V, 0);
}
cmd ::= dryrun DROP PROCEDURE nm(N) VERSION INTEGER(V). {
    comdb2DropProcedure(pParse, &N, &V, 0);
}
cmd ::= dryrun DROP PROCEDURE nm(N) STRING(V). {
    comdb2DropProcedure(pParse, &N, &V, 1);
}
cmd ::= dryrun DROP PROCEDURE nm(N) VERSION STRING(V). {
    comdb2DropProcedure(pParse, &N, &V, 1);
}

///////////////////////////////// CREATE LUA //////////////////////////////////

%type sfuncattr {int}

sfuncattr(A) ::= DETERMINISTIC.          {A = SQLITE_FUNC_CONSTANT;}
sfuncattr(A) ::= .                       {A = 0;}

cmd ::= dryrun CREATE LUA SCALAR FUNCTION nm(Q) sfuncattr(A). {
	comdb2CreateScalarFunc(pParse, &Q, A);
}

cmd ::= dryrun CREATE LUA AGGREGATE FUNCTION nm(Q). {
	comdb2CreateAggFunc(pParse, &Q);
}

cmd ::= dryrun CREATE trigger(T) nm(Q) withsequence(S) ON table_trigger_event(E). {
  comdb2CreateTrigger(pParse,T,S,&Q,E);
}

%type trigger {int}
trigger(A) ::= LUA TRIGGER. { A = 0; }
trigger(A) ::= LUA CONSUMER. { A = 1; }
trigger(A) ::= DEFAULT LUA CONSUMER. { A = 2; }

table_trigger_event(A) ::= table_trigger_event(B) COMMA LP TABLE fullname(T) FOR trigger_events(C) RP. {
  A = comdb2AddTriggerTable(pParse,B,T,C);
}

table_trigger_event(A) ::= LP TABLE fullname(T) FOR trigger_events(B) RP. {
  A = comdb2AddTriggerTable(pParse,0,T,B);
}

%type withsequence {int}
withsequence(A) ::= .                   { A = -1; }
withsequence(A) ::= WITHOUT SEQUENCE.   { A = 0; }
withsequence(A) ::= WITH SEQUENCE.      { A = 1; }

%type table_trigger_event {Cdb2TrigTables*}
%destructor table_trigger_event {sqlite3DbFree(pParse->db, $$);}

%type cdb2_trigger_event {Cdb2TrigEvent}
%destructor cdb2_trigger_event {sqlite3IdListDelete(pParse->db, $$.cols);}

%type trigger_events {Cdb2TrigEvents*}
%destructor trigger_events {sqlite3DbFree(pParse->db, $$);}

trigger_events(A) ::= trigger_events(B) AND cdb2_trigger_event(C). {
  A = comdb2AddTriggerEvent(pParse,B,&C);
}
trigger_events(A) ::= cdb2_trigger_event(B). {
  A = comdb2AddTriggerEvent(pParse,0,&B);
}
cdb2_trigger_event(A) ::= DELETE. {
  A.op = TK_DELETE;
  A.cols = 0;
}
cdb2_trigger_event(A) ::= INSERT. {
  A.op = TK_INSERT;
  A.cols = 0;
}
cdb2_trigger_event(A) ::= UPDATE. {
  A.op = TK_UPDATE;
  A.cols = 0;
}
cdb2_trigger_event(A) ::= DELETE OF idlist(X). {
  A.op = TK_DELETE;
  A.cols = X;
}
cdb2_trigger_event(A) ::= INSERT OF idlist(X). {
  A.op = TK_INSERT;
  A.cols = X;
}
cdb2_trigger_event(A) ::= UPDATE OF idlist(X). {
  A.op = TK_UPDATE;
  A.cols = X;
}

////////////////////////////////// DROP LUA ///////////////////////////////////

cmd ::= dryrun DROP LUA SCALAR FUNCTION nm(A). {
  comdb2DropScalarFunc(pParse,&A);
}
cmd ::= dryrun DROP LUA AGGREGATE FUNCTION nm(A). {
  comdb2DropAggFunc(pParse,&A);
}
cmd ::= dryrun DROP LUA TRIGGER nm(A). {
  comdb2DropTrigger(pParse,0,&A);
}
cmd ::= dryrun DROP LUA CONSUMER nm(A). {
  comdb2DropTrigger(pParse,1,&A);
}
%endif SQLITE_BUILDING_FOR_COMDB2

//////////////////////// WINDOW FUNCTION EXPRESSIONS /////////////////////////
// These must be at the end of this file. Specifically, the rules that
// introduce tokens WINDOW, OVER and FILTER must appear last. This causes 
// the integer values assigned to these tokens to be larger than all other 
// tokens that may be output by the tokenizer except TK_SPACE and TK_ILLEGAL.
//
%ifndef SQLITE_OMIT_WINDOWFUNC
%type windowdefn_list {Window*}
%destructor windowdefn_list {sqlite3WindowListDelete(pParse->db, $$);}
windowdefn_list(A) ::= windowdefn(Z). { A = Z; }
windowdefn_list(A) ::= windowdefn_list(Y) COMMA windowdefn(Z). {
  assert( Z!=0 );
  sqlite3WindowChain(pParse, Z, Y);
  Z->pNextWin = Y;
  A = Z;
}

%type windowdefn {Window*}
%destructor windowdefn {sqlite3WindowDelete(pParse->db, $$);}
windowdefn(A) ::= nm(X) AS LP window(Y) RP. {
  if( ALWAYS(Y) ){
    Y->zName = sqlite3DbStrNDup(pParse->db, X.z, X.n);
  }
  A = Y;
}

%type window {Window*}
%destructor window {sqlite3WindowDelete(pParse->db, $$);}

%type frame_opt {Window*}
%destructor frame_opt {sqlite3WindowDelete(pParse->db, $$);}

%type part_opt {ExprList*}
%destructor part_opt {sqlite3ExprListDelete(pParse->db, $$);}

%type filter_opt {Expr*}
%destructor filter_opt {sqlite3ExprDelete(pParse->db, $$);}

%type range_or_rows {int}

%type frame_bound {struct FrameBound}
%destructor frame_bound {sqlite3ExprDelete(pParse->db, $$.pExpr);}
%type frame_bound_s {struct FrameBound}
%destructor frame_bound_s {sqlite3ExprDelete(pParse->db, $$.pExpr);}
%type frame_bound_e {struct FrameBound}
%destructor frame_bound_e {sqlite3ExprDelete(pParse->db, $$.pExpr);}

window(A) ::= PARTITION BY nexprlist(X) orderby_opt(Y) frame_opt(Z). {
  A = sqlite3WindowAssemble(pParse, Z, X, Y, 0);
}
window(A) ::= nm(W) PARTITION BY nexprlist(X) orderby_opt(Y) frame_opt(Z). {
  A = sqlite3WindowAssemble(pParse, Z, X, Y, &W);
}
window(A) ::= ORDER BY sortlist(Y) frame_opt(Z). {
  A = sqlite3WindowAssemble(pParse, Z, 0, Y, 0);
}
window(A) ::= nm(W) ORDER BY sortlist(Y) frame_opt(Z). {
  A = sqlite3WindowAssemble(pParse, Z, 0, Y, &W);
}
window(A) ::= frame_opt(Z). {
  A = Z;
}
window(A) ::= nm(W) frame_opt(Z). {
  A = sqlite3WindowAssemble(pParse, Z, 0, 0, &W);
}

frame_opt(A) ::= .                             { 
  A = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0);
}
frame_opt(A) ::= range_or_rows(X) frame_bound_s(Y) frame_exclude_opt(Z). { 
  A = sqlite3WindowAlloc(pParse, X, Y.eType, Y.pExpr, TK_CURRENT, 0, Z);
}
frame_opt(A) ::= range_or_rows(X) BETWEEN frame_bound_s(Y) AND
                          frame_bound_e(Z) frame_exclude_opt(W). { 
  A = sqlite3WindowAlloc(pParse, X, Y.eType, Y.pExpr, Z.eType, Z.pExpr, W);
}

range_or_rows(A) ::= RANGE|ROWS|GROUPS(X).   {A = @X; /*A-overwrites-X*/}

frame_bound_s(A) ::= frame_bound(X).         {A = X;}
frame_bound_s(A) ::= UNBOUNDED(X) PRECEDING. {A.eType = @X; A.pExpr = 0;}
frame_bound_e(A) ::= frame_bound(X).         {A = X;}
frame_bound_e(A) ::= UNBOUNDED(X) FOLLOWING. {A.eType = @X; A.pExpr = 0;}

frame_bound(A) ::= expr(X) PRECEDING|FOLLOWING(Y).
                                             {A.eType = @Y; A.pExpr = X;}
frame_bound(A) ::= CURRENT(X) ROW.           {A.eType = @X; A.pExpr = 0;}

%type frame_exclude_opt {u8}
frame_exclude_opt(A) ::= . {A = 0;}
frame_exclude_opt(A) ::= EXCLUDE frame_exclude(X). {A = X;}

%type frame_exclude {u8}
frame_exclude(A) ::= NO(X) OTHERS.   {A = @X; /*A-overwrites-X*/}
frame_exclude(A) ::= CURRENT(X) ROW. {A = @X; /*A-overwrites-X*/}
frame_exclude(A) ::= GROUP|TIES(X).  {A = @X; /*A-overwrites-X*/}


%type window_clause {Window*}
%destructor window_clause {sqlite3WindowListDelete(pParse->db, $$);}
window_clause(A) ::= WINDOW windowdefn_list(B). { A = B; }

%type over_clause {Window*}
%destructor over_clause {sqlite3WindowDelete(pParse->db, $$);}
over_clause(A) ::= filter_opt(W) OVER LP window(Z) RP. {
  A = Z;
  assert( A!=0 );
  A->pFilter = W;
}
over_clause(A) ::= filter_opt(W) OVER nm(Z). {
  A = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
  if( A ){
    A->zName = sqlite3DbStrNDup(pParse->db, Z.z, Z.n);
    A->pFilter = W;
  }else{
    sqlite3ExprDelete(pParse->db, W);
  }
}

filter_opt(A) ::= .                            { A = 0; }
filter_opt(A) ::= FILTER LP WHERE expr(X) RP.  { A = X; }
%endif /* SQLITE_OMIT_WINDOWFUNC */

/*
** The code generator needs some extra TK_ token values for tokens that
** are synthesized and do not actually appear in the grammar:
*/
%token
  TRUEFALSE       /* True or false keyword */
  ISNOT           /* Combination of IS and NOT */
  FUNCTION        /* A function invocation */
  COLUMN          /* Reference to a table column */
  AGG_FUNCTION    /* An aggregate function */
  AGG_COLUMN      /* An aggregated column */
  UMINUS          /* Unary minus */
  UPLUS           /* Unary plus */
  TRUTH           /* IS TRUE or IS FALSE or IS NOT TRUE or IS NOT FALSE */
  REGISTER        /* Reference to a VDBE register */
  VECTOR          /* Vector */
  SELECT_COLUMN   /* Choose a single column from a multi-column SELECT */
  IF_NULL_ROW     /* the if-null-row operator */
  ASTERISK        /* The "*" in count(*) and similar */
  SPAN            /* The span operator */
%ifdef SQLITE_BUILDING_FOR_COMDB2
  TO_TEXT
  TO_DATETIME
  TO_INTERVAL_YE
  TO_INTERVAL_MO
  TO_INTERVAL_DY
  TO_INTERVAL_HO
  TO_INTERVAL_MI
  TO_INTERVAL_SE
  TO_BLOB
  TO_NUMERIC
  TO_INT
  TO_REAL
  TO_DECIMAL
%endif SQLITE_BUILDING_FOR_COMDB2
.
/* There must be no more than 255 tokens defined above.  If this grammar
** is extended with new rules and tokens, they must either be so few in
** number that TK_SPAN is no more than 255, or else the new tokens must
** appear after this line.
*/
%include {
#if TK_SPAN>255
# error too many tokens in the grammar
#endif
}

/*
** The TK_SPACE and TK_ILLEGAL tokens must be the last two tokens.  The
** parser depends on this.  Those tokens are not used in any grammar rule.
** They are only used by the tokenizer.  Declare them last so that they
** are guaranteed to be the last two tokens
*/
%token SPACE ILLEGAL.
