###############################################################################
#
#   Copyright 2015 Bloomberg Finance L.P.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
###############################################################################

if {[lsearch [namespace children] ::tcltest] == -1} then {
  package require tcltest
  namespace import ::tcltest::*
}

set path [file normalize [file dirname [info script]]]
package require tclcdb2

###############################################################################

if {[llength [info commands getEnvVar]] == 0} then {
  proc getEnvVar { name {default ""} } {
    if {![info exists ::env($name)]} then {
      if {![info exists ::warn($name)]} then {
        tcltest::Warn [appendArgs \
            "missing environment variable \"" $name \
            "\", using default \"" $default \"...]

        set ::warn($name) 1
      }

      return $default
    }

    return $::env($name)
  }
}

###############################################################################

if {[llength [info commands normalizeResult]] == 0} then {
  proc normalizeResult { result } {
    if {[regexp -- {^cdb2_(?:0x)?[0-9A-Fa-f]+$} $result]} then {
      return <connection_open>
    }

    if {[regexp -- {^connection ".*?" not found\n$} $result]} then {
      return <connection_not_found>
    }

    regsub -all -- {( baddb_[0-9]+ )} $result { <bad_db> } result

    set wrongNumArgs(open) [string trim {
      wrong # args: should be "cdb2 open dbName ?type? ?flags?"
    }]

    set wrongNumArgs(close) [string trim {
      wrong # args: should be "cdb2 close connection"
    }]

    return [string map [list \
        $wrongNumArgs(open) <wrong_open> \
        $wrongNumArgs(close) <wrong_close>] \
        [string trim $result]]
  }
}

###############################################################################

if {[llength [info commands getDbName]] == 0} then {
  proc getDbName { {name ""} } {
    if {[string length $name] == 0} then {
      set name [getEnvVar TCLCDB2_DB_NAME]
    }

    return $name
  }
}

###############################################################################

if {[llength [info commands openConnection]] == 0} then {
  proc openConnection { {name ""} {flags ""} } {
    set command [list cdb2 open [getDbName $name] local]

    if {[string length $flags] > 0} then {
      lappend command $flags
    }

    return [eval $command]
  }
}

###############################################################################

if {[llength [info commands closeConnection]] == 0} then {
  proc closeConnection { connection } {
    if {[catch {cdb2 close $connection} error]} then {
      tcltest::Warn [appendArgs \
          "could not close database connection \"" \
          $connection "\": " $error]
    }
  }
}

###############################################################################

test cdb2-1.1 {overall command usage} -body {
  list [catch {cdb2} errMsg] $errMsg
} -cleanup {
  unset -nocomplain errMsg
} -result {1 {wrong # args: should be "cdb2 option ?arg ...?"}}

###############################################################################

test cdb2-2.1 {ssl sub-command} -body {
  list [catch {cdb2 ssl} errMsg] $errMsg \
      [catch {cdb2 ssl 1} errMsg] $errMsg \
      [catch {cdb2 ssl 1 1}  errMsg] $errMsg \
      [catch {cdb2 ssl 1 1 1} errMsg] $errMsg
} -cleanup {
  unset -nocomplain errMsg
} -result {1 {wrong # args: should be "cdb2 ssl initSsl initCrypto"} 1 {wrong\
# args: should be "cdb2 ssl initSsl initCrypto"} 0 {} 1 {wrong # args: should\
be "cdb2 ssl initSsl initCrypto"}}

###############################################################################

test cdb2-3.1 {open & close sub-commands} -body {
  list [catch {
        cdb2 open
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open baddb_[pid] local
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName]
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1) 1
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 close
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 close
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local 0
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local read_intrans_results
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local {0 read_intrans_results}
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local {random read_intrans_results}
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local {bad read_intrans_results}
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)]
} -cleanup {
  unset -nocomplain result
} -result {1 <wrong_open> 1 <connection_not_found> 1 {cdb2_get_dbhosts: can't\
do dbinfo query on <bad_db> hosts} 1 <connection_not_found> 0 <connection_open>\
1 <wrong_close> 1 <wrong_close> 0 {} 1 <connection_not_found> 1 <wrong_close> 0\
<connection_open> 0 {} 0 <connection_open> 0 {} 0 <connection_open> 0 {} 0\
<connection_open> 0 {} 1 "name \"bad\" not found\nvalue for name \"bad\" not\
found" 1 <connection_not_found>}

###############################################################################

test cdb2-4.1 {debug sub-command} -setup {
  set db [openConnection]
} -body {
  list [catch {cdb2 debug} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 debug 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 debug $db}  errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 debug 1 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 debug $db 1}  errMsg] [normalizeResult $errMsg]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg db
} -result {1 {wrong # args: should be "cdb2 debug connection"} 1 {connection\
"1" not found} 0 {} 1 {wrong # args: should be "cdb2 debug connection"} 1\
{wrong # args: should be "cdb2 debug connection"}}

###############################################################################

if {0} then {
  #
  # TODO: Test the following sub-commands, variations, etc.
  #
  cdb2 bind
  cdb2 cnonce
  cdb2 colcount
  cdb2 colname
  cdb2 colsize
  cdb2 coltype
  cdb2 colvalue
  cdb2 configure
  cdb2 effects
  cdb2 encrypted
  cdb2 error
  cdb2 hint
  cdb2 next
  cdb2 run
  cdb2 unbind
}

###############################################################################

unset -nocomplain path
::tcltest::cleanupTests
