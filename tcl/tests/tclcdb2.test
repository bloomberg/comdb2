###############################################################################
#
#   Copyright 2015 Bloomberg Finance L.P.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
###############################################################################

if {[lsearch [namespace children] ::tcltest] == -1} then {
  package require tcltest
  namespace import ::tcltest::*
}

set path [file normalize [file dirname [info script]]]
package require tclcdb2

###############################################################################

if {[llength [info commands appendArgs]] == 0} then {
  proc appendArgs { args } {
    set result ""; eval append result $args
  }
}

###############################################################################

if {[llength [info commands isBinary]] == 0} then {
  proc isBinary { value } {
    return [regexp -- {[^\t\n\v\f\r[:print:]]} $value]
  }
}

###############################################################################

if {[llength [info commands getTempPath]] == 0} then {
  proc getTempPath {} {
    global tcl_platform

    set names [list]

    foreach name [list TMPDIR TEMP TMP] {
      lappend names \
          [string toupper $name] \
          [string tolower $name] \
          [string totitle $name]
    }

    foreach name $names {
      set value [getEnvVar $name]

      if {[string length $value] > 0} then {
        return [file normalize $value]
      }
    }

    if {[info exists tcl_platform(platform)]} then {
      if {$tcl_platform(platform) ne "windows"} then {
        return /tmp; # TODO: Good default on Unix?
      }
    }

    error "no temporary path is available"
  }
}

###############################################################################

if {[llength [info commands writeFile]] == 0} then {
  proc writeFile { fileName data } {
    set channel [open $fileName {WRONLY CREAT TRUNC}]
    fconfigure $channel -encoding binary -translation binary
    puts -nonewline $channel $data
    close $channel
    return ""
  }
}

###############################################################################

if {[llength [info commands hexList]] == 0} then {
  proc hexList { value } {
    set result ""
    set length [string length $value]

    for {set index 0} {$index < $length} {incr index} {
      if {$index > 0} then {append result " "}
      scan [string index $value $index] %c ordinal
      append result 0x [format %02X $ordinal]
    }

    return $result
  }
}

###############################################################################

if {[llength [info commands getEnvVar]] == 0} then {
  proc getEnvVar { name {default ""} } {
    if {![info exists ::env($name)]} then {
      if {![info exists ::warn($name)]} then {
        tcltest::Warn [appendArgs \
            "missing environment variable \"" $name \
            "\", using default \"" $default \"...]

        set ::warn($name) 1
      }

      return $default
    }

    return $::env($name)
  }
}

###############################################################################

if {[llength [info commands normalizeResult]] == 0} then {
  proc normalizeResult { result {name ""} } {
    if {[regexp -- {^cdb2_(?:0x)?[0-9A-Fa-f]+$} $result]} then {
      return <connection_open>
    }

    if {[regexp -- {^connection ".*?" not found\n$} $result]} then {
      return <connection_not_found>
    }

    if {[regexp -- {^cdb2_get_dbhosts: .*?$} $result]} then {
      return <get_dbhosts_error>
    }

    set percentD {(?:-)?[0-9]{1,10}}

    set pattern [appendArgs \
        ^ $percentD - $percentD - $percentD - $percentD \$]

    if {[regexp -- $pattern $result]} then {
      return <cnonce>
    }

    regsub -all -- {( baddb_[0-9]+ )} $result { <bad_db> } result

    set wrongNumArgs(open) [string trim {
      wrong # args: should be "cdb2 open dbName ?type? ?flags?"
    }]

    set wrongNumArgs(close) [string trim {
      wrong # args: should be "cdb2 close connection"
    }]

    return [string map [list \
        [getDbName $name] <dbName> \
        $wrongNumArgs(open) <wrong_open> \
        $wrongNumArgs(close) <wrong_close> \
        \r\n <crLf> \r <cr> \n <lf>] \
        [string trim $result]]
  }
}

###############################################################################

if {[llength [info commands getColumns]] == 0} then {
  proc getColumns { connection {nullValue <null>} } {
    set result [list]

    for {set index 0} {$index < [cdb2 colcount $connection]} {incr index} {
      tclcdb2::getNullableValue $connection $index null value

      if {$null} then {
        set value $nullValue
      } elseif {[info exists value]} then {
        if {[isBinary $value]} then {
          set value [hexList $value]
        }
      } else {
        error [appendArgs \
            "missing non-NULL value for column " $index]
      }

      lappend result [list index $index \
          type [cdb2 coltype $connection $index] \
          size [cdb2 colsize $connection $index] \
          name [cdb2 colname $connection $index] \
          null $null value $value]
    }

    return $result
  }
}

###############################################################################

if {[llength [info commands getValues]] == 0} then {
  proc getValues { connection index {omitNulls false} {nullValue <null>} } {
    set result [list]

    while {[cdb2 next $connection]} {
      tclcdb2::getNullableValue $connection $index null value

      if {$null} then {
        if {!$omitNulls} then {
          lappend result $nullValue
        }
      } elseif {[info exists value]} then {
        if {[isBinary $value]} then {
          lappend result [hexList $value]
        } else {
          lappend result $value
        }
      } else {
        error [appendArgs \
            "missing non-NULL value for column " $index]
      }
    }

    return $result
  }
}

###############################################################################

if {[llength [info commands getRowsOfColumns]] == 0} then {
  proc getRowsOfColumns { connection } {
    set result [list]
    set index 0

    while {[cdb2 next $connection]} {
      lappend result index [incr index] \
          columns [getColumns $connection]
    }

    lappend result effects [cdb2 effects $connection]

    return $result
  }
}

###############################################################################

if {[llength [info commands getDbName]] == 0} then {
  proc getDbName { {name ""} } {
    if {[string length $name] == 0} then {
      set name [getEnvVar TCLCDB2_DB_NAME]
    }

    return $name
  }
}

###############################################################################

if {[llength [info commands getConfigInfo]] == 0} then {
  proc getConfigInfo { good {name ""} } {
    if {$good} then {
      return [appendArgs \
          [getDbName $name] " " localhost \n \
          comdb2_config:default_type=local]
    } else {
      return [appendArgs \
          [getDbName $name] " " nowhere]
    }
  }
}

###############################################################################

if {[llength [info commands resetConfig]] == 0} then {
  proc resetConfig { {sockPool ""} } {
    #
    # NOTE: First, make sure the configuration buffer and file names are
    #       reset -AND- the cached sockpool FD, if any, if closed.
    #
    cdb2 configure "" false true; # set buffer to NULL -AND- force reset.
    cdb2 configure "" true false; # set file to empty string.

    #
    # NOTE: Finally, if requested by the caller, enable -OR- disable the
    #       sockpool.
    #
    if {[string is true -strict $sockPool]} then {
      cdb2 sockpool true
    } elseif {[string is false -strict $sockPool]} then {
      cdb2 sockpool false
    }
  }
}

###############################################################################

if {[llength [info commands openConnection]] == 0} then {
  proc openConnection { {name ""} {flags ""} } {
    set command [list cdb2 open [getDbName $name] local]

    if {[string length $flags] > 0} then {
      lappend command $flags
    }

    return [eval $command]
  }
}

###############################################################################

if {[llength [info commands getTableName]] == 0} then {
  proc getTableName { name } {
    if {![regexp -nocase -- {[A-Z][0-9A-Z]*} $name]} then {
      error "table name must be alphanumeric and start with a letter"
    }

    return [appendArgs tcl_cdb2_test_ [pid] _ $name]
  }
}

###############################################################################

if {[llength [info commands cleanupDatabase]] == 0} then {
  proc cleanupDatabase {} {
    set connection [openConnection]
    set glob [appendArgs 'tcl_cdb2_test_ [pid] _%']

    set sql [string trim [subst {
      SELECT name FROM sqlite_master WHERE name LIKE $glob
    }]]

    if {[catch {cdb2 run $connection $sql} error] == 0} then {
      set names [list]

      if {[catch {
        while {[cdb2 next $connection]} {
          lappend names [cdb2 colvalue $connection 0]
        }
      } error]} then {
        tcltest::Warn [appendArgs \
            "could not grab table names using connection \"" \
            $connection "\": " $error]
      }

      foreach name $names {
        set sql [subst {DROP TABLE $name}]

        if {[catch {cdb2 run $connection $sql} error]} then {
          tcltest::Warn [appendArgs \
              "could not DROP table \"$name\" using connection \"" \
              $connection "\": " $error]
        }
      }
    } else {
      tcltest::Warn [appendArgs \
          "could not query table names using connection \"" \
          $connection "\": " $error]
    }

    closeConnection $connection
  }
}

###############################################################################

if {[llength [info commands closeConnection]] == 0} then {
  proc closeConnection { connection } {
    if {[catch {cdb2 close $connection} error]} then {
      tcltest::Warn [appendArgs \
          "could not close database connection \"" \
          $connection "\": " $error]
    }
  }
}

###############################################################################

if {[llength [info commands getIntegers]] == 0} then {
  if {0} then {
    -3.402823E+38
    3.402823E+38
    0.0
    NaN
    -Inf
    +Inf
    -1.79769313486232E+308
    1.79769313486232E+308
  }

  proc getIntegers {} {
    return [list \
        -9223372036854775808 -2147483648 -32768 -128 -1 NULL 0 1 127 \
        255 32767 2147483647 9223372036854775807 18446744073709551615]
  }
}

###############################################################################

if {[llength [info commands isTypeError]] == 0} then {
  proc isTypeError { error } {
    return [regexp -- \
        {^incompatible values from .*? for table '.*?'$} $error]
  }
}

###############################################################################

test cdb2-1.1 {overall command usage} -body {
  list [catch {cdb2} errMsg] $errMsg
} -cleanup {
  unset -nocomplain errMsg
} -result {1 {wrong # args: should be "cdb2 option ?arg ...?"}}

###############################################################################

test cdb2-2.1 {ssl sub-command} -body {
  list [catch {cdb2 ssl} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 ssl 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 ssl 1 1}  errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 ssl 1 1 1} errMsg] [normalizeResult $errMsg]
} -cleanup {
  unset -nocomplain errMsg
} -result {1 {wrong # args: should be "cdb2 ssl initSsl initCrypto"} 1 {wrong\
# args: should be "cdb2 ssl initSsl initCrypto"} 0 {} 1 {wrong # args: should\
be "cdb2 ssl initSsl initCrypto"}}

###############################################################################

test cdb2-3.1 {open & close sub-commands} -body {
  list [catch {
        cdb2 open
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open baddb_[pid] local
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1) 1
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 close
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 close
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local 0
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local read_intrans_results
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local {0 read_intrans_results}
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local {random read_intrans_results}
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)] \
      [catch {
        cdb2 open [getDbName] local {bad read_intrans_results}
      } result(1)] [normalizeResult $result(1)] \
      [catch {
        cdb2 close $result(1)
      } result(2)] [normalizeResult $result(2)]
} -cleanup {
  unset -nocomplain result
} -result {1 <wrong_open> 1 <connection_not_found> 1 <get_dbhosts_error> 1\
<connection_not_found> 0 <connection_open> 1 <wrong_close> 1 <wrong_close> 0 {}\
1 <connection_not_found> 1 <wrong_close> 0 <connection_open> 0 {} 0\
<connection_open> 0 {} 0 <connection_open> 0 {} 0 <connection_open> 0 {} 1\
{name "bad" not found<lf>value for name "bad" not found} 1\
<connection_not_found>}

###############################################################################

test cdb2-4.1 {cnonce sub-command} -setup {
  set db [openConnection]
} -body {
  list [catch {cdb2 cnonce} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 cnonce 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 cnonce 1 1}  errMsg] [normalizeResult $errMsg] \
      [normalizeResult [cdb2 cnonce $db]] \
      [normalizeResult [cdb2 run $db "SELECT 1"]] \
      [normalizeResult [cdb2 cnonce $db]]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg db
} -result {1 {wrong # args: should be "cdb2 cnonce connection"} 1\
<connection_not_found> 1 {wrong # args: should be "cdb2 cnonce connection"} {}\
{} <cnonce>}

###############################################################################

test cdb2-5.1 {encrypted sub-command} -setup {
  set db [openConnection]
} -body {
  list [catch {cdb2 encrypted} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 encrypted 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 encrypted 1 1} errMsg] [normalizeResult $errMsg] \
      [normalizeResult [cdb2 encrypted $db]]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg db
} -match regexp -result {^1 \{wrong # args: should be "cdb2 encrypted\
connection"\} 1 <connection_not_found> 1 \{wrong # args: should be "cdb2\
encrypted connection"\} (0|1)$}

###############################################################################

test cdb2-6.1 {hint sub-command} -setup {
  set db [openConnection]
} -body {
  list [catch {cdb2 hint} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 hint 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 hint $db}  errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 hint 1 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 hint $db 1}  errMsg] [normalizeResult $errMsg]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg db
} -result {1 {wrong # args: should be "cdb2 hint connection"} 1\
<connection_not_found> 0 {} 1 {wrong # args: should be "cdb2 hint connection"}\
1 {wrong # args: should be "cdb2 hint connection"}}

###############################################################################

test cdb2-7.1 {error sub-command} -setup {
  set db [openConnection]
} -body {
  list [catch {cdb2 error} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 error 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 error $db} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 run $db bad} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 error $db} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 error 1 1} errMsg] [normalizeResult $errMsg]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg db
} -result {1 {wrong # args: should be "cdb2 error connection"} 1\
<connection_not_found> 0 {} 1 {near "bad": syntax error} 0 {near "bad": syntax\
error} 1 {wrong # args: should be "cdb2 error connection"}}

###############################################################################

test cdb2-8.1 {run sub-command errors} -setup {
  set db [openConnection]
} -body {
  list [catch {cdb2 run} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 run 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 run $db}  errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 run $db 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 run $db "SELECT bad"} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 run $db 1 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 run $db 1 bad} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 run $db "SELECT bad" bad} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 run $db 1 1 1} errMsg] [normalizeResult $errMsg]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg db
} -result {1 {wrong # args: should be "cdb2 run connection sql ?types?"} 1\
{wrong # args: should be "cdb2 run connection sql ?types?"} 1 {wrong # args:\
should be "cdb2 run connection sql ?types?"} 1 {near "1": syntax error} 1 {no\
such column: bad} 1 {near "1": syntax error} 1 {name "bad" not found<lf>value\
for name "bad" not found} 1 {name "bad" not found<lf>value for name "bad" not\
found} 1 {wrong # args: should be "cdb2 run connection sql ?types?"}}

###############################################################################

test cdb2-8.2 {simple run sub-command} -setup {
  set db [openConnection]
} -body {
  list [catch {cdb2 run $db "SELECT 1"} errMsg] $errMsg \
      [getRowsOfColumns $db]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg db
} -result {0 {} {index 1 columns {{index 0 type integer size 8 name 1 null\
false value 1}} effects {affected 0 selected 1 updated 0 deleted 0 inserted 0}}}

###############################################################################

test cdb2-8.3 {run sub-command with results} -setup {
  set db [openConnection]
  set table [getTableName cdb2_83]

  cdb2 run $db [string trim [subst {
    CREATE TABLE $table (x INTEGER)
  }]]

  cdb2 run $db [string trim [subst {
    INSERT INTO $table (x) VALUES (1)
  }]]
} -body {
  list [catch {cdb2 run $db "SELECT x FROM $table"} errMsg] $errMsg \
      [getRowsOfColumns $db]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg table db
} -result {0 {} {index 1 columns {{index 0 type integer size 8 name x null\
false value 1}} effects {affected 0 selected 1 updated 0 deleted 0 inserted 0}}}

###############################################################################

test cdb2-8.4 {run sub-command with NULL results} -setup {
  set db [openConnection]
  set table [getTableName cdb2_84]

  cdb2 run $db [string trim [subst {
    CREATE TABLE $table (x INTEGER)
  }]]

  cdb2 run $db [string trim [subst {
    INSERT INTO $table (x) VALUES (NULL)
  }]]
} -body {
  list [catch {cdb2 run $db "SELECT x FROM $table"} errMsg] $errMsg \
      [getRowsOfColumns $db]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg table db
} -result {0 {} {index 1 columns {{index 0 type integer size 0 name x null\
true value <null>}} effects {affected 0 selected 1 updated 0 deleted 0 inserted\
0}}}

###############################################################################

test cdb2-9.1 {bind sub-command w/short} -setup {
  set db [openConnection]
  set table [getTableName cdb2_91]

  cdb2 run $db [string trim [subst {
    CREATE TABLE $table {schema {short x null=yes}}
  }]]
} -body {
  foreach value [getIntegers] {
    cdb2 unbind $db

    if {$value eq "NULL"} then {
      cdb2 bind $db 1 null
    } else {
      cdb2 bind $db 1 integer $value
    }

    if {[catch {
      cdb2 run $db [string trim [subst {
        INSERT INTO $table (x) VALUES (?)
      }]]
    } error] && ![isTypeError $error]} then {
      error $error; # FAIL: Unexpected error.
    }
  }

  cdb2 unbind $db; cdb2 run $db [string trim [subst {
    SELECT x FROM $table ORDER BY x
  }]]

  getValues $db 0
} -cleanup {
  closeConnection $db

  unset -nocomplain error value table db
} -result {}

###############################################################################

cleanupDatabase; # Cleanup test databases before changing the configuration.

###############################################################################

test cdb2-89.1 {configure sub-command errors} -body {
  list [catch {cdb2 configure} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 configure 1 1 1 1} errMsg] [normalizeResult $errMsg]
} -cleanup {
  unset -nocomplain errMsg
} -result {1 {wrong # args: should be "cdb2 configure string ?useFile?\
?reset?"} 1 {wrong # args: should be "cdb2 configure string ?useFile? ?reset?"}}

###############################################################################

catch {resetConfig false}; # Reset configuration and disable sockpool.

###############################################################################

test cdb2-89.2 {configure sub-command w/string} -body {
  list [resetConfig false] [cdb2 configure [getConfigInfo false]] \
      [catch {cdb2 open [getDbName]} result(1)] [normalizeResult $result(1)] \
      [catch {cdb2 close $result(1)} result(2)] [normalizeResult $result(2)] \
      [resetConfig false] [cdb2 configure [getConfigInfo true] 0] \
      [catch {cdb2 open [getDbName]} result(1)] [normalizeResult $result(1)] \
      [catch {cdb2 close $result(1)} result(2)] [normalizeResult $result(2)] \
      [resetConfig false] \
      [catch {cdb2 open [getDbName] local} result(1)] \
      [normalizeResult $result(1)] \
      [catch {cdb2 close $result(1)} result(2)] [normalizeResult $result(2)]
} -cleanup {
  catch {resetConfig}

  unset -nocomplain result
} -result {{} {} 1 <get_dbhosts_error> 1 <connection_not_found> {} {} 0\
<connection_open> 0 {} {} 0 <connection_open> 0 {}}

###############################################################################

catch {resetConfig false}; # Reset configuration and disable sockpool.

###############################################################################

test cdb2-89.3 {configure sub-command w/file} -setup {
  set fileName(bad) [file join [getTempPath] tclcdb2_89_3_bad.cfg]
  writeFile $fileName(bad) [getConfigInfo false]

  set fileName(good) [file join [getTempPath] tclcdb2_89_3_good.cfg]
  writeFile $fileName(good) [getConfigInfo true]
} -body {
  list [resetConfig false] [cdb2 configure $fileName(bad) 1] \
      [catch {cdb2 open [getDbName]} result(1)] [normalizeResult $result(1)] \
      [catch {cdb2 close $result(1)} result(2)] [normalizeResult $result(2)] \
      [resetConfig false] [cdb2 configure $fileName(good) 1] \
      [catch {cdb2 open [getDbName]} result(1)] [normalizeResult $result(1)] \
      [catch {cdb2 close $result(1)} result(2)] [normalizeResult $result(2)] \
      [resetConfig false] \
      [catch {cdb2 open [getDbName] local} result(1)] \
      [normalizeResult $result(1)] \
      [catch {cdb2 close $result(1)} result(2)] [normalizeResult $result(2)]
} -cleanup {
  catch {file delete $fileName(good)}
  catch {file delete $fileName(bad)}

  catch {resetConfig}

  unset -nocomplain result fileName
} -result {{} {} 1 <get_dbhosts_error> 1 <connection_not_found> {} {} 0\
<connection_open> 0 {} {} 0 <connection_open> 0 {}}

###############################################################################

catch {resetConfig true}; # Reset configuration and enable sockpool.

###############################################################################

test cdb2-99.1 {debug sub-command} -setup {
  set db [openConnection]
} -body {
  list [catch {cdb2 debug} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 debug 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 debug $db}  errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 debug 1 1} errMsg] [normalizeResult $errMsg] \
      [catch {cdb2 debug $db 1}  errMsg] [normalizeResult $errMsg]
} -cleanup {
  closeConnection $db

  unset -nocomplain errMsg db
} -result {1 {wrong # args: should be "cdb2 debug connection"} 1\
<connection_not_found> 0 {} 1 {wrong # args: should be "cdb2 debug connection"}\
1 {wrong # args: should be "cdb2 debug connection"}}

###############################################################################

if {0} then {
  #
  # TODO: Test the following sub-commands, variations, etc.
  #
  cdb2 bind
  cdb2 unbind
}

###############################################################################

unset -nocomplain path
::tcltest::cleanupTests
